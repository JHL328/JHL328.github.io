<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>VPN - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-12-22 11:14">
      2020年12月22日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      40
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="TLS-SSL-VPN设计基础"><a href="#TLS-SSL-VPN设计基础" class="headerlink" title="TLS/SSL VPN设计基础"></a>TLS/SSL VPN设计基础</h2><ul>
<li>VPN</li>
<li>TUN/TAP接口</li>
<li>路由</li>
<li>PKI相关</li>
<li>TLS/SSL加密</li>
</ul>
<h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1：设置虚拟机"><a href="#task-1：设置虚拟机" class="headerlink" title="task 1：设置虚拟机"></a>task 1：设置虚拟机</h3><table>
<thead>
<tr>
<th align="center">VPN Client/Host U</th>
<th align="center">10.0.2.4</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Gateway</strong></td>
<td align="center"><strong>10.0.2.5、192.168.60.1</strong></td>
</tr>
<tr>
<td align="center"><strong>Host V</strong></td>
<td align="center"><strong>192.168.60.101</strong></td>
</tr>
</tbody></table>
<p><img src="/2020/12/22/VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p>
<p>在建立VPN隧道之前，可以看到U是无法ping V的</p>
<h3 id="task-2：通过TUN-TAP建立VPN隧道"><a href="#task-2：通过TUN-TAP建立VPN隧道" class="headerlink" title="task 2：通过TUN/TAP建立VPN隧道"></a>task 2：通过TUN/TAP建立VPN隧道</h3><p><img src="/2020/12/22/VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p>
<h4 id="step-1：运行VPN-server"><a href="#step-1：运行VPN-server" class="headerlink" title="step 1：运行VPN server"></a>step 1：运行VPN server</h4><p>在Gateway上面按照步骤运行相关命令，之后可以看到对于tun0接口的配置如下，已经有了IP地址<code>192.168.53.1</code></p>
<p><img src="/2020/12/22/VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p>
<h4 id="step-2：运行VPN-client"><a href="#step-2：运行VPN-client" class="headerlink" title="step 2：运行VPN client"></a>step 2：运行VPN client</h4><p>和上面基本一样</p>
<p><img src="/2020/12/22/VPN/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p>
<h4 id="step-3：在client和server端建立路由"><a href="#step-3：在client和server端建立路由" class="headerlink" title="step 3：在client和server端建立路由"></a>step 3：在client和server端建立路由</h4><p>配置好的路由表应该如下</p>
<ul>
<li><strong>client端</strong></li>
</ul>
<p><img src="/2020/12/22/VPN/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p>
<ul>
<li><strong>server端</strong></li>
</ul>
<p><img src="/2020/12/22/VPN/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p>
<h4 id="step-4：设置V的路由"><a href="#step-4：设置V的路由" class="headerlink" title="step 4：设置V的路由"></a>step 4：设置V的路由</h4><p>根据对于整个发包流程的认识，其实在这一步我们所需要添加的就是如果包的目的IP是192.168.53.0/24的主机，需要通过<code>enp0s8</code>来发往<code>192.168.60.1</code>，这样当<code>Gateway</code>收到来自<code>host V</code>的回复之后，会通过<code>192.168.53.1</code>端口来进行转发数据包。</p>
<p><code>host V</code>路由表设置完之后如下</p>
<p><img src="/2020/12/22/VPN/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p>
<h4 id="step-5：测试VPN"><a href="#step-5：测试VPN" class="headerlink" title="step 5：测试VPN"></a>step 5：测试VPN</h4><p>首先是terminal上面的显示</p>
<p><img src="/2020/12/22/VPN/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p>
<p>可以看到是能够ping通的，之后来分析wireshark</p>
<p><img src="/2020/12/22/VPN/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p>
<p>其中，ICMP类型的包不是隧道流量，而在<code>10.0.2.4</code>和<code>10.0.2.5</code>之间流动的是隧道流量</p>
<p>同理，telnet的命令也是如此</p>
<p><img src="/2020/12/22/VPN/2-10.PNG" srcset="/img/loading.gif" alt="2-10">)<img src="/2020/12/22/VPN/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p>
<h4 id="step-6：破洞实验"><a href="#step-6：破洞实验" class="headerlink" title="step 6：破洞实验"></a>step 6：破洞实验</h4><p>当我们在保持telnet连接的时候停止运行vpnclient，此时输入的命令不会显示出来，连接断开</p>
<p><img src="/2020/12/22/VPN/2-12.PNG" srcset="/img/loading.gif" alt="2-12"></p>
<p>但是当我们重新建立连接的时候，会显示之前输入的字符串</p>
<p><img src="/2020/12/22/VPN/2-13.PNG" srcset="/img/loading.gif" alt="2-13"></p>
<h3 id="task-3：隧道加密"><a href="#task-3：隧道加密" class="headerlink" title="task 3：隧道加密"></a>task 3：隧道加密</h3><p>要保护隧道的完整性以及机密性，其中机密性是通过加密来实现的，完整性可以通过MAC来确保，参考：<a href="https://www.jianshu.com/p/9616b2d29954" target="_blank" rel="noopener">消息认证码MAC</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，直接用是不行的，因为<code>server-key.pem</code>证书过期，但是又不知道<code>cacert.pem</code>的密码，所以不能用原来的<code>cacert.pem</code>来为服务端重新签名一个证书，所以只能是自己生成一个根证书，之后再用自己的根证书给服务器签名，在这里，我们将服务端的域名命名为<code>jhlvpn.com</code></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在<code>cert_server</code>文件夹中</p>
<ul>
<li>首先生成自签名的根证书<code>cacert.pem</code>，运行命令</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">req</span> <span class="hljs-selector-tag">-new</span> <span class="hljs-selector-tag">-x509</span> <span class="hljs-selector-tag">-keyout</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre>

<p>之后需要设定文件密码，为<code>123456</code>，然后填写相关内容</p>
<p><img src="/2020/12/22/VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p>
<p>会生成<code>cacert.pem</code>文件和<code>cakey.pem</code>，即CA的证书文件和私钥</p>
<ul>
<li>之后，服务器产生一对私钥，采用des3加密</li>
</ul>
<pre><code class="hljs angelscript">openssl genrsa -des3 -<span class="hljs-keyword">out</span> server-key.pem <span class="hljs-number">1024</span></code></pre>

<p>文件密码还是<code>123456</code></p>
<ul>
<li>然后根据证书生成证书请求文件<code>server-csr.pem</code></li>
</ul>
<pre><code class="hljs pgsql">openssl req -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>-key.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>-csr.pem -config openssl.cnf</code></pre>

<p><img src="/2020/12/22/VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p>
<ul>
<li>生成服务端签名证书</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">ca</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">server-csr</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">server-cert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-cert</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-keyfile</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span>
<span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre>

<ul>
<li><p>之后把<code>cacert.pem</code>文件复制到<code>ca_client</code>文件夹下面</p>
</li>
<li><p>之后生成散列值并且利用散列值创建符号链接</p>
</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">x509</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-noout</span> <span class="hljs-selector-tag">-subject_hash</span>
<span class="hljs-selector-tag">ln</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> 3<span class="hljs-selector-tag">de75e64</span><span class="hljs-selector-class">.0</span></code></pre>

<p>之后运行程序，成功</p>
<ul>
<li><strong>server端</strong></li>
</ul>
<p><img src="/2020/12/22/VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p>
<ul>
<li><strong>client端</strong></li>
</ul>
<p><img src="/2020/12/22/VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p>
<p>同时，对wireshark抓包结果进行分析</p>
<p><img src="/2020/12/22/VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p>
<p>首先，能明显看到TCP连接建立的握手过程（SYN、ACK包）、数据传输的过程以及断开连接的过程（FIN、ACK包），同时随便选择一个数据包，分析Data字段，可以看到是加密传输，不是明文传输</p>
<p><img src="/2020/12/22/VPN/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p>
<h3 id="task-4：VPN服务器验证"><a href="#task-4：VPN服务器验证" class="headerlink" title="task 4：VPN服务器验证"></a>task 4：VPN服务器验证</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>在建立VPN之前，要对VPN服务器进行验证，是通过使用公钥证书的方式来实现的</p>
<p>具体分为三部：1.首先要验证服务器证书有效 2.验证服务器是证书的所有者 3.验证服务器是目标服务器</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><ul>
<li><p><strong>指出执行上述验证的代码行</strong></p>
<p>  首先，验证部分包括服务端发送服务器证书以及客户端对于证书的验证过程</p>
<p>  <strong>server</strong></p>
</li>
</ul>
<pre><code class="hljs c"><span class="hljs-comment">// Step 0: OpenSSL library initialization </span>
<span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>
SSL_library_init();<span class="hljs-comment">//进行协议初始化工作</span>
SSL_load_error_strings();<span class="hljs-comment">//加载错误信息</span>
SSLeay_add_ssl_algorithms();<span class="hljs-comment">//添加SSL加密算法</span>


<span class="hljs-comment">// Step 1: SSL context initialization</span>
meth = (SSL_METHOD *)TLSv1_2_method();
ctx = SSL_CTX_new(meth);<span class="hljs-comment">//创建会话环境</span>
SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//指定握手阶段的证书验证方式，SSL_VERIFY_NONE表示完全忽略验证证书的结果</span>


<span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>
SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>, SSL_FILETYPE_PEM);
SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>, SSL_FILETYPE_PEM);
<span class="hljs-comment">//加载服务端证书和私钥</span>

<span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>
ssl = SSL_new (ctx);</code></pre>

<p>​    <strong>client</strong></p>
<pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">setupTLSClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname)</span></span>
<span class="hljs-function"></span>&#123;
   <span class="hljs-comment">// Step 0: OpenSSL library initialization </span>
   <span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>
   SSL_library_init();
   SSL_load_error_strings();
   SSLeay_add_ssl_algorithms();

   SSL_METHOD *meth;
   SSL_CTX* ctx;
   SSL* ssl;

   meth = (SSL_METHOD *)TLSv1_2_method();
   ctx = SSL_CTX_new(meth);

   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//SSL_VERIFY_PEER表示希望验证对方证书</span>
   <span class="hljs-keyword">if</span>(SSL_CTX_load_verify_locations(ctx,<span class="hljs-literal">NULL</span>, CA_DIR) &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//SSL_CTX_load_verify_locations为CA证书所在目录，这里实现了上面所说的步骤一对于服务器证书的验证：利用CA_DIR目录下面的CA证书去验证服务器证书是否有效</span>
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error setting the verify locations. \n"</span>);
	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
   &#125;
   ssl = SSL_new (ctx);

   X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl); 
   X509_VERIFY_PARAM_set1_host(vpm, hostname, <span class="hljs-number">0</span>);<span class="hljs-comment">//实现步骤三对于hostname的验证，检查服务器hostname</span>

   <span class="hljs-keyword">return</span> ssl;
&#125;</code></pre>

<p>而第二步的检查在验证证书合法性的时候就已经验证了</p>
<h3 id="task-5：VPN客户端验证"><a href="#task-5：VPN客户端验证" class="headerlink" title="task 5：VPN客户端验证"></a>task 5：VPN客户端验证</h3><p>在这一个task当中，我们需要对VPN客户端进行验证，client会向server端发送username和password，之后server端通过shadow文件匹配来验证对方身份</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在server端加入对用户信息的请求，用户在终端上输入username以及password，参考文档的3.3节</p>
<h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><ul>
<li>在server端添加<code>loginrequest()</code>函数，以及通过<code>login()</code>来进行信息的验证</li>
</ul>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginRequest</span><span class="hljs-params">(SSL* ssl,<span class="hljs-keyword">int</span> sock)</span></span>&#123;    
	<span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];
	<span class="hljs-keyword">char</span> username[<span class="hljs-number">1024</span>];
	<span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];
    
	<span class="hljs-comment">//将请求用户名的语句SSL_write到Client,从client端读取到的后面的输入字符串SSL_read到username</span>
	<span class="hljs-keyword">char</span>* requsr = <span class="hljs-string">"Please enter username:"</span>;
	SSL_write(ssl,requsr,<span class="hljs-built_in">strlen</span>(requsr));
	<span class="hljs-keyword">int</span> usrlen = SSL_read(ssl,username,<span class="hljs-keyword">sizeof</span>(username)<span class="hljs-number">-1</span>);
	username[usrlen] = <span class="hljs-string">'\0'</span>;
    
	<span class="hljs-comment">//将请求用户口令的语句SSL_write到Client,从client端读取到的输入字符串SSL_read到 password</span>
	<span class="hljs-keyword">char</span>* reqpsd = <span class="hljs-string">"Please enter password:"</span>;
	SSL_write(ssl,reqpsd,<span class="hljs-built_in">strlen</span>(reqpsd));
	<span class="hljs-keyword">int</span> psdlen = SSL_read(ssl,password,<span class="hljs-keyword">sizeof</span>(password)<span class="hljs-number">-1</span>);
	password[psdlen] = <span class="hljs-string">'\0'</span>;
    
	login(username,password); <span class="hljs-comment">//检查shadow文件中是否有该用户的信息</span>
&#125;</code></pre>

<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">char</span> *passwd)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spwd</span> *<span class="hljs-title">pw</span>;</span>
	<span class="hljs-keyword">char</span> *epasswd;
	pw = getspnam(user);

	<span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">NULL</span>) &#123;
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Login name: %s\n"</span>, pw-&gt;sp_namp);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Passwd : %s\n"</span>, pw-&gt;sp_pwdp);

	epasswd = crypt(passwd, pw-&gt;sp_pwdp);
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(epasswd, pw-&gt;sp_pwdp)) &#123;
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	&#125;
&#125;</code></pre>

<p>对<code>main()</code>函数中只需要在处理client的GET请求的<code>processRequest()</code>函数之前加上<code>loginrequest()</code>即可</p>
<ul>
<li>client端在收到来自于server端的用户信息的请求之后，就直接<code>scanf()</code>输入即可，但是要求用户密码不可见，就用<code>getpass()</code>函数即可</li>
</ul>
<pre><code class="hljs c"><span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection using %s\n"</span>, SSL_get_cipher(ssl));

<span class="hljs-comment">/*----------------Send username &amp; password-------------*/</span>
<span class="hljs-keyword">int</span> len1;
<span class="hljs-keyword">char</span> username[<span class="hljs-number">20</span>];
<span class="hljs-keyword">char</span>* password;
<span class="hljs-keyword">char</span> usrbuf[<span class="hljs-number">1000</span>];
<span class="hljs-keyword">char</span> pwdbuf[<span class="hljs-number">1000</span>];

len1 = SSL_read (ssl, usrbuf, <span class="hljs-keyword">sizeof</span>(usrbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read来获取Server的请求用户名的信息</span>
usrbuf[len1] = <span class="hljs-string">'\0'</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, usrbuf);
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s:"</span>,username);
SSL_write (ssl,username,<span class="hljs-built_in">strlen</span>(username));<span class="hljs-comment">//将username通过SSL_write到Server</span>


len1 = SSL_read (ssl, pwdbuf, <span class="hljs-keyword">sizeof</span>(pwdbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read到Server的请求用户口令的信息</span>
pwdbuf[len1] = <span class="hljs-string">'\0'</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, pwdbuf);
password = getpass(<span class="hljs-string">""</span>);
SSL_write(ssl,password,<span class="hljs-built_in">strlen</span>(password));<span class="hljs-comment">//将password SSL_write到Server</span>

<span class="hljs-comment">/*----------------Send/Receive data --------------------*/</span></code></pre>

<p>运行结果如下：</p>
<p><strong>client端</strong></p>
<p><img src="/2020/12/22/VPN/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p>
<p><strong>server端</strong></p>
<p><img src="/2020/12/22/VPN/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p>
<p>而当我们没有正确的输入用户名和密码的时候，用户端会直接退出</p>
<p><img src="/2020/12/22/VPN/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p>
<h3 id="task-6：支持多进程"><a href="#task-6：支持多进程" class="headerlink" title="task 6：支持多进程"></a>task 6：支持多进程</h3><p><img src="/2020/12/22/VPN/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p>
<p>在之前的task当中，我们只是实现了数据的加密传输（SSL），但是还没有完全的实现VPN，因为没用通过使用TUN接口来构建VPN隧道，所以接下来我们实际要实现的就是在多进程的条件下来实现我们对于TUN接口的使用</p>
<ul>
<li><strong>client端</strong></li>
</ul>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span>
<span class="hljs-function"></span>&#123;<span class="hljs-comment">//该函数的作用就是新建一个tun接口并且返回对应的文件描述符，无需修改，直接加到tlsclient即可</span>
   <span class="hljs-keyword">int</span> tunfd;
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>
   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));

   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;  

   tunfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/net/tun"</span>, O_RDWR);
   ioctl(tunfd, TUNSETIFF, &amp;ifr);       

   <span class="hljs-keyword">return</span> tunfd;
&#125;


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-keyword">char</span> buff[BUFF_SIZE];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN\n"</span>);
    
	bzero(buff, BUFF_SIZE);
	len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);<span class="hljs-comment">//read函数将从tunfd当中的数据读取到buff当中</span>
	<span class="hljs-comment">//sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr,sizeof(peerAddr));</span>
	SSL_write(ssl,buff,len);<span class="hljs-comment">//写给ssl套接字</span>
&#125;


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-keyword">char</span> buff[BUFF_SIZE];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel\n"</span>);
    
	bzero(buff, BUFF_SIZE);
	<span class="hljs-comment">//len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL);</span>
	len = SSL_read(ssl,buff,<span class="hljs-keyword">sizeof</span>(buff)<span class="hljs-number">-1</span>);
	<span class="hljs-built_in">write</span>(tunfd, buff, len);<span class="hljs-comment">//写给tunfd来进行外层的解包</span>
&#125;</code></pre>

<ul>
<li><strong>server端</strong>，所需要的函数和上面基本一样，在main里面的修改如下</li>
</ul>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
    <span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);
    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span>
       <span class="hljs-built_in">close</span> (listen_sock);

       SSL_set_fd (ssl, sock);
       <span class="hljs-keyword">int</span> err = SSL_accept (ssl);
       CHK_SSL(err);
       <span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established!\n"</span>);

       loginrequest(ssl, sock);
       processRequest(ssl, sock);
       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
          fd_set readFDSet;
          FD_ZERO(&amp;readFDSet);
          FD_SET(sock, &amp;readFDSet);
          FD_SET(tunfd, &amp;readFDSet);
          select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);

          <span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, ssl);
          <span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(tunfd, ssl);

       &#125;
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span>
        <span class="hljs-built_in">close</span>(sock);
    &#125;
  &#125;</code></pre>

<p>之后就按照task 2的一些步骤来弄就行</p>
<h4 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h4><p>在pipe的是相当中，会区分父子进程，父进程负责将从tun接口收到的数据发给子进程，而子进程有两种情况要处理，第一种是将来自父进程的数据通过通过ssl/tls发给客户端进程，第二种是将来自于客户端的程序传递给tun接口</p>
<p>具体实现</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunPipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> pipefd)</span> </span>&#123;
    <span class="hljs-comment">//该函数的作用是实现父进程的作用，从tun接口通过read来把数据读取到pipe的输出端口上</span>
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-keyword">char</span> buff[BUFF_SIZE];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);
    
	bzero(buff, BUFF_SIZE);
	len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);
	buff[len] = <span class="hljs-string">'\0'</span>;
	<span class="hljs-built_in">write</span>(pipefd, buff, len);
&#125;</code></pre>

<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl)</span> </span>&#123;
    <span class="hljs-comment">//该函数的作用是实现子进程从父进程通过pipe来得到的数据写入到ssl的socket上</span>
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-keyword">char</span> buff[BUFF_SIZE];
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);

    bzero(buff, BUFF_SIZE);
	len = <span class="hljs-built_in">read</span>(pipefd, buff, BUFF_SIZE);
	buff[len] = <span class="hljs-string">'\0'</span>;
	SSL_write(ssl, buff, len);
&#125;</code></pre>

<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl, <span class="hljs-keyword">int</span> tunfd)</span> </span>&#123;
    <span class="hljs-comment">//该函数的作用是将来自客户端的程序发给了</span>
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-keyword">char</span> buff[BUFF_SIZE];
	<span class="hljs-keyword">char</span> *ptr = buff;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel established \n"</span>);
    
	bzero(buff, BUFF_SIZE);
	len = SSL_read(ssl, buff, BUFF_SIZE);
	buff[len] = <span class="hljs-string">'\0'</span>;
	<span class="hljs-built_in">write</span>(tunfd, buff, len);
&#125;</code></pre>

<p>对于<code>main()</code>函数的修改</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
	SSL_METHOD *meth;
	SSL_CTX* ctx;
	SSL *ssl;
	<span class="hljs-keyword">int</span> err;
    
	<span class="hljs-comment">// Step 0: OpenSSL library initialization</span>
	<span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>
	SSL_library_init();
	SSL_load_error_strings();
	SSLeay_add_ssl_algorithms();
    
	<span class="hljs-comment">// Step 1: SSL context initialization</span>
	meth = (SSL_METHOD *)TLSv1_2_method();
	ctx = SSL_CTX_new(meth);
	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);
    
	<span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>
	SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>,SSL_FILETYPE_PEM);
	SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>,SSL_FILETYPE_PEM);

    <span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>
	ssl = SSL_new (ctx);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa_client</span>;</span>
	<span class="hljs-keyword">size_t</span> client_len;
	<span class="hljs-keyword">int</span> tunfd = createTunDevice();
	<span class="hljs-keyword">int</span> listen_sock = setupTCPServer();
    
	<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>];<span class="hljs-comment">//pipe输入端和pipe输出端</span>
	<span class="hljs-keyword">pid_t</span> pid;
    
	pipe(fd);
	pid = fork();<span class="hljs-comment">//fork子进程，pid为子进程id</span>
	<span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;
		perror(<span class="hljs-string">"fork"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
	&#125;
	<span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;
		<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);
		<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
			fd_set readFDSet;
			FD_ZERO(&amp;readFDSet);
			FD_SET(tunfd, &amp;readFDSet);
			select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
			<span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunPipeSelected(tunfd, fd[<span class="hljs-number">1</span>]);
		&#125;
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	&#125;	
	<span class="hljs-keyword">else</span>&#123;
		<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
		<span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);
		<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span>
			<span class="hljs-built_in">close</span> (listen_sock);
            
			SSL_set_fd (ssl, sock);
			<span class="hljs-keyword">int</span> err = SSL_accept (ssl);
			CHK_SSL(err);
			<span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established in child process!\n"</span>);
			loginRequest(ssl,sock);
			processRequest(ssl, sock);
			<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
				fd_set readFDSet;
                
				FD_ZERO(&amp;readFDSet);
				FD_SET(sock, &amp;readFDSet);
				FD_SET(fd[<span class="hljs-number">0</span>], &amp;readFDSet);
                
				select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
				<span class="hljs-keyword">if</span> (FD_ISSET(fd[<span class="hljs-number">0</span>],&amp;readFDSet)) pipeSelected(fd[<span class="hljs-number">0</span>], sock, ssl);
				<span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(fd[<span class="hljs-number">0</span>],sock,ssl,tunfd);
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span>
				<span class="hljs-built_in">close</span>(sock);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p>并且此时并不需要在单线程的时候所写的<code>socketSelecct()</code>和<code>tunSelect()</code>，</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Network-Security/">Network Security</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统lab6实验报告</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/">
                        <span class="hidden-mobile">SQL注入实验</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "VPN&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
